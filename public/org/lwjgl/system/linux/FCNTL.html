<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) -->
<title>FCNTL (LWJGL 3.3.2-snapshot)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.lwjgl.system.linux, class: FCNTL">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li><a href="#field-summary">Field</a></li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.lwjgl.system.linux</a></div>
<h1 title="Class FCNTL" class="title">Class FCNTL</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.lwjgl.system.linux.FCNTL</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">FCNTL</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Native bindings to &lt;fcntl.h&gt;.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#DN_ACCESS" class="member-name-link">DN_ACCESS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#DN_ATTRIB" class="member-name-link">DN_ATTRIB</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#DN_CREATE" class="member-name-link">DN_CREATE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#DN_DELETE" class="member-name-link">DN_DELETE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#DN_MODIFY" class="member-name-link">DN_MODIFY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#DN_MULTISHOT" class="member-name-link">DN_MULTISHOT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#DN_RENAME" class="member-name-link">DN_RENAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_ADD_SEALS" class="member-name-link">F_ADD_SEALS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_DUPFD" class="member-name-link">F_DUPFD</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_DUPFD_CLOEXEC" class="member-name-link">F_DUPFD_CLOEXEC</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_EXLCK" class="member-name-link">F_EXLCK</a></code></div>
<div class="col-last even-row-color">
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_GET_FILE_RW_HINT" class="member-name-link">F_GET_FILE_RW_HINT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_GET_RW_HINT" class="member-name-link">F_GET_RW_HINT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_GET_SEALS" class="member-name-link">F_GET_SEALS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_GETFD" class="member-name-link">F_GETFD</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_GETFL" class="member-name-link">F_GETFL</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_GETLEASE" class="member-name-link">F_GETLEASE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_GETLK" class="member-name-link">F_GETLK</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_GETOWN" class="member-name-link">F_GETOWN</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_GETOWN_EX" class="member-name-link">F_GETOWN_EX</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_GETPIPE_SZ" class="member-name-link">F_GETPIPE_SZ</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_GETSIG" class="member-name-link">F_GETSIG</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_NOTIFY" class="member-name-link">F_NOTIFY</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_OFD_GETLK" class="member-name-link">F_OFD_GETLK</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_OFD_SETLK" class="member-name-link">F_OFD_SETLK</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_OFD_SETLKW" class="member-name-link">F_OFD_SETLKW</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_OWNER_PGRP" class="member-name-link">F_OWNER_PGRP</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a><code>::type</code> values.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_OWNER_PID" class="member-name-link">F_OWNER_PID</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a><code>::type</code> values.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_OWNER_TID" class="member-name-link">F_OWNER_TID</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a><code>::type</code> values.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_RDLCK" class="member-name-link">F_RDLCK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SEAL_FUTURE_WRITE" class="member-name-link">F_SEAL_FUTURE_WRITE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SEAL_GROW" class="member-name-link">F_SEAL_GROW</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SEAL_SEAL" class="member-name-link">F_SEAL_SEAL</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SEAL_SHRINK" class="member-name-link">F_SEAL_SHRINK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SEAL_WRITE" class="member-name-link">F_SEAL_WRITE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SET_FILE_RW_HINT" class="member-name-link">F_SET_FILE_RW_HINT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SET_RW_HINT" class="member-name-link">F_SET_RW_HINT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SETFD" class="member-name-link">F_SETFD</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SETFL" class="member-name-link">F_SETFL</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SETLEASE" class="member-name-link">F_SETLEASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SETLK" class="member-name-link">F_SETLK</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SETLKW" class="member-name-link">F_SETLKW</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SETOWN" class="member-name-link">F_SETOWN</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SETOWN_EX" class="member-name-link">F_SETOWN_EX</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SETPIPE_SZ" class="member-name-link">F_SETPIPE_SZ</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_SETSIG" class="member-name-link">F_SETSIG</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_SHLCK" class="member-name-link">F_SHLCK</a></code></div>
<div class="col-last even-row-color">
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#F_UNLCK" class="member-name-link">F_UNLCK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#F_WRLCK" class="member-name-link">F_WRLCK</a></code></div>
<div class="col-last even-row-color">
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#FD_CLOEXEC" class="member-name-link">FD_CLOEXEC</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#LOCK_EX" class="member-name-link">LOCK_EX</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#LOCK_MAND" class="member-name-link">LOCK_MAND</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#LOCK_NB" class="member-name-link">LOCK_NB</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#LOCK_READ" class="member-name-link">LOCK_READ</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#LOCK_RW" class="member-name-link">LOCK_RW</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#LOCK_SH" class="member-name-link">LOCK_SH</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#LOCK_UN" class="member-name-link">LOCK_UN</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#LOCK_WRITE" class="member-name-link">LOCK_WRITE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_ACCMODE" class="member-name-link">O_ACCMODE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_APPEND" class="member-name-link">O_APPEND</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_ASYNC" class="member-name-link">O_ASYNC</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_CLOEXEC" class="member-name-link">O_CLOEXEC</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_CREAT" class="member-name-link">O_CREAT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_DIRECT" class="member-name-link">O_DIRECT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_DIRECTORY" class="member-name-link">O_DIRECTORY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_DSYNC" class="member-name-link">O_DSYNC</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_EXCL" class="member-name-link">O_EXCL</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_LARGEFILE" class="member-name-link">O_LARGEFILE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_NDELAY" class="member-name-link">O_NDELAY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_NOATIME" class="member-name-link">O_NOATIME</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_NOCTTY" class="member-name-link">O_NOCTTY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_NOFOLLOW" class="member-name-link">O_NOFOLLOW</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_NONBLOCK" class="member-name-link">O_NONBLOCK</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_PATH" class="member-name-link">O_PATH</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_RDONLY" class="member-name-link">O_RDONLY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_RDWR" class="member-name-link">O_RDWR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_SYNC" class="member-name-link">O_SYNC</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_TMPFILE" class="member-name-link">O_TMPFILE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#O_TRUNC" class="member-name-link">O_TRUNC</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#O_WRONLY" class="member-name-link">O_WRONLY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#RWH_WRITE_LIFE_EXTREME" class="member-name-link">RWH_WRITE_LIFE_EXTREME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#RWH_WRITE_LIFE_LONG" class="member-name-link">RWH_WRITE_LIFE_LONG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#RWH_WRITE_LIFE_MEDIUM" class="member-name-link">RWH_WRITE_LIFE_MEDIUM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#RWH_WRITE_LIFE_NONE" class="member-name-link">RWH_WRITE_LIFE_NONE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#RWH_WRITE_LIFE_NOT_SET" class="member-name-link">RWH_WRITE_LIFE_NOT_SET</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#RWH_WRITE_LIFE_SHORT" class="member-name-link">RWH_WRITE_LIFE_SHORT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IFBLK" class="member-name-link">S_IFBLK</a></code></div>
<div class="col-last even-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IFCHR" class="member-name-link">S_IFCHR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IFDIR" class="member-name-link">S_IFDIR</a></code></div>
<div class="col-last even-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IFIFO" class="member-name-link">S_IFIFO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IFLNK" class="member-name-link">S_IFLNK</a></code></div>
<div class="col-last even-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IFMT" class="member-name-link">S_IFMT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IFREG" class="member-name-link">S_IFREG</a></code></div>
<div class="col-last even-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IFSOCK" class="member-name-link">S_IFSOCK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File types encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IRGRP" class="member-name-link">S_IRGRP</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IROTH" class="member-name-link">S_IROTH</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IRUSR" class="member-name-link">S_IRUSR</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IRWXG" class="member-name-link">S_IRWXG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IRWXO" class="member-name-link">S_IRWXO</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IRWXU" class="member-name-link">S_IRWXU</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_ISGID" class="member-name-link">S_ISGID</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_ISUID" class="member-name-link">S_ISUID</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_ISVTX" class="member-name-link">S_ISVTX</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IWGRP" class="member-name-link">S_IWGRP</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IWOTH" class="member-name-link">S_IWOTH</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IWUSR" class="member-name-link">S_IWUSR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IXGRP" class="member-name-link">S_IXGRP</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#S_IXOTH" class="member-name-link">S_IXOTH</a></code></div>
<div class="col-last odd-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#S_IXUSR" class="member-name-link">S_IXUSR</a></code></div>
<div class="col-last even-row-color">
<div class="block">File mode bits encoded in type <code>mode_t</code>.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#creat(java.lang.CharSequence,int)" class="member-name-link">creat</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pathname,
 int&nbsp;mode)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Equivalent to <code>open()</code> with <code>flags</code> equal to <code>O_CREAT|O_WRONLY|O_TRUNC</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#creat(java.nio.ByteBuffer,int)" class="member-name-link">creat</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pathname,
 int&nbsp;mode)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Equivalent to <code>open()</code> with <code>flags</code> equal to <code>O_CREAT|O_WRONLY|O_TRUNC</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fcntl(int,int)" class="member-name-link">fcntl</a><wbr>(int&nbsp;fd,
 int&nbsp;cmd)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Performs one of the operations determined by <code>cmd</code> on the open file descriptor <code>fd</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fcntli(int,int,int)" class="member-name-link">fcntli</a><wbr>(int&nbsp;fd,
 int&nbsp;cmd,
 int&nbsp;arg)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> overload that takes a third argument of type <code>int</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fcntlp(int,int,long)" class="member-name-link">fcntlp</a><wbr>(int&nbsp;fd,
 int&nbsp;cmd,
 long&nbsp;arg)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> overload that takes a third argument of type <code>void *</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ncreat(long,int)" class="member-name-link">ncreat</a><wbr>(long&nbsp;pathname,
 int&nbsp;mode)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#creat(java.nio.ByteBuffer,int)"><code>creat(java.nio.ByteBuffer, int)</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nfcntli(int,int,int)" class="member-name-link">nfcntli</a><wbr>(int&nbsp;fd,
 int&nbsp;cmd,
 int&nbsp;arg)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#fcntli(int,int,int)"><code>fcntli(int, int, int)</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nfcntlp(int,int,long)" class="member-name-link">nfcntlp</a><wbr>(int&nbsp;fd,
 int&nbsp;cmd,
 long&nbsp;arg)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#fcntlp(int,int,long)"><code>fcntlp(int, int, long)</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nopen(long,int,int)" class="member-name-link">nopen</a><wbr>(long&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#open(java.nio.ByteBuffer,int,int)"><code>open(java.nio.ByteBuffer, int, int)</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nopenat(int,long,int,int)" class="member-name-link">nopenat</a><wbr>(int&nbsp;dirfd,
 long&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#openat(int,java.nio.ByteBuffer,int,int)"><code>openat(int, java.nio.ByteBuffer, int, int)</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#open(java.lang.CharSequence,int,int)" class="member-name-link">open</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a <code>pathname</code> for a file, <code>open()</code> returns a file descriptor, a small, nonnegative integer for use in subsequent system calls
 (<code>read(2)</code>, <code>write(2)</code>, <code>lseek(2)</code>, <code>fcntl(2)</code>, etc.).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#open(java.nio.ByteBuffer,int,int)" class="member-name-link">open</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a <code>pathname</code> for a file, <code>open()</code> returns a file descriptor, a small, nonnegative integer for use in subsequent system calls
 (<code>read(2)</code>, <code>write(2)</code>, <code>lseek(2)</code>, <code>fcntl(2)</code>, etc.).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#openat(int,java.lang.CharSequence,int,int)" class="member-name-link">openat</a><wbr>(int&nbsp;dirfd,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">The <code>openat()</code> system call operates in exactly the same way as <code>open(2)</code>, except for the differences described in this manual page.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#openat(int,java.nio.ByteBuffer,int,int)" class="member-name-link">openat</a><wbr>(int&nbsp;dirfd,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">The <code>openat()</code> system call operates in exactly the same way as <code>open(2)</code>, except for the differences described in this manual page.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="O_ACCMODE">
<h3>O_ACCMODE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_ACCMODE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_ACCMODE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_RDONLY">
<h3>O_RDONLY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_RDONLY</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_RDONLY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_WRONLY">
<h3>O_WRONLY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_WRONLY</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_WRONLY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_RDWR">
<h3>O_RDWR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_RDWR</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_RDWR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_APPEND">
<h3>O_APPEND</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_APPEND</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_APPEND">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_ASYNC">
<h3>O_ASYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_ASYNC</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_ASYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_CLOEXEC">
<h3>O_CLOEXEC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_CLOEXEC</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_CLOEXEC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_CREAT">
<h3>O_CREAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_CREAT</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_CREAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_DIRECT">
<h3>O_DIRECT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_DIRECT</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_DIRECT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_DIRECTORY">
<h3>O_DIRECTORY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_DIRECTORY</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_DIRECTORY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_DSYNC">
<h3>O_DSYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_DSYNC</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_DSYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_EXCL">
<h3>O_EXCL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_EXCL</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_EXCL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_LARGEFILE">
<h3>O_LARGEFILE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_LARGEFILE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_LARGEFILE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_NOATIME">
<h3>O_NOATIME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_NOATIME</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_NOATIME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_NOCTTY">
<h3>O_NOCTTY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_NOCTTY</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_NOCTTY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_NOFOLLOW">
<h3>O_NOFOLLOW</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_NOFOLLOW</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_NOFOLLOW">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_NONBLOCK">
<h3>O_NONBLOCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_NONBLOCK</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_NONBLOCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_NDELAY">
<h3>O_NDELAY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_NDELAY</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_NDELAY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_PATH">
<h3>O_PATH</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_PATH</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_PATH">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_SYNC">
<h3>O_SYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_SYNC</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_SYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_TMPFILE">
<h3>O_TMPFILE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_TMPFILE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_TMPFILE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="O_TRUNC">
<h3>O_TRUNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">O_TRUNC</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#O_ACCMODE"><code>O_ACCMODE</code></a></li>
 <li><a href="#O_RDONLY"><code>O_RDONLY</code></a></li>
 <li><a href="#O_WRONLY"><code>O_WRONLY</code></a></li>
 <li><a href="#O_RDWR"><code>O_RDWR</code></a></li>
 <li><a href="#O_APPEND"><code>O_APPEND</code></a> - 
 The file is opened in append mode.
 
 <p>Before each <code>write(2)</code>, the file offset is positioned at the end of the file, as if with <code>lseek(2)</code>. <code>O_APPEND</code> may lead to
 corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a
 file, so the client kernel has to simulate it, which can't be done without a race condition.</p>
 </li>
 <li><a href="#O_ASYNC"><code>O_ASYNC</code></a> - 
 Enable signal-driven I/O: generate a signal (<code>SIGIO</code> by default, but this can be changed via <code>fcntl(2)</code>) when input or output becomes
 possible on this file descriptor.
 
 <p>This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See <code>fcntl(2)</code> for further
 details.</p>
 </li>
 <li><a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> - 
 Enable the close-on-exec flag for the new file descriptor.
 
 <p>Specifying this flag permits a program to avoid additional <code>fcntl(2) F_SETFD</code> operations to set the <code>FD_CLOEXEC</code> flag. Additionally,
 use of this flag is essential in some multithreaded programs since using a separate <code>fcntl(2) F_SETFD</code> operation to set the
 <code>FD_CLOEXEC</code> flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does
 a <code>fork(2)</code> plus <code>execve(2)</code>.</p>
 </li>
 <li><a href="#O_CREAT"><code>O_CREAT</code></a> - 
 If the file does not exist it will be created.
 
 <p>The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group
 ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent
 directory, see the mount options <code>bsdgroups</code> and <code>sysvgroups</code> described in <code>mount(8)</code>).</p>
 </li>
 <li><a href="#O_DIRECT"><code>O_DIRECT</code></a> - 
 Try to minimize cache effects of the I/O to and from this file.
 
 <p>In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I/O is done
 directly to/from user-space buffers. The <code>O_DIRECT</code> flag on its own makes an effort to transfer data synchronously, but does not give the
 guarantees of the <code>O_SYNC</code> flag that data and necessary metadata are transferred. To guarantee synchronous I/O, <code>O_SYNC</code> must be used
 in addition to <code>O_DIRECT</code>.</p>
 
 <p>A semantically similar (but deprecated) interface for block devices is described in <code>raw(8)</code>.</p>
 </li>
 <li><a href="#O_DIRECTORY"><code>O_DIRECTORY</code></a> - 
 If pathname is not a directory, cause the open to fail.
 
 <p>This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if <code>opendir(3)</code> is called on a FIFO
 or tape device, but should not be used outside of the implementation of <code>opendir(3)</code>.</p>
 </li>
 <li><a href="#O_DSYNC"><code>O_DSYNC</code></a></li>
 <li><a href="#O_EXCL"><code>O_EXCL</code></a> - 
 Ensure that this call creates the file: if this flag is specified in conjunction with <code>O_CREAT</code>, and pathname already exists, then
 <code>open()</code> will fail.
 
 <p>When these two flags are specified, symbolic links are not followed: if <code>pathname</code> is a symbolic link, then <code>open()</code> fails regardless
 of where the symbolic link points to.</p>
 
 <p>In general, the behavior of <code>O_EXCL</code> is undefined if it is used without <code>O_CREAT</code>. There is one exception: on Linux 2.6 and later,
 <code>O_EXCL</code> can be used without <code>O_CREAT</code> if <code>pathname</code> refers to a block device. If the block device is in use by the system (e.g.,
 mounted), <code>open()</code> fails with the error <code>EBUSY</code>.</p>
 
 <p>On NFS, <code>O_EXCL</code> is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where <code>O_EXCL</code> support is not
 provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file
 locking using a lockfile, and need to avoid reliance on NFS support for <code>O_EXCL</code>, can create a unique file on the same file system (e.g.,
 incorporating hostname and PID), and use <code>link(2)</code> to make a link to the lockfile. If <code>link(2)</code> returns 0, the lock is successful.
 Otherwise, use <code>stat(2)</code> on the unique file to check if its link count has increased to 2, in which case the lock is also successful.</p>
 </li>
 <li><a href="#O_LARGEFILE"><code>O_LARGEFILE</code></a> - 
 (LFS) Allow files whose sizes cannot be represented in an <code>off_t</code> (but can be represented in an <code>off64_t</code>) to be opened.
 
 <p>The <code>_LARGEFILE64_SOURCE</code> macro must be defined (before including any header files) in order to obtain this definition. Setting the
 <code>_FILE_OFFSET_BITS</code> feature test macro to 64 (rather than using <code>O_LARGEFILE</code>) is the preferred method of accessing large files on
 32-bit systems (see <code>feature_test_macros(7)</code>).</p>
 </li>
 <li><a href="#O_NOATIME"><code>O_NOATIME</code></a> - 
 Do not update the file last access time (<code>st_atime</code> in the <code>inode</code>) when the file is <code>read(2)</code>.
 
 <p>This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not
 be effective on all file systems. One example is NFS, where the server maintains the access time.</p>
 </li>
 <li><a href="#O_NOCTTY"><code>O_NOCTTY</code></a> - 
 If <code>pathname</code> refers to a terminal device --see <code>tty(4)</code>-- it will not become the process's controlling terminal even if the process
 does not have one.
 </li>
 <li><a href="#O_NOFOLLOW"><code>O_NOFOLLOW</code></a> - 
 If <code>pathname</code> is a symbolic link, then the open fails.
 
 <p>This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the <code>pathname</code> will still
 be followed.</p>
 </li>
 <li><a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> - 
 When possible, the file is opened in nonblocking mode.
 
 <p>Neither the <code>open()</code> nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the
 handling of FIFOs (named pipes), see also <code>fifo(7)</code>. For a discussion of the effect of <code>O_NONBLOCK</code> in conjunction with mandatory file
 locks and with file leases, see <code>fcntl(2)</code>.</p>
 </li>
 <li><a href="#O_NDELAY"><code>O_NDELAY</code></a></li>
 <li><a href="#O_PATH"><code>O_PATH</code></a></li>
 <li><a href="#O_SYNC"><code>O_SYNC</code></a> - 
 The file is opened for synchronous I/O.
 
 <p>Any <code>write(2)</code>s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying
 hardware.</p>
 </li>
 <li><a href="#O_TMPFILE"><code>O_TMPFILE</code></a></li>
 <li><a href="#O_TRUNC"><code>O_TRUNC</code></a> - 
 If the file already exists and is a regular file and the open mode allows writing (i.e., is <code>O_RDWR</code> or <code>O_WRONLY</code>) it will be
 truncated to length 0.
 
 <p>If the file is a FIFO or terminal device file, the <code>O_TRUNC</code> flag is ignored. Otherwise the effect of <code>O_TRUNC</code> is unspecified.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.O_TRUNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFMT">
<h3>S_IFMT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFMT</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFMT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFBLK">
<h3>S_IFBLK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFBLK</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFBLK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFCHR">
<h3>S_IFCHR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFCHR</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFCHR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFIFO">
<h3>S_IFIFO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFIFO</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFIFO">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFREG">
<h3>S_IFREG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFREG</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFREG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFDIR">
<h3>S_IFDIR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFDIR</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFDIR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFLNK">
<h3>S_IFLNK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFLNK</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFLNK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IFSOCK">
<h3>S_IFSOCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IFSOCK</span></div>
<div class="block">File types encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IFMT"><code>S_IFMT</code></a> - Type of file.</li>
 <li><a href="#S_IFBLK"><code>S_IFBLK</code></a> - Block special.</li>
 <li><a href="#S_IFCHR"><code>S_IFCHR</code></a> - Character special.</li>
 <li><a href="#S_IFIFO"><code>S_IFIFO</code></a> - FIFO special.</li>
 <li><a href="#S_IFREG"><code>S_IFREG</code></a> - Regular.</li>
 <li><a href="#S_IFDIR"><code>S_IFDIR</code></a> - Directory.</li>
 <li><a href="#S_IFLNK"><code>S_IFLNK</code></a> - Symbolic link.</li>
 <li><a href="#S_IFSOCK"><code>S_IFSOCK</code></a> - Socket.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IFSOCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IRWXU">
<h3>S_IRWXU</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IRWXU</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IRWXU">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IRUSR">
<h3>S_IRUSR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IRUSR</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IRUSR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IWUSR">
<h3>S_IWUSR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IWUSR</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IWUSR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IXUSR">
<h3>S_IXUSR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IXUSR</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IXUSR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IRWXG">
<h3>S_IRWXG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IRWXG</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IRWXG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IRGRP">
<h3>S_IRGRP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IRGRP</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IRGRP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IWGRP">
<h3>S_IWGRP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IWGRP</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IWGRP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IXGRP">
<h3>S_IXGRP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IXGRP</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IXGRP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IRWXO">
<h3>S_IRWXO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IRWXO</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IRWXO">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IROTH">
<h3>S_IROTH</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IROTH</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IROTH">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IWOTH">
<h3>S_IWOTH</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IWOTH</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IWOTH">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_IXOTH">
<h3>S_IXOTH</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_IXOTH</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_IXOTH">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_ISUID">
<h3>S_ISUID</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_ISUID</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_ISUID">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_ISGID">
<h3>S_ISGID</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_ISGID</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_ISGID">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="S_ISVTX">
<h3>S_ISVTX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">S_ISVTX</span></div>
<div class="block">File mode bits encoded in type <code>mode_t</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#S_IRWXU"><code>S_IRWXU</code></a> - Read, write, execute/search by owner.</li>
 <li><a href="#S_IRUSR"><code>S_IRUSR</code></a> - Read permission, owner.</li>
 <li><a href="#S_IWUSR"><code>S_IWUSR</code></a> - Write permission, owner.</li>
 <li><a href="#S_IXUSR"><code>S_IXUSR</code></a> - Execute/search permission, owner.</li>
 <li><a href="#S_IRWXG"><code>S_IRWXG</code></a> - Read, write, execute/search by group.</li>
 <li><a href="#S_IRGRP"><code>S_IRGRP</code></a> - Read permission, group.</li>
 <li><a href="#S_IWGRP"><code>S_IWGRP</code></a> - Write permission, group.</li>
 <li><a href="#S_IXGRP"><code>S_IXGRP</code></a> - Execute/search permission, group.</li>
 <li><a href="#S_IRWXO"><code>S_IRWXO</code></a> - Read, write, execute/search by others.</li>
 <li><a href="#S_IROTH"><code>S_IROTH</code></a> - Read permission, others.</li>
 <li><a href="#S_IWOTH"><code>S_IWOTH</code></a> - Write permission, others.</li>
 <li><a href="#S_IXOTH"><code>S_IXOTH</code></a> - Execute/search permission, others.</li>
 <li><a href="#S_ISUID"><code>S_ISUID</code></a> - Set-user-ID on execution.</li>
 <li><a href="#S_ISGID"><code>S_ISGID</code></a> - Set-group-ID on execution.</li>
 <li><a href="#S_ISVTX"><code>S_ISVTX</code></a> - On directories, restricted deletion flag.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.S_ISVTX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_DUPFD">
<h3>F_DUPFD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_DUPFD</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_DUPFD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETFD">
<h3>F_GETFD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETFD</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETFD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETFD">
<h3>F_SETFD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETFD</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETFD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETFL">
<h3>F_GETFL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETFL</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETFL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETFL">
<h3>F_SETFL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETFL</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETFL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETLK">
<h3>F_GETLK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETLK</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETLK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETLK">
<h3>F_SETLK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETLK</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETLK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETLKW">
<h3>F_SETLKW</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETLKW</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETLKW">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETOWN">
<h3>F_SETOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETOWN</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETOWN">
<h3>F_GETOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETOWN</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETSIG">
<h3>F_SETSIG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETSIG</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETSIG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETSIG">
<h3>F_GETSIG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETSIG</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETSIG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETOWN_EX">
<h3>F_SETOWN_EX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETOWN_EX</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETOWN_EX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETOWN_EX">
<h3>F_GETOWN_EX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETOWN_EX</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETOWN_EX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_OFD_GETLK">
<h3>F_OFD_GETLK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_OFD_GETLK</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_OFD_GETLK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_OFD_SETLK">
<h3>F_OFD_SETLK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_OFD_SETLK</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_OFD_SETLK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_OFD_SETLKW">
<h3>F_OFD_SETLKW</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_OFD_SETLKW</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_OFD_SETLKW">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETLEASE">
<h3>F_SETLEASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETLEASE</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETLEASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETLEASE">
<h3>F_GETLEASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETLEASE</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETLEASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_NOTIFY">
<h3>F_NOTIFY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_NOTIFY</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_NOTIFY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SETPIPE_SZ">
<h3>F_SETPIPE_SZ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SETPIPE_SZ</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SETPIPE_SZ">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GETPIPE_SZ">
<h3>F_GETPIPE_SZ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GETPIPE_SZ</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GETPIPE_SZ">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_ADD_SEALS">
<h3>F_ADD_SEALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_ADD_SEALS</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_ADD_SEALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GET_SEALS">
<h3>F_GET_SEALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GET_SEALS</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GET_SEALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GET_RW_HINT">
<h3>F_GET_RW_HINT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GET_RW_HINT</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GET_RW_HINT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SET_RW_HINT">
<h3>F_SET_RW_HINT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SET_RW_HINT</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SET_RW_HINT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_GET_FILE_RW_HINT">
<h3>F_GET_FILE_RW_HINT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_GET_FILE_RW_HINT</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_GET_FILE_RW_HINT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SET_FILE_RW_HINT">
<h3>F_SET_FILE_RW_HINT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SET_FILE_RW_HINT</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SET_FILE_RW_HINT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_DUPFD_CLOEXEC">
<h3>F_DUPFD_CLOEXEC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_DUPFD_CLOEXEC</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> commands.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_DUPFD"><code>F_DUPFD</code></a> - 
 Duplicate the file descriptor <code>fd</code> using the lowest-numbered available file descriptor greater than or equal to <code>arg</code>.
 
 <p>This is different from <code>dup2(2)</code>, which uses exactly the file descriptor specified.</p>
 
 <p>On success, the new file descriptor is returned.</p>
 
 <p>See <code>dup(2)</code> for further details.</p>
 </li>
 <li><a href="#F_GETFD"><code>F_GETFD</code></a> - Return (as the function result) the file descriptor flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFD"><code>F_SETFD</code></a> - Set the file descriptor flags to the value specified by <code>arg</code>.</li>
 <li><a href="#F_GETFL"><code>F_GETFL</code></a> - Return (as the function result) the file access mode and the file status flags; <code>arg</code> is ignored.</li>
 <li><a href="#F_SETFL"><code>F_SETFL</code></a> - 
 Set the file status flags to the value specified by <code>arg</code>.
 
 <p>File access mode (<a href="#O_RDONLY"><code>O_RDONLY</code></a>, <a href="#O_WRONLY"><code>O_WRONLY</code></a>, <a href="#O_RDWR"><code>O_RDWR</code></a>) and file creation flags (i.e., <a href="#O_CREAT"><code>O_CREAT</code></a>, <a href="#O_EXCL"><code>O_EXCL</code></a>, <a href="#O_NOCTTY"><code>O_NOCTTY</code></a>, <a href="#O_TRUNC"><code>O_TRUNC</code></a>) in <code>arg</code> are ignored.
 On Linux, this command can change only the <a href="#O_APPEND"><code>O_APPEND</code></a>, <a href="#O_ASYNC"><code>O_ASYNC</code></a>, <a href="#O_DIRECT"><code>O_DIRECT</code></a>, <a href="#O_NOATIME"><code>O_NOATIME</code></a>, and <a href="#O_NONBLOCK"><code>O_NONBLOCK</code></a> flags. It is not possible to change the
 <a href="#O_DSYNC"><code>O_DSYNC</code></a> and <a href="#O_SYNC"><code>O_SYNC</code></a> flags; see BUGS, below.</p>
 </li>
 <li><a href="#F_GETLK"><code>F_GETLK</code></a> - 
 On input to this call, lock describes a lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of lock and leaves the
 other fields of the structure unchanged.</p>
 
 <p>If one or more incompatible locks would prevent this lock being placed, then <code>fcntl()</code> returns details about one of those locks in the
 <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock. If the conflicting lock is a traditional (process-associated)
 record lock, then the <code>l_pid</code> field is set to the <code>PID</code> of the process holding that lock. If the conflicting lock is an open file
 description lock, then <code>l_pid</code> is set to -1. Note that the returned information may already be out of date by the time the caller inspects
 it.</p>
 </li>
 <li><a href="#F_SETLK"><code>F_SETLK</code></a> - 
 Acquire a lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release a lock (when <code>l_type</code> is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the
 <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of lock.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EACCES</code> or <code>EAGAIN</code>. (The error
 returned in this case differs across implementations, so POSIX requires a portable application to check for both errors.)</p>
 </li>
 <li><a href="#F_SETLKW"><code>F_SETLKW</code></a> - 
 As for <a href="#F_SETLK"><code>F_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and errno set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETOWN"><code>F_SETOWN</code></a> - 
 Set the process ID or process group ID that will receive <code>SIGIO</code> and <code>SIGURG</code> signals for events on the file descriptor <code>fd</code>.
 
 <p>The target process or process group ID is specified in <code>arg</code>. A process ID is specified as a positive value; a process group ID is specified
 as a negative value. Most commonly, the calling process specifies itself as the owner (that is, <code>arg</code> is specified as <code>getpid(2)</code>).</p>
 
 <p>As well as setting the file descriptor owner, one must also enable generation of signals on the file descriptor. This is done by using the
 <code>fcntl()</code> <a href="#F_SETFL"><code>F_SETFL</code></a> command to set the <a href="#O_ASYNC"><code>O_ASYNC</code></a> file status flag on the file descriptor. Subsequently, a <code>SIGIO</code> signal is sent whenever
 input or output becomes possible on the file descriptor. The <code>fcntl()</code> <a href="#F_SETSIG"><code>F_SETSIG</code></a> command can be used to obtain delivery of a signal other
 than <code>SIGIO</code>.</p>
 
 <p>Sending a signal to the owner process (group) specified by <code>F_SETOWN</code> is subject to the same permissions checks as are described for
 <code>kill(2)</code>, where the sending process is the one that employs <code>F_SETOWN</code> (but see BUGS below). If this permission check fails, then the
 signal is silently discarded. Note: The <code>F_SETOWN</code> operation records the caller's credentials at the time of the <code>fcntl()</code> call, and it
 is these saved credentials that are used for the permission checks.</p>
 
 <p>If the file descriptor <code>fd</code> refers to a socket, <code>F_SETOWN</code> also selects the recipient of <code>SIGURG</code> signals that are delivered when
 out-of-band data arrives on that socket. (<code>SIGURG</code> is sent in any situation where <code>select(2)</code> would report the socket as having an
 "exceptional condition".)</p>
 
 <p>The following was true in 2.6.x kernels up to and including kernel 2.6.11:</p>
 
 <p>If a nonzero value is given to <a href="#F_SETSIG"><code>F_SETSIG</code></a> in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then
 a positive value given to <code>F_SETOWN</code> has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID
 identifying a specific thread within a process. Consequently, it may be necessary to pass <code>F_SETOWN</code> the result of <code>gettid(2)</code> instead
 of <code>getpid(2)</code> to get sensible results when <code>F_SETSIG</code> is used. (In current Linux threading implementations, a main thread's thread ID
 is the same as its process ID. This means that a single-threaded program can equally use <code>gettid(2)</code> or <code>getpid(2)</code> in this scenario.)
 Note, however, that the statements in this paragraph do not apply to the <code>SIGURG</code> signal generated for out-of-band data on a socket: this
 signal is always sent to either a process or a process group, depending on the value given to <code>F_SETOWN</code>.</p>
 
 <p>The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> to target
 <code>SIGIO</code> and <code>SIGURG</code> signals at a particular thread.</p>
 </li>
 <li><a href="#F_GETOWN"><code>F_GETOWN</code></a> - 
 Return (as the function result) the process ID or process group ID currently receiving <code>SIGIO</code> and <code>SIGURG</code> signals for events on file
 descriptor <code>fd</code>.
 
 <p>Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETSIG"><code>F_SETSIG</code></a> - 
 Set the signal sent when input or output becomes possible to the value given in <code>arg</code>.
 
 <p>A value of zero means to send the default <code>SIGIO</code> signal. Any other value (including <code>SIGIO</code>) is the signal to send instead, and in
 this case additional info is available to the signal handler if installed with <code>SA_SIGINFO</code>.</p>
 
 <p>By using <code>F_SETSIG</code> with a nonzero value, and setting <code>SA_SIGINFO</code> for the signal handler (see <code>sigaction(2)</code>), extra information
 about I/O events is passed to the handler in a <code>siginfo_t</code> structure. If the <code>si_code</code> field indicates the source is <code>SI_SIGIO</code>,
 the <code>si_fd</code> field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending,
 and you should use the usual mechanisms (<code>select(2)</code>, <code>poll(2)</code>, <code>read(2)</code> with <code>O_NONBLOCK</code> set etc.) to determine which
 file descriptors are available for I/O.</p>
 
 <p>Note that the file descriptor provided in <code>si_fd</code> is the one that was specified during the <code>F_SETSIG</code> operation. This can lead to an
 unusual corner case. If the file descriptor is duplicated (<code>dup(2)</code> or similar), and the original file descriptor is closed, then I/O events
 will continue to be generated, but the <code>si_fd</code> field will contain the number of the now closed file descriptor.</p>
 
 <p>By selecting a real time signal (value &ge; <code>SIGRTMIN</code>), multiple I/O events may be queued using the same signal numbers. (Queuing is
 dependent on available memory.) Extra information is available if <code>SA_SIGINFO</code> is set for the signal handler, as above.</p>
 
 <p>Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see <code>getrlimit(2)</code> and <code>signal(7)</code>)
 and if this limit is reached, then the kernel reverts to delivering <code>SIGIO</code>, and this signal is delivered to the entire process rather than
 to a specific thread.</p>
 </li>
 <li><a href="#F_GETSIG"><code>F_GETSIG</code></a> - 
 Return (as the function result) the signal sent when input or output becomes possible.
 
 <p>A value of zero means <code>SIGIO</code> is sent. Any other value (including <code>SIGIO</code>) is the signal sent instead, and in this case additional info
 is available to the signal handler if installed with <code>SA_SIGINFO</code>. <code>arg</code> is ignored.</p>
 </li>
 <li><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> - 
 This operation performs a similar task to <a href="#F_SETOWN"><code>F_SETOWN</code></a>. It allows the caller to direct I/O availability signals to a specific thread, process, or
 process group.
 
 <p>The caller specifies the target of signals via <code>arg</code>, which is a pointer to a <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure. The type field has one of the following
 values, which define how pid is interpreted: <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>.</p>
 </li>
 <li><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a> - 
 Return the current file descriptor owner settings as defined by a previous <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> operation.
 
 <p>The information is returned in the <a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a> structure pointed to by <code>arg</code>.</p>
 
 <p>The type field will have one of the values <a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a>, <a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a>, or <a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a>. The <code>pid</code> field is a positive integer representing a
 thread ID, process ID, or process group ID. See <a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a> for more details.</p>
 </li>
 <li><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a> - 
 On input to this call, <code>lock</code> describes an open file description lock we would like to place on the file.
 
 <p>If the lock could be placed, <code>fcntl()</code> does not actually place it, but returns <a href="#F_UNLCK"><code>F_UNLCK</code></a> in the <code>l_type</code> field of <code>lock</code> and
 leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then details about one
 of these locks are returned via <code>lock</code>, as described above for <a href="#F_GETLK"><code>F_GETLK</code></a>.</p>
 </li>
 <li><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a> - 
 Acquire an open file description lock (when <code>l_type</code> is <a href="#F_RDLCK"><code>F_RDLCK</code></a> or <a href="#F_WRLCK"><code>F_WRLCK</code></a>) or release an open file description lock (when <code>l_type</code>
 is <a href="#F_UNLCK"><code>F_UNLCK</code></a>) on the bytes specified by the <code>l_whence</code>, <code>l_start</code>, and <code>l_len</code> fields of <code>lock</code>.
 
 <p>If a conflicting lock is held by another process, this call returns -1 and sets <code>errno</code> to <code>EAGAIN</code>.</p>
 </li>
 <li><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a> - 
 As for <a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a>, but if a conflicting lock is held on the file, then wait for that lock to be released.
 
 <p>If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return
 value -1 and <code>errno</code> set to <code>EINTR</code>; see <code>signal(7)</code>).</p>
 </li>
 <li><a href="#F_SETLEASE"><code>F_SETLEASE</code></a> - Set or remove a file lease according to which of the following values is specified in the integer <code>arg</code>: <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, <a href="#F_UNLCK"><code>F_UNLCK</code></a></li>
 <li><a href="#F_GETLEASE"><code>F_GETLEASE</code></a> - 
 Indicates what type of lease is associated with the file descriptor <code>fd</code> by returning either <a href="#F_RDLCK"><code>F_RDLCK</code></a>, <a href="#F_WRLCK"><code>F_WRLCK</code></a>, or <a href="#F_UNLCK"><code>F_UNLCK</code></a>, indicating,
 respectively, a read lease, a write lease, or no lease. <code>arg</code> is ignored.
 </li>
 <li><a href="#F_NOTIFY"><code>F_NOTIFY</code></a> - 
 (Linux 2.4 onward) Provide notification when the directory referred to by <code>fd</code> or any of the files that it contains is changed.
 
 <p>The events to be notified are specified in <code>arg</code>, which is a bit mask specified by ORing together zero or more of the following bits:
 <a href="#DN_ACCESS"><code>DN_ACCESS</code></a>, <a href="#DN_MODIFY"><code>DN_MODIFY</code></a>, <a href="#DN_CREATE"><code>DN_CREATE</code></a>, <a href="#DN_DELETE"><code>DN_DELETE</code></a>, <a href="#DN_RENAME"><code>DN_RENAME</code></a>, <a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a></p>
 
 <p>(In order to obtain these definitions, the <code>_GNU_SOURCE</code> feature test macro must be defined before including any header files.)</p>
 
 <p>Directory notifications are normally "one-shot", and the application must reregister to receive further notifications. Alternatively, if
 <a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> is included in <code>arg</code>, then notification will remain in effect until explicitly removed.</p>
 
 <p>A series of <code>F_NOTIFY</code> requests is cumulative, with the events in <code>arg</code> being added to the set already monitored. To disable
 notification of all events, make an <code>F_NOTIFY</code> call specifying <code>arg</code> as 0.</p>
 
 <p>Notification occurs via delivery of a signal. The default signal is <code>SIGIO</code>, but this can be changed using the <a href="#F_SETSIG"><code>F_SETSIG</code></a> command to
 <code>fcntl()</code>. (Note that <code>SIGIO</code> is one of the nonqueuing standard signals; switching to the use of a real-time signal means that multiple
 notifications can be queued to the process.) In the latter case, the signal handler receives a <code>siginfo_t</code> structure as its second argument
 (if the handler was established using <code>SA_SIGINFO</code>) and the <code>si_fd</code> field of this structure contains the file descriptor which
 generated the notification (useful when establishing notification on multiple directories).</p>
 
 <p>Especially when using <code>DN_MULTISHOT</code>, a real time signal should be used for notification, so that multiple notifications can be queued.</p>
 
 <p>NOTE: New applications should use the <code>inotify</code> interface (available since kernel 2.6.13), which provides a much superior interface for
 obtaining notifications of filesystem events. See <code>inotify(7)</code>.</p>
 </li>
 <li><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a> - 
 Change the capacity of the pipe referred to by <code>fd</code> to be at least <code>arg</code> bytes.
 
 <p>An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in
 <code>/proc/sys/fs/pipe-max-size</code> (see <code>proc(5)</code>). Attempts to set the pipe capacity below the page size are silently rounded up to the page
 size. Attempts by an unprivileged process to set the pipe capacity above the limit in <code>/proc/sys/fs/pipe-max-size</code> yield the error
 <code>EPERM</code>; a privileged process (<code>CAP_SYS_RESOURCE</code>) can override the limit.</p>
 
 <p>When allocating the buffer for the pipe, the kernel may use a capacity larger than <code>arg</code>, if that is convenient for the implementation. (In
 the current implementation, the allocation is the next higher power-of-two page-size multiple of the requested size.) The actual capacity (in
 bytes) that is set is returned as the function result.</p>
 
 <p>Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error <code>EBUSY</code>.</p>
 
 <p>Note that because of the way the pages of the pipe buffer are employed when data is written to the pipe, the number of bytes that can be written
 may be less than the nominal size, depending on the size of the writes.</p>
 </li>
 <li><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a> - Return (as the function result) the capacity of the pipe referred to by <code>fd</code>.</li>
 <li><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> - 
 Add the seals given in the bit-mask argument <code>arg</code> to the set of seals of the <code>inode</code> referred to by the file descriptor <code>fd</code>.
 
 <p>Seals cannot be removed again. Once this call succeeds, the seals are enforced by the kernel immediately. If the current set of seals includes
 <a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> (see below), then this call will be rejected with <code>EPERM</code>. Adding a seal that is already set is a no-op, in case
 <code>F_SEAL_SEAL</code> is not set already. In order to place a seal, the file descriptor <code>fd</code> must be writable.</p>
 </li>
 <li><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a> - 
 Return (as the function result) the current set of seals of the <code>inode</code> referred to by <code>fd</code>.
 
 <p>If no seals are set, 0 is returned. If the file does not support sealing, -1 is returned and <code>errno</code> is set to <code>EINVAL</code>.</p>
 </li>
 <li><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a> - Returns the value of the read/write hint associated with the underlying <code>inode</code> referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a> - 
 Sets the read/write hint value associated with the underlying <code>inode</code> referred to by <code>fd</code>.
 
 <p>This hint persists until either it is explicitly modified or the underlying filesystem is unmounted.</p>
 </li>
 <li><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a> - Returns the value of the read/write hint associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a> - Sets the read/write hint value associated with the open file description referred to by <code>fd</code>.</li>
 <li><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a> - 
 As for <a href="#F_DUPFD"><code>F_DUPFD</code></a>, but additionally set the close-on-exec flag for the duplicate file descriptor.
 
 <p>Specifying this flag permits a program to avoid an additional <code>fcntl()</code> <a href="#F_SETFD"><code>F_SETFD</code></a> operation to set the <a href="#FD_CLOEXEC"><code>FD_CLOEXEC</code></a> flag. For an explanation of
 why this flag is useful, see the description of <a href="#O_CLOEXEC"><code>O_CLOEXEC</code></a> in <code>open(2)</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_DUPFD_CLOEXEC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="FD_CLOEXEC">
<h3>FD_CLOEXEC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">FD_CLOEXEC</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.FD_CLOEXEC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_RDLCK">
<h3>F_RDLCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_RDLCK</span></div>
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_RDLCK"><code>F_RDLCK</code></a> - 
 Take out a read lease.
 
 <p>This will cause the calling process to be notified when the file is opened for writing or is truncated. A read lease can be placed only on a file
 descriptor that is opened read-only.</p>
 </li>
 <li><a href="#F_WRLCK"><code>F_WRLCK</code></a> - 
 Take out a write lease.
 
 <p>This will cause the caller to be notified when the file is opened for reading or writing or is truncated. A write lease may be placed on a file
 only if there are no other open file descriptors for the file.</p>
 </li>
 <li><a href="#F_UNLCK"><code>F_UNLCK</code></a> - Remove our lease from the file.</li>
 <li><a href="#F_EXLCK"><code>F_EXLCK</code></a></li>
 <li><a href="#F_SHLCK"><code>F_SHLCK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_RDLCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_WRLCK">
<h3>F_WRLCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_WRLCK</span></div>
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_RDLCK"><code>F_RDLCK</code></a> - 
 Take out a read lease.
 
 <p>This will cause the calling process to be notified when the file is opened for writing or is truncated. A read lease can be placed only on a file
 descriptor that is opened read-only.</p>
 </li>
 <li><a href="#F_WRLCK"><code>F_WRLCK</code></a> - 
 Take out a write lease.
 
 <p>This will cause the caller to be notified when the file is opened for reading or writing or is truncated. A write lease may be placed on a file
 only if there are no other open file descriptors for the file.</p>
 </li>
 <li><a href="#F_UNLCK"><code>F_UNLCK</code></a> - Remove our lease from the file.</li>
 <li><a href="#F_EXLCK"><code>F_EXLCK</code></a></li>
 <li><a href="#F_SHLCK"><code>F_SHLCK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_WRLCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_UNLCK">
<h3>F_UNLCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_UNLCK</span></div>
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_RDLCK"><code>F_RDLCK</code></a> - 
 Take out a read lease.
 
 <p>This will cause the calling process to be notified when the file is opened for writing or is truncated. A read lease can be placed only on a file
 descriptor that is opened read-only.</p>
 </li>
 <li><a href="#F_WRLCK"><code>F_WRLCK</code></a> - 
 Take out a write lease.
 
 <p>This will cause the caller to be notified when the file is opened for reading or writing or is truncated. A write lease may be placed on a file
 only if there are no other open file descriptors for the file.</p>
 </li>
 <li><a href="#F_UNLCK"><code>F_UNLCK</code></a> - Remove our lease from the file.</li>
 <li><a href="#F_EXLCK"><code>F_EXLCK</code></a></li>
 <li><a href="#F_SHLCK"><code>F_SHLCK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_UNLCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_EXLCK">
<h3>F_EXLCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_EXLCK</span></div>
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_RDLCK"><code>F_RDLCK</code></a> - 
 Take out a read lease.
 
 <p>This will cause the calling process to be notified when the file is opened for writing or is truncated. A read lease can be placed only on a file
 descriptor that is opened read-only.</p>
 </li>
 <li><a href="#F_WRLCK"><code>F_WRLCK</code></a> - 
 Take out a write lease.
 
 <p>This will cause the caller to be notified when the file is opened for reading or writing or is truncated. A write lease may be placed on a file
 only if there are no other open file descriptors for the file.</p>
 </li>
 <li><a href="#F_UNLCK"><code>F_UNLCK</code></a> - Remove our lease from the file.</li>
 <li><a href="#F_EXLCK"><code>F_EXLCK</code></a></li>
 <li><a href="#F_SHLCK"><code>F_SHLCK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_EXLCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SHLCK">
<h3>F_SHLCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SHLCK</span></div>
<div class="block">For posix <a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> and <code>l_type</code> field of an <a href="Flock.html" title="class in org.lwjgl.system.linux"><code>Flock</code></a> for <code>lockf()</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_RDLCK"><code>F_RDLCK</code></a> - 
 Take out a read lease.
 
 <p>This will cause the calling process to be notified when the file is opened for writing or is truncated. A read lease can be placed only on a file
 descriptor that is opened read-only.</p>
 </li>
 <li><a href="#F_WRLCK"><code>F_WRLCK</code></a> - 
 Take out a write lease.
 
 <p>This will cause the caller to be notified when the file is opened for reading or writing or is truncated. A write lease may be placed on a file
 only if there are no other open file descriptors for the file.</p>
 </li>
 <li><a href="#F_UNLCK"><code>F_UNLCK</code></a> - Remove our lease from the file.</li>
 <li><a href="#F_EXLCK"><code>F_EXLCK</code></a></li>
 <li><a href="#F_SHLCK"><code>F_SHLCK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SHLCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_OWNER_TID">
<h3>F_OWNER_TID</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_OWNER_TID</span></div>
<div class="block"><a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a><code>::type</code> values.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a> - 
 Send the signal to the thread whose thread ID (the value returned by a call to <code>clone(2)</code> or <code>gettid(2)</code>) is specified in <code>pid</code>.
 </li>
 <li><a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a> -  Send the signal to the process whose ID is specified in <code>pid</code>.</li>
 <li><a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a> - 
 Send the signal to the process group whose ID is specified in <code>pid</code>.
 
 <p>(Note that, unlike with <a href="#F_SETOWN"><code>F_SETOWN</code></a>, a process group ID is specified as a positive value here.)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_OWNER_TID">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_OWNER_PID">
<h3>F_OWNER_PID</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_OWNER_PID</span></div>
<div class="block"><a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a><code>::type</code> values.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a> - 
 Send the signal to the thread whose thread ID (the value returned by a call to <code>clone(2)</code> or <code>gettid(2)</code>) is specified in <code>pid</code>.
 </li>
 <li><a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a> -  Send the signal to the process whose ID is specified in <code>pid</code>.</li>
 <li><a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a> - 
 Send the signal to the process group whose ID is specified in <code>pid</code>.
 
 <p>(Note that, unlike with <a href="#F_SETOWN"><code>F_SETOWN</code></a>, a process group ID is specified as a positive value here.)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_OWNER_PID">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_OWNER_PGRP">
<h3>F_OWNER_PGRP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_OWNER_PGRP</span></div>
<div class="block"><a href="FOwnerEx.html" title="class in org.lwjgl.system.linux"><code>FOwnerEx</code></a><code>::type</code> values.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_OWNER_TID"><code>F_OWNER_TID</code></a> - 
 Send the signal to the thread whose thread ID (the value returned by a call to <code>clone(2)</code> or <code>gettid(2)</code>) is specified in <code>pid</code>.
 </li>
 <li><a href="#F_OWNER_PID"><code>F_OWNER_PID</code></a> -  Send the signal to the process whose ID is specified in <code>pid</code>.</li>
 <li><a href="#F_OWNER_PGRP"><code>F_OWNER_PGRP</code></a> - 
 Send the signal to the process group whose ID is specified in <code>pid</code>.
 
 <p>(Note that, unlike with <a href="#F_SETOWN"><code>F_SETOWN</code></a>, a process group ID is specified as a positive value here.)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_OWNER_PGRP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_SH">
<h3>LOCK_SH</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_SH</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_SH">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_EX">
<h3>LOCK_EX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_EX</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_EX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_NB">
<h3>LOCK_NB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_NB</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_NB">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_UN">
<h3>LOCK_UN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_UN</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_UN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_MAND">
<h3>LOCK_MAND</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_MAND</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_MAND">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_READ">
<h3>LOCK_READ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_READ</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_READ">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_WRITE">
<h3>LOCK_WRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_WRITE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_WRITE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOCK_RW">
<h3>LOCK_RW</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOCK_RW</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#LOCK_SH"><code>LOCK_SH</code></a> - shared lock</li>
 <li><a href="#LOCK_EX"><code>LOCK_EX</code></a> - exclusive lock</li>
 <li><a href="#LOCK_NB"><code>LOCK_NB</code></a> - or'd with one of the above to prevent blocking</li>
 <li><a href="#LOCK_UN"><code>LOCK_UN</code></a> - remove lock</li>
 <li><a href="#LOCK_MAND"><code>LOCK_MAND</code></a> - This is a mandatory flock...</li>
 <li><a href="#LOCK_READ"><code>LOCK_READ</code></a> - which allows concurrent read operations</li>
 <li><a href="#LOCK_WRITE"><code>LOCK_WRITE</code></a> - which allows concurrent write operations</li>
 <li><a href="#LOCK_RW"><code>LOCK_RW</code></a> - which allows concurrent read &amp; writes ops</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.LOCK_RW">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DN_ACCESS">
<h3>DN_ACCESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DN_ACCESS</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#DN_ACCESS"><code>DN_ACCESS</code></a> - A file was accessed (<code>read(2)</code>, <code>pread(2)</code>, <code>readv(2)</code>, and similar).</li>
 <li><a href="#DN_MODIFY"><code>DN_MODIFY</code></a> - A file was modified (<code>write(2)</code>, <code>pwrite(2)</code>, <code>writev(2)</code>, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and similar).</li>
 <li><a href="#DN_CREATE"><code>DN_CREATE</code></a> - 
 A file was created (<code>open(2)</code>, <code>creat(2)</code>, <code>mknod(2)</code>, <code>mkdir(2)</code>, <code>link(2)</code>, <code>symlink(2)</code>, <code>rename(2)</code>
 into this directory).
 </li>
 <li><a href="#DN_DELETE"><code>DN_DELETE</code></a> - A file was unlinked (<code>unlink(2)</code>, <code>rename(2)</code> to another directory, <code>rmdir(2)</code>).</li>
 <li><a href="#DN_RENAME"><code>DN_RENAME</code></a> - A file was renamed within this directory (<code>rename(2)</code>).</li>
 <li><a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a> - The attributes of a file were changed (<code>chown(2)</code>, <code>chmod(2)</code>, <code>utime(2)</code>, <code>utimensat(2)</code>, and similar).</li>
 <li><a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> - Don't remove notifier</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.DN_ACCESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DN_MODIFY">
<h3>DN_MODIFY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DN_MODIFY</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#DN_ACCESS"><code>DN_ACCESS</code></a> - A file was accessed (<code>read(2)</code>, <code>pread(2)</code>, <code>readv(2)</code>, and similar).</li>
 <li><a href="#DN_MODIFY"><code>DN_MODIFY</code></a> - A file was modified (<code>write(2)</code>, <code>pwrite(2)</code>, <code>writev(2)</code>, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and similar).</li>
 <li><a href="#DN_CREATE"><code>DN_CREATE</code></a> - 
 A file was created (<code>open(2)</code>, <code>creat(2)</code>, <code>mknod(2)</code>, <code>mkdir(2)</code>, <code>link(2)</code>, <code>symlink(2)</code>, <code>rename(2)</code>
 into this directory).
 </li>
 <li><a href="#DN_DELETE"><code>DN_DELETE</code></a> - A file was unlinked (<code>unlink(2)</code>, <code>rename(2)</code> to another directory, <code>rmdir(2)</code>).</li>
 <li><a href="#DN_RENAME"><code>DN_RENAME</code></a> - A file was renamed within this directory (<code>rename(2)</code>).</li>
 <li><a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a> - The attributes of a file were changed (<code>chown(2)</code>, <code>chmod(2)</code>, <code>utime(2)</code>, <code>utimensat(2)</code>, and similar).</li>
 <li><a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> - Don't remove notifier</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.DN_MODIFY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DN_CREATE">
<h3>DN_CREATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DN_CREATE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#DN_ACCESS"><code>DN_ACCESS</code></a> - A file was accessed (<code>read(2)</code>, <code>pread(2)</code>, <code>readv(2)</code>, and similar).</li>
 <li><a href="#DN_MODIFY"><code>DN_MODIFY</code></a> - A file was modified (<code>write(2)</code>, <code>pwrite(2)</code>, <code>writev(2)</code>, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and similar).</li>
 <li><a href="#DN_CREATE"><code>DN_CREATE</code></a> - 
 A file was created (<code>open(2)</code>, <code>creat(2)</code>, <code>mknod(2)</code>, <code>mkdir(2)</code>, <code>link(2)</code>, <code>symlink(2)</code>, <code>rename(2)</code>
 into this directory).
 </li>
 <li><a href="#DN_DELETE"><code>DN_DELETE</code></a> - A file was unlinked (<code>unlink(2)</code>, <code>rename(2)</code> to another directory, <code>rmdir(2)</code>).</li>
 <li><a href="#DN_RENAME"><code>DN_RENAME</code></a> - A file was renamed within this directory (<code>rename(2)</code>).</li>
 <li><a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a> - The attributes of a file were changed (<code>chown(2)</code>, <code>chmod(2)</code>, <code>utime(2)</code>, <code>utimensat(2)</code>, and similar).</li>
 <li><a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> - Don't remove notifier</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.DN_CREATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DN_DELETE">
<h3>DN_DELETE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DN_DELETE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#DN_ACCESS"><code>DN_ACCESS</code></a> - A file was accessed (<code>read(2)</code>, <code>pread(2)</code>, <code>readv(2)</code>, and similar).</li>
 <li><a href="#DN_MODIFY"><code>DN_MODIFY</code></a> - A file was modified (<code>write(2)</code>, <code>pwrite(2)</code>, <code>writev(2)</code>, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and similar).</li>
 <li><a href="#DN_CREATE"><code>DN_CREATE</code></a> - 
 A file was created (<code>open(2)</code>, <code>creat(2)</code>, <code>mknod(2)</code>, <code>mkdir(2)</code>, <code>link(2)</code>, <code>symlink(2)</code>, <code>rename(2)</code>
 into this directory).
 </li>
 <li><a href="#DN_DELETE"><code>DN_DELETE</code></a> - A file was unlinked (<code>unlink(2)</code>, <code>rename(2)</code> to another directory, <code>rmdir(2)</code>).</li>
 <li><a href="#DN_RENAME"><code>DN_RENAME</code></a> - A file was renamed within this directory (<code>rename(2)</code>).</li>
 <li><a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a> - The attributes of a file were changed (<code>chown(2)</code>, <code>chmod(2)</code>, <code>utime(2)</code>, <code>utimensat(2)</code>, and similar).</li>
 <li><a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> - Don't remove notifier</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.DN_DELETE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DN_RENAME">
<h3>DN_RENAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DN_RENAME</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#DN_ACCESS"><code>DN_ACCESS</code></a> - A file was accessed (<code>read(2)</code>, <code>pread(2)</code>, <code>readv(2)</code>, and similar).</li>
 <li><a href="#DN_MODIFY"><code>DN_MODIFY</code></a> - A file was modified (<code>write(2)</code>, <code>pwrite(2)</code>, <code>writev(2)</code>, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and similar).</li>
 <li><a href="#DN_CREATE"><code>DN_CREATE</code></a> - 
 A file was created (<code>open(2)</code>, <code>creat(2)</code>, <code>mknod(2)</code>, <code>mkdir(2)</code>, <code>link(2)</code>, <code>symlink(2)</code>, <code>rename(2)</code>
 into this directory).
 </li>
 <li><a href="#DN_DELETE"><code>DN_DELETE</code></a> - A file was unlinked (<code>unlink(2)</code>, <code>rename(2)</code> to another directory, <code>rmdir(2)</code>).</li>
 <li><a href="#DN_RENAME"><code>DN_RENAME</code></a> - A file was renamed within this directory (<code>rename(2)</code>).</li>
 <li><a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a> - The attributes of a file were changed (<code>chown(2)</code>, <code>chmod(2)</code>, <code>utime(2)</code>, <code>utimensat(2)</code>, and similar).</li>
 <li><a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> - Don't remove notifier</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.DN_RENAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DN_ATTRIB">
<h3>DN_ATTRIB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DN_ATTRIB</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#DN_ACCESS"><code>DN_ACCESS</code></a> - A file was accessed (<code>read(2)</code>, <code>pread(2)</code>, <code>readv(2)</code>, and similar).</li>
 <li><a href="#DN_MODIFY"><code>DN_MODIFY</code></a> - A file was modified (<code>write(2)</code>, <code>pwrite(2)</code>, <code>writev(2)</code>, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and similar).</li>
 <li><a href="#DN_CREATE"><code>DN_CREATE</code></a> - 
 A file was created (<code>open(2)</code>, <code>creat(2)</code>, <code>mknod(2)</code>, <code>mkdir(2)</code>, <code>link(2)</code>, <code>symlink(2)</code>, <code>rename(2)</code>
 into this directory).
 </li>
 <li><a href="#DN_DELETE"><code>DN_DELETE</code></a> - A file was unlinked (<code>unlink(2)</code>, <code>rename(2)</code> to another directory, <code>rmdir(2)</code>).</li>
 <li><a href="#DN_RENAME"><code>DN_RENAME</code></a> - A file was renamed within this directory (<code>rename(2)</code>).</li>
 <li><a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a> - The attributes of a file were changed (<code>chown(2)</code>, <code>chmod(2)</code>, <code>utime(2)</code>, <code>utimensat(2)</code>, and similar).</li>
 <li><a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> - Don't remove notifier</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.DN_ATTRIB">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DN_MULTISHOT">
<h3>DN_MULTISHOT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DN_MULTISHOT</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#DN_ACCESS"><code>DN_ACCESS</code></a> - A file was accessed (<code>read(2)</code>, <code>pread(2)</code>, <code>readv(2)</code>, and similar).</li>
 <li><a href="#DN_MODIFY"><code>DN_MODIFY</code></a> - A file was modified (<code>write(2)</code>, <code>pwrite(2)</code>, <code>writev(2)</code>, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and similar).</li>
 <li><a href="#DN_CREATE"><code>DN_CREATE</code></a> - 
 A file was created (<code>open(2)</code>, <code>creat(2)</code>, <code>mknod(2)</code>, <code>mkdir(2)</code>, <code>link(2)</code>, <code>symlink(2)</code>, <code>rename(2)</code>
 into this directory).
 </li>
 <li><a href="#DN_DELETE"><code>DN_DELETE</code></a> - A file was unlinked (<code>unlink(2)</code>, <code>rename(2)</code> to another directory, <code>rmdir(2)</code>).</li>
 <li><a href="#DN_RENAME"><code>DN_RENAME</code></a> - A file was renamed within this directory (<code>rename(2)</code>).</li>
 <li><a href="#DN_ATTRIB"><code>DN_ATTRIB</code></a> - The attributes of a file were changed (<code>chown(2)</code>, <code>chmod(2)</code>, <code>utime(2)</code>, <code>utimensat(2)</code>, and similar).</li>
 <li><a href="#DN_MULTISHOT"><code>DN_MULTISHOT</code></a> - Don't remove notifier</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.DN_MULTISHOT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SEAL_SEAL">
<h3>F_SEAL_SEAL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SEAL_SEAL</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> - 
 If this seal is set, any further call to <code>fcntl()</code> with <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> fails with the error <code>EPERM</code>.
 
 <p>Therefore, this seal prevents any modifications to the set of seals itself. If the initial set of seals of a file includes <code>F_SEAL_SEAL</code>,
 then this effectively causes the set of seals to be constant and locked.</p>
 </li>
 <li><a href="#F_SEAL_SHRINK"><code>F_SEAL_SHRINK</code></a> - 
 If this seal is set, the file in question cannot be reduced in size.
 
 <p>This affects <code>open(2)</code> with the <a href="#O_TRUNC"><code>O_TRUNC</code></a> flag as well as <code>truncate(2)</code> and <code>ftruncate(2)</code>. Those calls fail with <code>EPERM</code> if
 you try to shrink the file in question. Increasing the file size is still possible.</p>
 </li>
 <li><a href="#F_SEAL_GROW"><code>F_SEAL_GROW</code></a> - 
 If this seal is set, the size of the file in question cannot be increased.
 
 <p>This affects <code>write(2)</code> beyond the end of the file, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and <code>fallocate(2)</code>. These calls fail
 with <code>EPERM</code> if you use them to increase the file size. If you keep the size or shrink it, those calls still work as expected.</p>
 </li>
 <li><a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a> - 
 If this seal is set, you cannot modify the contents of the file.
 
 <p>Note that shrinking or growing the size of the file is still possible and allowed. Thus, this seal is normally used in combination with one of the
 other seals. This seal affects <code>write(2)</code> and <code>fallocate(2)</code> (only in combination with the <code>FALLOC_FL_PUNCH_HOLE</code> flag). Those
 calls fail with <code>EPERM</code> if this seal is set. Furthermore, trying to create new shared, writable memory-mappings via <code>mmap(2)</code> will also
 fail with <code>EPERM</code>.</p>
 
 <p>Using the <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> operation to set the <code>F_SEAL_WRITE</code> seal fails with <code>EBUSY</code> if any writable, shared mapping exists.  Such
 mappings must be unmapped before you can add this seal. Furthermore, if there are any asynchronous I/O operations (<code>io_submit(2)</code>) pending on
 the file, all outstanding writes will be discarded.</p>
 </li>
 <li><a href="#F_SEAL_FUTURE_WRITE"><code>F_SEAL_FUTURE_WRITE</code></a> - 
 The effect of this seal is similar to <a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a>, but the contents of the file can still be modified via shared writable mappings that were
 created prior to the seal being set.
 
 <p>Any attempt to create a new writable mapping on the file via <code>mmap(2)</code> will fail with <code>EPERM</code>. Likewise, an attempt to write to the
 file via <code>write(2)</code> will fail with <code>EPERM</code>.</p>
 
 <p>Using this seal, one process can create a memory buffer that it can continue to modify while sharing that buffer on a "read-only" basis with other
 processes.</p>
 
 <p>(since Linux 5.1)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SEAL_SEAL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SEAL_SHRINK">
<h3>F_SEAL_SHRINK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SEAL_SHRINK</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> - 
 If this seal is set, any further call to <code>fcntl()</code> with <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> fails with the error <code>EPERM</code>.
 
 <p>Therefore, this seal prevents any modifications to the set of seals itself. If the initial set of seals of a file includes <code>F_SEAL_SEAL</code>,
 then this effectively causes the set of seals to be constant and locked.</p>
 </li>
 <li><a href="#F_SEAL_SHRINK"><code>F_SEAL_SHRINK</code></a> - 
 If this seal is set, the file in question cannot be reduced in size.
 
 <p>This affects <code>open(2)</code> with the <a href="#O_TRUNC"><code>O_TRUNC</code></a> flag as well as <code>truncate(2)</code> and <code>ftruncate(2)</code>. Those calls fail with <code>EPERM</code> if
 you try to shrink the file in question. Increasing the file size is still possible.</p>
 </li>
 <li><a href="#F_SEAL_GROW"><code>F_SEAL_GROW</code></a> - 
 If this seal is set, the size of the file in question cannot be increased.
 
 <p>This affects <code>write(2)</code> beyond the end of the file, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and <code>fallocate(2)</code>. These calls fail
 with <code>EPERM</code> if you use them to increase the file size. If you keep the size or shrink it, those calls still work as expected.</p>
 </li>
 <li><a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a> - 
 If this seal is set, you cannot modify the contents of the file.
 
 <p>Note that shrinking or growing the size of the file is still possible and allowed. Thus, this seal is normally used in combination with one of the
 other seals. This seal affects <code>write(2)</code> and <code>fallocate(2)</code> (only in combination with the <code>FALLOC_FL_PUNCH_HOLE</code> flag). Those
 calls fail with <code>EPERM</code> if this seal is set. Furthermore, trying to create new shared, writable memory-mappings via <code>mmap(2)</code> will also
 fail with <code>EPERM</code>.</p>
 
 <p>Using the <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> operation to set the <code>F_SEAL_WRITE</code> seal fails with <code>EBUSY</code> if any writable, shared mapping exists.  Such
 mappings must be unmapped before you can add this seal. Furthermore, if there are any asynchronous I/O operations (<code>io_submit(2)</code>) pending on
 the file, all outstanding writes will be discarded.</p>
 </li>
 <li><a href="#F_SEAL_FUTURE_WRITE"><code>F_SEAL_FUTURE_WRITE</code></a> - 
 The effect of this seal is similar to <a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a>, but the contents of the file can still be modified via shared writable mappings that were
 created prior to the seal being set.
 
 <p>Any attempt to create a new writable mapping on the file via <code>mmap(2)</code> will fail with <code>EPERM</code>. Likewise, an attempt to write to the
 file via <code>write(2)</code> will fail with <code>EPERM</code>.</p>
 
 <p>Using this seal, one process can create a memory buffer that it can continue to modify while sharing that buffer on a "read-only" basis with other
 processes.</p>
 
 <p>(since Linux 5.1)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SEAL_SHRINK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SEAL_GROW">
<h3>F_SEAL_GROW</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SEAL_GROW</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> - 
 If this seal is set, any further call to <code>fcntl()</code> with <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> fails with the error <code>EPERM</code>.
 
 <p>Therefore, this seal prevents any modifications to the set of seals itself. If the initial set of seals of a file includes <code>F_SEAL_SEAL</code>,
 then this effectively causes the set of seals to be constant and locked.</p>
 </li>
 <li><a href="#F_SEAL_SHRINK"><code>F_SEAL_SHRINK</code></a> - 
 If this seal is set, the file in question cannot be reduced in size.
 
 <p>This affects <code>open(2)</code> with the <a href="#O_TRUNC"><code>O_TRUNC</code></a> flag as well as <code>truncate(2)</code> and <code>ftruncate(2)</code>. Those calls fail with <code>EPERM</code> if
 you try to shrink the file in question. Increasing the file size is still possible.</p>
 </li>
 <li><a href="#F_SEAL_GROW"><code>F_SEAL_GROW</code></a> - 
 If this seal is set, the size of the file in question cannot be increased.
 
 <p>This affects <code>write(2)</code> beyond the end of the file, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and <code>fallocate(2)</code>. These calls fail
 with <code>EPERM</code> if you use them to increase the file size. If you keep the size or shrink it, those calls still work as expected.</p>
 </li>
 <li><a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a> - 
 If this seal is set, you cannot modify the contents of the file.
 
 <p>Note that shrinking or growing the size of the file is still possible and allowed. Thus, this seal is normally used in combination with one of the
 other seals. This seal affects <code>write(2)</code> and <code>fallocate(2)</code> (only in combination with the <code>FALLOC_FL_PUNCH_HOLE</code> flag). Those
 calls fail with <code>EPERM</code> if this seal is set. Furthermore, trying to create new shared, writable memory-mappings via <code>mmap(2)</code> will also
 fail with <code>EPERM</code>.</p>
 
 <p>Using the <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> operation to set the <code>F_SEAL_WRITE</code> seal fails with <code>EBUSY</code> if any writable, shared mapping exists.  Such
 mappings must be unmapped before you can add this seal. Furthermore, if there are any asynchronous I/O operations (<code>io_submit(2)</code>) pending on
 the file, all outstanding writes will be discarded.</p>
 </li>
 <li><a href="#F_SEAL_FUTURE_WRITE"><code>F_SEAL_FUTURE_WRITE</code></a> - 
 The effect of this seal is similar to <a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a>, but the contents of the file can still be modified via shared writable mappings that were
 created prior to the seal being set.
 
 <p>Any attempt to create a new writable mapping on the file via <code>mmap(2)</code> will fail with <code>EPERM</code>. Likewise, an attempt to write to the
 file via <code>write(2)</code> will fail with <code>EPERM</code>.</p>
 
 <p>Using this seal, one process can create a memory buffer that it can continue to modify while sharing that buffer on a "read-only" basis with other
 processes.</p>
 
 <p>(since Linux 5.1)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SEAL_GROW">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SEAL_WRITE">
<h3>F_SEAL_WRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SEAL_WRITE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> - 
 If this seal is set, any further call to <code>fcntl()</code> with <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> fails with the error <code>EPERM</code>.
 
 <p>Therefore, this seal prevents any modifications to the set of seals itself. If the initial set of seals of a file includes <code>F_SEAL_SEAL</code>,
 then this effectively causes the set of seals to be constant and locked.</p>
 </li>
 <li><a href="#F_SEAL_SHRINK"><code>F_SEAL_SHRINK</code></a> - 
 If this seal is set, the file in question cannot be reduced in size.
 
 <p>This affects <code>open(2)</code> with the <a href="#O_TRUNC"><code>O_TRUNC</code></a> flag as well as <code>truncate(2)</code> and <code>ftruncate(2)</code>. Those calls fail with <code>EPERM</code> if
 you try to shrink the file in question. Increasing the file size is still possible.</p>
 </li>
 <li><a href="#F_SEAL_GROW"><code>F_SEAL_GROW</code></a> - 
 If this seal is set, the size of the file in question cannot be increased.
 
 <p>This affects <code>write(2)</code> beyond the end of the file, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and <code>fallocate(2)</code>. These calls fail
 with <code>EPERM</code> if you use them to increase the file size. If you keep the size or shrink it, those calls still work as expected.</p>
 </li>
 <li><a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a> - 
 If this seal is set, you cannot modify the contents of the file.
 
 <p>Note that shrinking or growing the size of the file is still possible and allowed. Thus, this seal is normally used in combination with one of the
 other seals. This seal affects <code>write(2)</code> and <code>fallocate(2)</code> (only in combination with the <code>FALLOC_FL_PUNCH_HOLE</code> flag). Those
 calls fail with <code>EPERM</code> if this seal is set. Furthermore, trying to create new shared, writable memory-mappings via <code>mmap(2)</code> will also
 fail with <code>EPERM</code>.</p>
 
 <p>Using the <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> operation to set the <code>F_SEAL_WRITE</code> seal fails with <code>EBUSY</code> if any writable, shared mapping exists.  Such
 mappings must be unmapped before you can add this seal. Furthermore, if there are any asynchronous I/O operations (<code>io_submit(2)</code>) pending on
 the file, all outstanding writes will be discarded.</p>
 </li>
 <li><a href="#F_SEAL_FUTURE_WRITE"><code>F_SEAL_FUTURE_WRITE</code></a> - 
 The effect of this seal is similar to <a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a>, but the contents of the file can still be modified via shared writable mappings that were
 created prior to the seal being set.
 
 <p>Any attempt to create a new writable mapping on the file via <code>mmap(2)</code> will fail with <code>EPERM</code>. Likewise, an attempt to write to the
 file via <code>write(2)</code> will fail with <code>EPERM</code>.</p>
 
 <p>Using this seal, one process can create a memory buffer that it can continue to modify while sharing that buffer on a "read-only" basis with other
 processes.</p>
 
 <p>(since Linux 5.1)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SEAL_WRITE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="F_SEAL_FUTURE_WRITE">
<h3>F_SEAL_FUTURE_WRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">F_SEAL_FUTURE_WRITE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#F_SEAL_SEAL"><code>F_SEAL_SEAL</code></a> - 
 If this seal is set, any further call to <code>fcntl()</code> with <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> fails with the error <code>EPERM</code>.
 
 <p>Therefore, this seal prevents any modifications to the set of seals itself. If the initial set of seals of a file includes <code>F_SEAL_SEAL</code>,
 then this effectively causes the set of seals to be constant and locked.</p>
 </li>
 <li><a href="#F_SEAL_SHRINK"><code>F_SEAL_SHRINK</code></a> - 
 If this seal is set, the file in question cannot be reduced in size.
 
 <p>This affects <code>open(2)</code> with the <a href="#O_TRUNC"><code>O_TRUNC</code></a> flag as well as <code>truncate(2)</code> and <code>ftruncate(2)</code>. Those calls fail with <code>EPERM</code> if
 you try to shrink the file in question. Increasing the file size is still possible.</p>
 </li>
 <li><a href="#F_SEAL_GROW"><code>F_SEAL_GROW</code></a> - 
 If this seal is set, the size of the file in question cannot be increased.
 
 <p>This affects <code>write(2)</code> beyond the end of the file, <code>truncate(2)</code>, <code>ftruncate(2)</code>, and <code>fallocate(2)</code>. These calls fail
 with <code>EPERM</code> if you use them to increase the file size. If you keep the size or shrink it, those calls still work as expected.</p>
 </li>
 <li><a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a> - 
 If this seal is set, you cannot modify the contents of the file.
 
 <p>Note that shrinking or growing the size of the file is still possible and allowed. Thus, this seal is normally used in combination with one of the
 other seals. This seal affects <code>write(2)</code> and <code>fallocate(2)</code> (only in combination with the <code>FALLOC_FL_PUNCH_HOLE</code> flag). Those
 calls fail with <code>EPERM</code> if this seal is set. Furthermore, trying to create new shared, writable memory-mappings via <code>mmap(2)</code> will also
 fail with <code>EPERM</code>.</p>
 
 <p>Using the <a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a> operation to set the <code>F_SEAL_WRITE</code> seal fails with <code>EBUSY</code> if any writable, shared mapping exists.  Such
 mappings must be unmapped before you can add this seal. Furthermore, if there are any asynchronous I/O operations (<code>io_submit(2)</code>) pending on
 the file, all outstanding writes will be discarded.</p>
 </li>
 <li><a href="#F_SEAL_FUTURE_WRITE"><code>F_SEAL_FUTURE_WRITE</code></a> - 
 The effect of this seal is similar to <a href="#F_SEAL_WRITE"><code>F_SEAL_WRITE</code></a>, but the contents of the file can still be modified via shared writable mappings that were
 created prior to the seal being set.
 
 <p>Any attempt to create a new writable mapping on the file via <code>mmap(2)</code> will fail with <code>EPERM</code>. Likewise, an attempt to write to the
 file via <code>write(2)</code> will fail with <code>EPERM</code>.</p>
 
 <p>Using this seal, one process can create a memory buffer that it can continue to modify while sharing that buffer on a "read-only" basis with other
 processes.</p>
 
 <p>(since Linux 5.1)</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.F_SEAL_FUTURE_WRITE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="RWH_WRITE_LIFE_NOT_SET">
<h3>RWH_WRITE_LIFE_NOT_SET</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">RWH_WRITE_LIFE_NOT_SET</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#RWH_WRITE_LIFE_NOT_SET"><code>RWH_WRITE_LIFE_NOT_SET</code></a> - No specific hint has been set. This is the default value.</li>
 <li><a href="#RWH_WRITE_LIFE_NONE"><code>RWH_WRITE_LIFE_NONE</code></a> - No specific write lifetime is associated with this file or <code>inode</code>.</li>
 <li><a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a> - Data written to this <code>inode</code> or via this open file description is expected to have a short lifetime.</li>
 <li><a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_EXTREME"><code>RWH_WRITE_LIFE_EXTREME</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a>.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.RWH_WRITE_LIFE_NOT_SET">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="RWH_WRITE_LIFE_NONE">
<h3>RWH_WRITE_LIFE_NONE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">RWH_WRITE_LIFE_NONE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#RWH_WRITE_LIFE_NOT_SET"><code>RWH_WRITE_LIFE_NOT_SET</code></a> - No specific hint has been set. This is the default value.</li>
 <li><a href="#RWH_WRITE_LIFE_NONE"><code>RWH_WRITE_LIFE_NONE</code></a> - No specific write lifetime is associated with this file or <code>inode</code>.</li>
 <li><a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a> - Data written to this <code>inode</code> or via this open file description is expected to have a short lifetime.</li>
 <li><a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_EXTREME"><code>RWH_WRITE_LIFE_EXTREME</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a>.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.RWH_WRITE_LIFE_NONE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="RWH_WRITE_LIFE_SHORT">
<h3>RWH_WRITE_LIFE_SHORT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">RWH_WRITE_LIFE_SHORT</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#RWH_WRITE_LIFE_NOT_SET"><code>RWH_WRITE_LIFE_NOT_SET</code></a> - No specific hint has been set. This is the default value.</li>
 <li><a href="#RWH_WRITE_LIFE_NONE"><code>RWH_WRITE_LIFE_NONE</code></a> - No specific write lifetime is associated with this file or <code>inode</code>.</li>
 <li><a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a> - Data written to this <code>inode</code> or via this open file description is expected to have a short lifetime.</li>
 <li><a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_EXTREME"><code>RWH_WRITE_LIFE_EXTREME</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a>.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.RWH_WRITE_LIFE_SHORT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="RWH_WRITE_LIFE_MEDIUM">
<h3>RWH_WRITE_LIFE_MEDIUM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">RWH_WRITE_LIFE_MEDIUM</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#RWH_WRITE_LIFE_NOT_SET"><code>RWH_WRITE_LIFE_NOT_SET</code></a> - No specific hint has been set. This is the default value.</li>
 <li><a href="#RWH_WRITE_LIFE_NONE"><code>RWH_WRITE_LIFE_NONE</code></a> - No specific write lifetime is associated with this file or <code>inode</code>.</li>
 <li><a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a> - Data written to this <code>inode</code> or via this open file description is expected to have a short lifetime.</li>
 <li><a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_EXTREME"><code>RWH_WRITE_LIFE_EXTREME</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a>.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.RWH_WRITE_LIFE_MEDIUM">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="RWH_WRITE_LIFE_LONG">
<h3>RWH_WRITE_LIFE_LONG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">RWH_WRITE_LIFE_LONG</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#RWH_WRITE_LIFE_NOT_SET"><code>RWH_WRITE_LIFE_NOT_SET</code></a> - No specific hint has been set. This is the default value.</li>
 <li><a href="#RWH_WRITE_LIFE_NONE"><code>RWH_WRITE_LIFE_NONE</code></a> - No specific write lifetime is associated with this file or <code>inode</code>.</li>
 <li><a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a> - Data written to this <code>inode</code> or via this open file description is expected to have a short lifetime.</li>
 <li><a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_EXTREME"><code>RWH_WRITE_LIFE_EXTREME</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a>.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.RWH_WRITE_LIFE_LONG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="RWH_WRITE_LIFE_EXTREME">
<h3>RWH_WRITE_LIFE_EXTREME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">RWH_WRITE_LIFE_EXTREME</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#RWH_WRITE_LIFE_NOT_SET"><code>RWH_WRITE_LIFE_NOT_SET</code></a> - No specific hint has been set. This is the default value.</li>
 <li><a href="#RWH_WRITE_LIFE_NONE"><code>RWH_WRITE_LIFE_NONE</code></a> - No specific write lifetime is associated with this file or <code>inode</code>.</li>
 <li><a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a> - Data written to this <code>inode</code> or via this open file description is expected to have a short lifetime.</li>
 <li><a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_SHORT"><code>RWH_WRITE_LIFE_SHORT</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_MEDIUM"><code>RWH_WRITE_LIFE_MEDIUM</code></a>.
 </li>
 <li><a href="#RWH_WRITE_LIFE_EXTREME"><code>RWH_WRITE_LIFE_EXTREME</code></a> - 
 Data written to this <code>inode</code> or via this open file description is expected to have a lifetime longer than data written with
 <a href="#RWH_WRITE_LIFE_LONG"><code>RWH_WRITE_LIFE_LONG</code></a>.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.FCNTL.RWH_WRITE_LIFE_EXTREME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="nopen(long,int,int)">
<h3>nopen</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nopen</span><wbr><span class="parameters">(long&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</span></div>
<div class="block">Unsafe version of: <a href="#open(java.nio.ByteBuffer,int,int)"><code>open(java.nio.ByteBuffer, int, int)</code></a></div>
</section>
</li>
<li>
<section class="detail" id="open(java.nio.ByteBuffer,int,int)">
<h3>open</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">open</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</span></div>
<div class="block">Given a <code>pathname</code> for a file, <code>open()</code> returns a file descriptor, a small, nonnegative integer for use in subsequent system calls
 (<code>read(2)</code>, <code>write(2)</code>, <code>lseek(2)</code>, <code>fcntl(2)</code>, etc.).
 
 <p>The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mode</code> - one or more of:<br><table><tr><td><a href="#S_IRWXU"><code>S_IRWXU</code></a></td><td><a href="#S_IRUSR"><code>S_IRUSR</code></a></td><td><a href="#S_IWUSR"><code>S_IWUSR</code></a></td><td><a href="#S_IXUSR"><code>S_IXUSR</code></a></td><td><a href="#S_IRWXG"><code>S_IRWXG</code></a></td><td><a href="#S_IRGRP"><code>S_IRGRP</code></a></td><td><a href="#S_IWGRP"><code>S_IWGRP</code></a></td><td><a href="#S_IXGRP"><code>S_IXGRP</code></a></td><td><a href="#S_IRWXO"><code>S_IRWXO</code></a></td><td><a href="#S_IROTH"><code>S_IROTH</code></a></td><td><a href="#S_IWOTH"><code>S_IWOTH</code></a></td></tr><tr><td><a href="#S_IXOTH"><code>S_IXOTH</code></a></td><td><a href="#S_ISUID"><code>S_ISUID</code></a></td><td><a href="#S_ISGID"><code>S_ISGID</code></a></td><td><a href="#S_ISVTX"><code>S_ISVTX</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>the new file descriptor, or -1 if an error occurred (in which case, <code>errno</code> is set appropriately).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="open(java.lang.CharSequence,int,int)">
<h3>open</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">open</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</span></div>
<div class="block">Given a <code>pathname</code> for a file, <code>open()</code> returns a file descriptor, a small, nonnegative integer for use in subsequent system calls
 (<code>read(2)</code>, <code>write(2)</code>, <code>lseek(2)</code>, <code>fcntl(2)</code>, etc.).
 
 <p>The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mode</code> - one or more of:<br><table><tr><td><a href="#S_IRWXU"><code>S_IRWXU</code></a></td><td><a href="#S_IRUSR"><code>S_IRUSR</code></a></td><td><a href="#S_IWUSR"><code>S_IWUSR</code></a></td><td><a href="#S_IXUSR"><code>S_IXUSR</code></a></td><td><a href="#S_IRWXG"><code>S_IRWXG</code></a></td><td><a href="#S_IRGRP"><code>S_IRGRP</code></a></td><td><a href="#S_IWGRP"><code>S_IWGRP</code></a></td><td><a href="#S_IXGRP"><code>S_IXGRP</code></a></td><td><a href="#S_IRWXO"><code>S_IRWXO</code></a></td><td><a href="#S_IROTH"><code>S_IROTH</code></a></td><td><a href="#S_IWOTH"><code>S_IWOTH</code></a></td></tr><tr><td><a href="#S_IXOTH"><code>S_IXOTH</code></a></td><td><a href="#S_ISUID"><code>S_ISUID</code></a></td><td><a href="#S_ISGID"><code>S_ISGID</code></a></td><td><a href="#S_ISVTX"><code>S_ISVTX</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>the new file descriptor, or -1 if an error occurred (in which case, <code>errno</code> is set appropriately).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nopenat(int,long,int,int)">
<h3>nopenat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nopenat</span><wbr><span class="parameters">(int&nbsp;dirfd,
 long&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</span></div>
<div class="block">Unsafe version of: <a href="#openat(int,java.nio.ByteBuffer,int,int)"><code>openat(int, java.nio.ByteBuffer, int, int)</code></a></div>
</section>
</li>
<li>
<section class="detail" id="openat(int,java.nio.ByteBuffer,int,int)">
<h3>openat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">openat</span><wbr><span class="parameters">(int&nbsp;dirfd,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</span></div>
<div class="block">The <code>openat()</code> system call operates in exactly the same way as <code>open(2)</code>, except for the differences described in this manual page.
 
 <p>If the pathname given in <code>pathname</code> is relative, then it is interpreted relative to the directory referred to by the file descriptor
 <code>dirfd</code> (rather than relative to the current working directory of the calling process, as is done by <code>open(2)</code> for a relative pathname).</p>
 
 <p>If <code>pathname</code> is relative and <code>dirfd</code> is the special value <code>AT_FDCWD</code>, then pathname is interpreted relative to the current working
 directory of the calling process (like <code>open(2)</code>).</p>
 
 <p>If <code>pathname</code> is absolute, then <code>dirfd</code> is ignored.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mode</code> - one or more of:<br><table><tr><td><a href="#S_IRWXU"><code>S_IRWXU</code></a></td><td><a href="#S_IRUSR"><code>S_IRUSR</code></a></td><td><a href="#S_IWUSR"><code>S_IWUSR</code></a></td><td><a href="#S_IXUSR"><code>S_IXUSR</code></a></td><td><a href="#S_IRWXG"><code>S_IRWXG</code></a></td><td><a href="#S_IRGRP"><code>S_IRGRP</code></a></td><td><a href="#S_IWGRP"><code>S_IWGRP</code></a></td><td><a href="#S_IXGRP"><code>S_IXGRP</code></a></td><td><a href="#S_IRWXO"><code>S_IRWXO</code></a></td><td><a href="#S_IROTH"><code>S_IROTH</code></a></td><td><a href="#S_IWOTH"><code>S_IWOTH</code></a></td></tr><tr><td><a href="#S_IXOTH"><code>S_IXOTH</code></a></td><td><a href="#S_ISUID"><code>S_ISUID</code></a></td><td><a href="#S_ISGID"><code>S_ISGID</code></a></td><td><a href="#S_ISVTX"><code>S_ISVTX</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>a new file descriptor on success. On error, -1 is returned and <code>errno</code> is set to indicate the error.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="openat(int,java.lang.CharSequence,int,int)">
<h3>openat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">openat</span><wbr><span class="parameters">(int&nbsp;dirfd,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pathname,
 int&nbsp;flags,
 int&nbsp;mode)</span></div>
<div class="block">The <code>openat()</code> system call operates in exactly the same way as <code>open(2)</code>, except for the differences described in this manual page.
 
 <p>If the pathname given in <code>pathname</code> is relative, then it is interpreted relative to the directory referred to by the file descriptor
 <code>dirfd</code> (rather than relative to the current working directory of the calling process, as is done by <code>open(2)</code> for a relative pathname).</p>
 
 <p>If <code>pathname</code> is relative and <code>dirfd</code> is the special value <code>AT_FDCWD</code>, then pathname is interpreted relative to the current working
 directory of the calling process (like <code>open(2)</code>).</p>
 
 <p>If <code>pathname</code> is absolute, then <code>dirfd</code> is ignored.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mode</code> - one or more of:<br><table><tr><td><a href="#S_IRWXU"><code>S_IRWXU</code></a></td><td><a href="#S_IRUSR"><code>S_IRUSR</code></a></td><td><a href="#S_IWUSR"><code>S_IWUSR</code></a></td><td><a href="#S_IXUSR"><code>S_IXUSR</code></a></td><td><a href="#S_IRWXG"><code>S_IRWXG</code></a></td><td><a href="#S_IRGRP"><code>S_IRGRP</code></a></td><td><a href="#S_IWGRP"><code>S_IWGRP</code></a></td><td><a href="#S_IXGRP"><code>S_IXGRP</code></a></td><td><a href="#S_IRWXO"><code>S_IRWXO</code></a></td><td><a href="#S_IROTH"><code>S_IROTH</code></a></td><td><a href="#S_IWOTH"><code>S_IWOTH</code></a></td></tr><tr><td><a href="#S_IXOTH"><code>S_IXOTH</code></a></td><td><a href="#S_ISUID"><code>S_ISUID</code></a></td><td><a href="#S_ISGID"><code>S_ISGID</code></a></td><td><a href="#S_ISVTX"><code>S_ISVTX</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>a new file descriptor on success. On error, -1 is returned and <code>errno</code> is set to indicate the error.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ncreat(long,int)">
<h3>ncreat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ncreat</span><wbr><span class="parameters">(long&nbsp;pathname,
 int&nbsp;mode)</span></div>
<div class="block">Unsafe version of: <a href="#creat(java.nio.ByteBuffer,int)"><code>creat(java.nio.ByteBuffer, int)</code></a></div>
</section>
</li>
<li>
<section class="detail" id="creat(java.nio.ByteBuffer,int)">
<h3>creat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">creat</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pathname,
 int&nbsp;mode)</span></div>
<div class="block">Equivalent to <code>open()</code> with <code>flags</code> equal to <code>O_CREAT|O_WRONLY|O_TRUNC</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mode</code> - one or more of:<br><table><tr><td><a href="#S_IRWXU"><code>S_IRWXU</code></a></td><td><a href="#S_IRUSR"><code>S_IRUSR</code></a></td><td><a href="#S_IWUSR"><code>S_IWUSR</code></a></td><td><a href="#S_IXUSR"><code>S_IXUSR</code></a></td><td><a href="#S_IRWXG"><code>S_IRWXG</code></a></td><td><a href="#S_IRGRP"><code>S_IRGRP</code></a></td><td><a href="#S_IWGRP"><code>S_IWGRP</code></a></td><td><a href="#S_IXGRP"><code>S_IXGRP</code></a></td><td><a href="#S_IRWXO"><code>S_IRWXO</code></a></td><td><a href="#S_IROTH"><code>S_IROTH</code></a></td><td><a href="#S_IWOTH"><code>S_IWOTH</code></a></td></tr><tr><td><a href="#S_IXOTH"><code>S_IXOTH</code></a></td><td><a href="#S_ISUID"><code>S_ISUID</code></a></td><td><a href="#S_ISGID"><code>S_ISGID</code></a></td><td><a href="#S_ISVTX"><code>S_ISVTX</code></a></td></tr></table></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="creat(java.lang.CharSequence,int)">
<h3>creat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">creat</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pathname,
 int&nbsp;mode)</span></div>
<div class="block">Equivalent to <code>open()</code> with <code>flags</code> equal to <code>O_CREAT|O_WRONLY|O_TRUNC</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mode</code> - one or more of:<br><table><tr><td><a href="#S_IRWXU"><code>S_IRWXU</code></a></td><td><a href="#S_IRUSR"><code>S_IRUSR</code></a></td><td><a href="#S_IWUSR"><code>S_IWUSR</code></a></td><td><a href="#S_IXUSR"><code>S_IXUSR</code></a></td><td><a href="#S_IRWXG"><code>S_IRWXG</code></a></td><td><a href="#S_IRGRP"><code>S_IRGRP</code></a></td><td><a href="#S_IWGRP"><code>S_IWGRP</code></a></td><td><a href="#S_IXGRP"><code>S_IXGRP</code></a></td><td><a href="#S_IRWXO"><code>S_IRWXO</code></a></td><td><a href="#S_IROTH"><code>S_IROTH</code></a></td><td><a href="#S_IWOTH"><code>S_IWOTH</code></a></td></tr><tr><td><a href="#S_IXOTH"><code>S_IXOTH</code></a></td><td><a href="#S_ISUID"><code>S_ISUID</code></a></td><td><a href="#S_ISGID"><code>S_ISGID</code></a></td><td><a href="#S_ISVTX"><code>S_ISVTX</code></a></td></tr></table></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="fcntl(int,int)">
<h3>fcntl</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">fcntl</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;cmd)</span></div>
<div class="block">Performs one of the operations determined by <code>cmd</code> on the open file descriptor <code>fd</code>.
 
 <p><code>fcntl()</code> can take an optional third argument.  Whether or not this argument is required is determined by <code>cmd</code>. The required argument type
 is indicated in parentheses after each <code>cmd</code> name (in most cases, the required type is <code>int</code>, and we identify the argument using the name
 <code>arg</code>), or <code>void</code> is specified if the argument is not required.</p>
 
 <p><b>LWJGL note</b>: Use <a href="#fcntli(int,int,int)"><code>fcntli(int, int, int)</code></a> or <a href="#fcntlp(int,int,long)"><code>fcntlp(int, int, long)</code></a> to pass a third argument of the appropriate type.</p>
 
 <p>Certain of the operations below are supported only since a particular Linux kernel version. The preferred method of checking whether the host kernel
 supports a particular operation is to invoke <code>fcntl()</code> with the desired <code>cmd</code> value and then test whether the call failed with
 <code>EINVAL</code>, indicating that the kernel does not recognize this value.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cmd</code> - one of:<br><table><tr><td><a href="#F_DUPFD"><code>F_DUPFD</code></a></td><td><a href="#F_GETFD"><code>F_GETFD</code></a></td><td><a href="#F_SETFD"><code>F_SETFD</code></a></td><td><a href="#F_GETFL"><code>F_GETFL</code></a></td><td><a href="#F_SETFL"><code>F_SETFL</code></a></td><td><a href="#F_GETLK"><code>F_GETLK</code></a></td><td><a href="#F_SETLK"><code>F_SETLK</code></a></td><td><a href="#F_SETLKW"><code>F_SETLKW</code></a></td></tr><tr><td><a href="#F_SETOWN"><code>F_SETOWN</code></a></td><td><a href="#F_GETOWN"><code>F_GETOWN</code></a></td><td><a href="#F_SETSIG"><code>F_SETSIG</code></a></td><td><a href="#F_GETSIG"><code>F_GETSIG</code></a></td><td><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a></td><td><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a></td><td><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a></td><td><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a></td></tr><tr><td><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a></td><td><a href="#F_SETLEASE"><code>F_SETLEASE</code></a></td><td><a href="#F_GETLEASE"><code>F_GETLEASE</code></a></td><td><a href="#F_NOTIFY"><code>F_NOTIFY</code></a></td><td><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a></td><td><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a></td><td><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a></td><td><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a></td></tr><tr><td><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a></td><td><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a></td><td><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a></td><td><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a></td><td><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a></td></tr></table></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nfcntli(int,int,int)">
<h3>nfcntli</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nfcntli</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;cmd,
 int&nbsp;arg)</span></div>
<div class="block">Unsafe version of: <a href="#fcntli(int,int,int)"><code>fcntli(int, int, int)</code></a></div>
</section>
</li>
<li>
<section class="detail" id="fcntli(int,int,int)">
<h3>fcntli</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">fcntli</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;cmd,
 int&nbsp;arg)</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> overload that takes a third argument of type <code>int</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cmd</code> - one of:<br><table><tr><td><a href="#F_DUPFD"><code>F_DUPFD</code></a></td><td><a href="#F_GETFD"><code>F_GETFD</code></a></td><td><a href="#F_SETFD"><code>F_SETFD</code></a></td><td><a href="#F_GETFL"><code>F_GETFL</code></a></td><td><a href="#F_SETFL"><code>F_SETFL</code></a></td><td><a href="#F_GETLK"><code>F_GETLK</code></a></td><td><a href="#F_SETLK"><code>F_SETLK</code></a></td><td><a href="#F_SETLKW"><code>F_SETLKW</code></a></td></tr><tr><td><a href="#F_SETOWN"><code>F_SETOWN</code></a></td><td><a href="#F_GETOWN"><code>F_GETOWN</code></a></td><td><a href="#F_SETSIG"><code>F_SETSIG</code></a></td><td><a href="#F_GETSIG"><code>F_GETSIG</code></a></td><td><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a></td><td><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a></td><td><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a></td><td><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a></td></tr><tr><td><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a></td><td><a href="#F_SETLEASE"><code>F_SETLEASE</code></a></td><td><a href="#F_GETLEASE"><code>F_GETLEASE</code></a></td><td><a href="#F_NOTIFY"><code>F_NOTIFY</code></a></td><td><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a></td><td><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a></td><td><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a></td><td><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a></td></tr><tr><td><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a></td><td><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a></td><td><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a></td><td><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a></td><td><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a></td></tr></table></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nfcntlp(int,int,long)">
<h3>nfcntlp</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nfcntlp</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;cmd,
 long&nbsp;arg)</span></div>
<div class="block">Unsafe version of: <a href="#fcntlp(int,int,long)"><code>fcntlp(int, int, long)</code></a></div>
</section>
</li>
<li>
<section class="detail" id="fcntlp(int,int,long)">
<h3>fcntlp</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">fcntlp</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;cmd,
 long&nbsp;arg)</span></div>
<div class="block"><a href="#fcntl(int,int)"><code>fcntl(int, int)</code></a> overload that takes a third argument of type <code>void *</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cmd</code> - one of:<br><table><tr><td><a href="#F_DUPFD"><code>F_DUPFD</code></a></td><td><a href="#F_GETFD"><code>F_GETFD</code></a></td><td><a href="#F_SETFD"><code>F_SETFD</code></a></td><td><a href="#F_GETFL"><code>F_GETFL</code></a></td><td><a href="#F_SETFL"><code>F_SETFL</code></a></td><td><a href="#F_GETLK"><code>F_GETLK</code></a></td><td><a href="#F_SETLK"><code>F_SETLK</code></a></td><td><a href="#F_SETLKW"><code>F_SETLKW</code></a></td></tr><tr><td><a href="#F_SETOWN"><code>F_SETOWN</code></a></td><td><a href="#F_GETOWN"><code>F_GETOWN</code></a></td><td><a href="#F_SETSIG"><code>F_SETSIG</code></a></td><td><a href="#F_GETSIG"><code>F_GETSIG</code></a></td><td><a href="#F_SETOWN_EX"><code>F_SETOWN_EX</code></a></td><td><a href="#F_GETOWN_EX"><code>F_GETOWN_EX</code></a></td><td><a href="#F_OFD_GETLK"><code>F_OFD_GETLK</code></a></td><td><a href="#F_OFD_SETLK"><code>F_OFD_SETLK</code></a></td></tr><tr><td><a href="#F_OFD_SETLKW"><code>F_OFD_SETLKW</code></a></td><td><a href="#F_SETLEASE"><code>F_SETLEASE</code></a></td><td><a href="#F_GETLEASE"><code>F_GETLEASE</code></a></td><td><a href="#F_NOTIFY"><code>F_NOTIFY</code></a></td><td><a href="#F_SETPIPE_SZ"><code>F_SETPIPE_SZ</code></a></td><td><a href="#F_GETPIPE_SZ"><code>F_GETPIPE_SZ</code></a></td><td><a href="#F_ADD_SEALS"><code>F_ADD_SEALS</code></a></td><td><a href="#F_GET_SEALS"><code>F_GET_SEALS</code></a></td></tr><tr><td><a href="#F_GET_RW_HINT"><code>F_GET_RW_HINT</code></a></td><td><a href="#F_SET_RW_HINT"><code>F_SET_RW_HINT</code></a></td><td><a href="#F_GET_FILE_RW_HINT"><code>F_GET_FILE_RW_HINT</code></a></td><td><a href="#F_SET_FILE_RW_HINT"><code>F_SET_FILE_RW_HINT</code></a></td><td><a href="#F_DUPFD_CLOEXEC"><code>F_DUPFD_CLOEXEC</code></a></td></tr></table></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</div>
</div>
</body>
</html>
