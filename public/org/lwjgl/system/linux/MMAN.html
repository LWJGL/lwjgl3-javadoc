<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) -->
<title>MMAN (LWJGL 3.3.2-snapshot)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.lwjgl.system.linux, class: MMAN">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li><a href="#field-summary">Field</a></li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.lwjgl.system.linux</a></div>
<h1 title="Class MMAN" class="title">Class MMAN</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.lwjgl.system.linux.MMAN</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">MMAN</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Native bindings to &lt;sys/mman.h&gt;.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_32BIT" class="member-name-link">MAP_32BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_ANON" class="member-name-link">MAP_ANON</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_ANONYMOUS" class="member-name-link">MAP_ANONYMOUS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_DENYWRITE" class="member-name-link">MAP_DENYWRITE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_EXECUTABLE" class="member-name-link">MAP_EXECUTABLE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final long</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_FAILED" class="member-name-link">MAP_FAILED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Return value of <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> in case of an error.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_FILE" class="member-name-link">MAP_FILE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_FIXED" class="member-name-link">MAP_FIXED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_FIXED_NOREPLACE" class="member-name-link">MAP_FIXED_NOREPLACE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_GROWSDOWN" class="member-name-link">MAP_GROWSDOWN</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_HUGE_1GB" class="member-name-link">MAP_HUGE_1GB</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_HUGE_2MB" class="member-name-link">MAP_HUGE_2MB</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_HUGE_MASK" class="member-name-link">MAP_HUGE_MASK</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_HUGE_SHIFT" class="member-name-link">MAP_HUGE_SHIFT</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_HUGETLB" class="member-name-link">MAP_HUGETLB</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_LOCKED" class="member-name-link">MAP_LOCKED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_NONBLOCK" class="member-name-link">MAP_NONBLOCK</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_NORESERVE" class="member-name-link">MAP_NORESERVE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_POPULATE" class="member-name-link">MAP_POPULATE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_PRIVATE" class="member-name-link">MAP_PRIVATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried
 through to the underlying file.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_SHARED" class="member-name-link">MAP_SHARED</a></code></div>
<div class="col-last even-row-color">
<div class="block">The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried
 through to the underlying file.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_SHARED_VALIDATE" class="member-name-link">MAP_SHARED_VALIDATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried
 through to the underlying file.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_STACK" class="member-name-link">MAP_STACK</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MAP_SYNC" class="member-name-link">MAP_SYNC</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAP_UNINITIALIZED" class="member-name-link">MAP_UNINITIALIZED</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum values:</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#PROT_EXEC" class="member-name-link">PROT_EXEC</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#PROT_GROWSDOWN" class="member-name-link">PROT_GROWSDOWN</a></code></div>
<div class="col-last even-row-color">
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#PROT_GROWSUP" class="member-name-link">PROT_GROWSUP</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#PROT_NONE" class="member-name-link">PROT_NONE</a></code></div>
<div class="col-last even-row-color">
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#PROT_READ" class="member-name-link">PROT_READ</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#PROT_WRITE" class="member-name-link">PROT_WRITE</a></code></div>
<div class="col-last even-row-color">
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#mmap(long,long,int,int,int,long)" class="member-name-link">mmap</a><wbr>(long&nbsp;addr,
 long&nbsp;length,
 int&nbsp;prot,
 int&nbsp;flags,
 int&nbsp;fd,
 long&nbsp;offset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a new mapping in the virtual address space of the calling process.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#munmap(java.nio.ByteBuffer)" class="member-name-link">munmap</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;addr)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Deletes the mappings for the specified address range, and causes further references to addresses within the range to generate invalid memory
 references.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nmunmap(long,long)" class="member-name-link">nmunmap</a><wbr>(long&nbsp;addr,
 long&nbsp;length)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#munmap(java.nio.ByteBuffer)"><code>munmap(java.nio.ByteBuffer)</code></a></div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="MAP_FAILED">
<h3>MAP_FAILED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">MAP_FAILED</span></div>
<div class="block">Return value of <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> in case of an error.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_FAILED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PROT_EXEC">
<h3>PROT_EXEC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">PROT_EXEC</span></div>
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).
 
 <p>It is either <code>PROT_NONE</code> or the bitwise OR of one or more of the following flags.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#PROT_EXEC"><code>PROT_EXEC</code></a> - Pages may be executed.</li>
 <li><a href="#PROT_READ"><code>PROT_READ</code></a> - Pages may be read.</li>
 <li><a href="#PROT_WRITE"><code>PROT_WRITE</code></a> - Pages may be written.</li>
 <li><a href="#PROT_NONE"><code>PROT_NONE</code></a> - Pages may not be accessed.</li>
 <li><a href="#PROT_GROWSDOWN"><code>PROT_GROWSDOWN</code></a> - Extend change to start of <code>growsdown</code> vma (<code>mprotect</code> only).</li>
 <li><a href="#PROT_GROWSUP"><code>PROT_GROWSUP</code></a> - Extend change to start of <code>growsup</code> vma (<code>mprotect</code> only).</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.PROT_EXEC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PROT_READ">
<h3>PROT_READ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">PROT_READ</span></div>
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).
 
 <p>It is either <code>PROT_NONE</code> or the bitwise OR of one or more of the following flags.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#PROT_EXEC"><code>PROT_EXEC</code></a> - Pages may be executed.</li>
 <li><a href="#PROT_READ"><code>PROT_READ</code></a> - Pages may be read.</li>
 <li><a href="#PROT_WRITE"><code>PROT_WRITE</code></a> - Pages may be written.</li>
 <li><a href="#PROT_NONE"><code>PROT_NONE</code></a> - Pages may not be accessed.</li>
 <li><a href="#PROT_GROWSDOWN"><code>PROT_GROWSDOWN</code></a> - Extend change to start of <code>growsdown</code> vma (<code>mprotect</code> only).</li>
 <li><a href="#PROT_GROWSUP"><code>PROT_GROWSUP</code></a> - Extend change to start of <code>growsup</code> vma (<code>mprotect</code> only).</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.PROT_READ">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PROT_WRITE">
<h3>PROT_WRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">PROT_WRITE</span></div>
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).
 
 <p>It is either <code>PROT_NONE</code> or the bitwise OR of one or more of the following flags.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#PROT_EXEC"><code>PROT_EXEC</code></a> - Pages may be executed.</li>
 <li><a href="#PROT_READ"><code>PROT_READ</code></a> - Pages may be read.</li>
 <li><a href="#PROT_WRITE"><code>PROT_WRITE</code></a> - Pages may be written.</li>
 <li><a href="#PROT_NONE"><code>PROT_NONE</code></a> - Pages may not be accessed.</li>
 <li><a href="#PROT_GROWSDOWN"><code>PROT_GROWSDOWN</code></a> - Extend change to start of <code>growsdown</code> vma (<code>mprotect</code> only).</li>
 <li><a href="#PROT_GROWSUP"><code>PROT_GROWSUP</code></a> - Extend change to start of <code>growsup</code> vma (<code>mprotect</code> only).</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.PROT_WRITE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PROT_NONE">
<h3>PROT_NONE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">PROT_NONE</span></div>
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).
 
 <p>It is either <code>PROT_NONE</code> or the bitwise OR of one or more of the following flags.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#PROT_EXEC"><code>PROT_EXEC</code></a> - Pages may be executed.</li>
 <li><a href="#PROT_READ"><code>PROT_READ</code></a> - Pages may be read.</li>
 <li><a href="#PROT_WRITE"><code>PROT_WRITE</code></a> - Pages may be written.</li>
 <li><a href="#PROT_NONE"><code>PROT_NONE</code></a> - Pages may not be accessed.</li>
 <li><a href="#PROT_GROWSDOWN"><code>PROT_GROWSDOWN</code></a> - Extend change to start of <code>growsdown</code> vma (<code>mprotect</code> only).</li>
 <li><a href="#PROT_GROWSUP"><code>PROT_GROWSUP</code></a> - Extend change to start of <code>growsup</code> vma (<code>mprotect</code> only).</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.PROT_NONE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PROT_GROWSDOWN">
<h3>PROT_GROWSDOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">PROT_GROWSDOWN</span></div>
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).
 
 <p>It is either <code>PROT_NONE</code> or the bitwise OR of one or more of the following flags.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#PROT_EXEC"><code>PROT_EXEC</code></a> - Pages may be executed.</li>
 <li><a href="#PROT_READ"><code>PROT_READ</code></a> - Pages may be read.</li>
 <li><a href="#PROT_WRITE"><code>PROT_WRITE</code></a> - Pages may be written.</li>
 <li><a href="#PROT_NONE"><code>PROT_NONE</code></a> - Pages may not be accessed.</li>
 <li><a href="#PROT_GROWSDOWN"><code>PROT_GROWSDOWN</code></a> - Extend change to start of <code>growsdown</code> vma (<code>mprotect</code> only).</li>
 <li><a href="#PROT_GROWSUP"><code>PROT_GROWSUP</code></a> - Extend change to start of <code>growsup</code> vma (<code>mprotect</code> only).</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.PROT_GROWSDOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PROT_GROWSUP">
<h3>PROT_GROWSUP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">PROT_GROWSUP</span></div>
<div class="block">The <code>prot</code> argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).
 
 <p>It is either <code>PROT_NONE</code> or the bitwise OR of one or more of the following flags.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#PROT_EXEC"><code>PROT_EXEC</code></a> - Pages may be executed.</li>
 <li><a href="#PROT_READ"><code>PROT_READ</code></a> - Pages may be read.</li>
 <li><a href="#PROT_WRITE"><code>PROT_WRITE</code></a> - Pages may be written.</li>
 <li><a href="#PROT_NONE"><code>PROT_NONE</code></a> - Pages may not be accessed.</li>
 <li><a href="#PROT_GROWSDOWN"><code>PROT_GROWSDOWN</code></a> - Extend change to start of <code>growsdown</code> vma (<code>mprotect</code> only).</li>
 <li><a href="#PROT_GROWSUP"><code>PROT_GROWSUP</code></a> - Extend change to start of <code>growsup</code> vma (<code>mprotect</code> only).</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.PROT_GROWSUP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_SHARED">
<h3>MAP_SHARED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_SHARED</span></div>
<div class="block">The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried
 through to the underlying file.
 
 <p>This behavior is determined by including exactly one of the following values in <code>flags</code>.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_SHARED"><code>MAP_SHARED</code></a> - 
 Share this mapping.
 
 <p>Updates to the mapping are visible to other processes mapping the same region, and (in the case of file-backed mappings) are carried through to the
 underlying file. (To precisely control when updates are carried through to the underlying file requires the use of <code>msync(2)</code>.)</p>
 </li>
 <li><a href="#MAP_SHARED_VALIDATE"><code>MAP_SHARED_VALIDATE</code></a> - 
 This flag provides the same behavior as <a href="#MAP_SHARED"><code>MAP_SHARED</code></a> except that <code>MAP_SHARED</code> mappings ignore unknown flags in <code>flags</code>.
 
 <p>By contrast, when creating a mapping using <code>MAP_SHARED_VALIDATE</code>, the kernel verifies all passed flags are known and fails the mapping with
 the error <code>EOPNOTSUPP</code> for unknown flags. This mapping type is also required to be able to use some mapping flags (e.g., <code>MAP_SYNC</code>).</p>
 </li>
 <li><a href="#MAP_PRIVATE"><code>MAP_PRIVATE</code></a> - 
 Create a private copy-on-write mapping.
 
 <p>Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file.  It is
 unspecified whether changes made to the file after the <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> call are visible in the mapped region.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_SHARED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_SHARED_VALIDATE">
<h3>MAP_SHARED_VALIDATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_SHARED_VALIDATE</span></div>
<div class="block">The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried
 through to the underlying file.
 
 <p>This behavior is determined by including exactly one of the following values in <code>flags</code>.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_SHARED"><code>MAP_SHARED</code></a> - 
 Share this mapping.
 
 <p>Updates to the mapping are visible to other processes mapping the same region, and (in the case of file-backed mappings) are carried through to the
 underlying file. (To precisely control when updates are carried through to the underlying file requires the use of <code>msync(2)</code>.)</p>
 </li>
 <li><a href="#MAP_SHARED_VALIDATE"><code>MAP_SHARED_VALIDATE</code></a> - 
 This flag provides the same behavior as <a href="#MAP_SHARED"><code>MAP_SHARED</code></a> except that <code>MAP_SHARED</code> mappings ignore unknown flags in <code>flags</code>.
 
 <p>By contrast, when creating a mapping using <code>MAP_SHARED_VALIDATE</code>, the kernel verifies all passed flags are known and fails the mapping with
 the error <code>EOPNOTSUPP</code> for unknown flags. This mapping type is also required to be able to use some mapping flags (e.g., <code>MAP_SYNC</code>).</p>
 </li>
 <li><a href="#MAP_PRIVATE"><code>MAP_PRIVATE</code></a> - 
 Create a private copy-on-write mapping.
 
 <p>Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file.  It is
 unspecified whether changes made to the file after the <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> call are visible in the mapped region.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_SHARED_VALIDATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_PRIVATE">
<h3>MAP_PRIVATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_PRIVATE</span></div>
<div class="block">The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried
 through to the underlying file.
 
 <p>This behavior is determined by including exactly one of the following values in <code>flags</code>.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_SHARED"><code>MAP_SHARED</code></a> - 
 Share this mapping.
 
 <p>Updates to the mapping are visible to other processes mapping the same region, and (in the case of file-backed mappings) are carried through to the
 underlying file. (To precisely control when updates are carried through to the underlying file requires the use of <code>msync(2)</code>.)</p>
 </li>
 <li><a href="#MAP_SHARED_VALIDATE"><code>MAP_SHARED_VALIDATE</code></a> - 
 This flag provides the same behavior as <a href="#MAP_SHARED"><code>MAP_SHARED</code></a> except that <code>MAP_SHARED</code> mappings ignore unknown flags in <code>flags</code>.
 
 <p>By contrast, when creating a mapping using <code>MAP_SHARED_VALIDATE</code>, the kernel verifies all passed flags are known and fails the mapping with
 the error <code>EOPNOTSUPP</code> for unknown flags. This mapping type is also required to be able to use some mapping flags (e.g., <code>MAP_SYNC</code>).</p>
 </li>
 <li><a href="#MAP_PRIVATE"><code>MAP_PRIVATE</code></a> - 
 Create a private copy-on-write mapping.
 
 <p>Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file.  It is
 unspecified whether changes made to the file after the <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> call are visible in the mapped region.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_PRIVATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_HUGE_SHIFT">
<h3>MAP_HUGE_SHIFT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_HUGE_SHIFT</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_HUGE_SHIFT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_HUGE_MASK">
<h3>MAP_HUGE_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_HUGE_MASK</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_HUGE_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_32BIT">
<h3>MAP_32BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_32BIT</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_32BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_ANONYMOUS">
<h3>MAP_ANONYMOUS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_ANONYMOUS</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_ANONYMOUS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_ANON">
<h3>MAP_ANON</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_ANON</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_ANON">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_DENYWRITE">
<h3>MAP_DENYWRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_DENYWRITE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_DENYWRITE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_EXECUTABLE">
<h3>MAP_EXECUTABLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_EXECUTABLE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_EXECUTABLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_FILE">
<h3>MAP_FILE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_FILE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_FILE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_FIXED">
<h3>MAP_FIXED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_FIXED</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_FIXED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_FIXED_NOREPLACE">
<h3>MAP_FIXED_NOREPLACE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_FIXED_NOREPLACE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_FIXED_NOREPLACE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_GROWSDOWN">
<h3>MAP_GROWSDOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_GROWSDOWN</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_GROWSDOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_HUGETLB">
<h3>MAP_HUGETLB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_HUGETLB</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_HUGETLB">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_HUGE_2MB">
<h3>MAP_HUGE_2MB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_HUGE_2MB</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_HUGE_2MB">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_HUGE_1GB">
<h3>MAP_HUGE_1GB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_HUGE_1GB</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_HUGE_1GB">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_LOCKED">
<h3>MAP_LOCKED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_LOCKED</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_LOCKED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_NONBLOCK">
<h3>MAP_NONBLOCK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_NONBLOCK</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_NONBLOCK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_NORESERVE">
<h3>MAP_NORESERVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_NORESERVE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_NORESERVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_POPULATE">
<h3>MAP_POPULATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_POPULATE</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_POPULATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_STACK">
<h3>MAP_STACK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_STACK</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_STACK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_SYNC">
<h3>MAP_SYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_SYNC</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_SYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAP_UNINITIALIZED">
<h3>MAP_UNINITIALIZED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAP_UNINITIALIZED</span></div>
<div class="block"><h5>Enum values:</h5>
 
 <ul>
 <li><a href="#MAP_32BIT"><code>MAP_32BIT</code></a> - 
 Put the mapping into the first 2 Gigabytes of the process address space.
 
 <p>This flag is supported only on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2 GB of
 memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance
 problem, so use of this flag is not required on those systems. The <code>MAP_32BIT</code> flag is ignored when <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> is set.</p>
 </li>
 <li><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a> - 
 The mapping is not backed by any file; its contents are initialized to zero.
 
 <p>The <code>fd</code> argument is ignored; however, some implementations require <code>fd</code> to be -1 if <code>MAP_ANONYMOUS</code> (or <a href="#MAP_ANON"><code>MAP_ANON</code></a>) is specified,
 and portable applications should ensure this. The <code>offset</code> argument should be zero. The use of <code>MAP_ANONYMOUS</code> in conjunction with
 <code>MAP_SHARED</code> is supported on Linux only since kernel 2.4.</p>
 </li>
 <li><a href="#MAP_ANON"><code>MAP_ANON</code></a> - Synonym for MAP_ANONYMOUS; provided for compatibility with other implementations.</li>
 <li><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a> - 
 This flag is ignored.
 
 <p>(Long ago —Linux 2.0 and earlier— it signaled that attempts to write to the underlying file should fail with <code>ETXTBSY</code>. But this was a source
 of denial-of-service attacks.)</p>
 </li>
 <li><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a> - This flag is ignored.</li>
 <li><a href="#MAP_FILE"><code>MAP_FILE</code></a> - Compatibility flag. Ignored.</li>
 <li><a href="#MAP_FIXED"><code>MAP_FIXED</code></a> - 
 Don't interpret <code>addr</code> as a hint: place the mapping at exactly that address.
 
 <p><code>addr</code> must be suitably aligned: for most architectures a multiple of the page size is sufficient; however, some architectures may impose
 additional restrictions. If the memory region specified by <code>addr</code> and <code>length</code> overlaps pages of any existing mapping(s), then the
 overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, <a href="#mmap(long,long,int,int,int,long)"><code>mmap(long, long, int, int, int, long)</code></a> will fail.</p>
 
 <p>Software that aspires to be portable should use the <code>MAP_FIXED</code> flag with care, keeping in mind that the exact layout of a process's memory
 mappings is allowed to change significantly between kernel versions, C library versions, and operating system releases. Carefully read the
 discussion of this flag in NOTES!</p>
 </li>
 <li><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a> - 
 This flag provides behavior that is similar to <a href="#MAP_FIXED"><code>MAP_FIXED</code></a> with respect to the <code>addr</code> enforcement, but differs in that
 <code>MAP_FIXED_NOREPLACE</code> never clobbers a preexisting mapped range.
 
 <p>If the requested range would collide with an existing mapping, then this call fails with the error <code>EEXIST</code>. This flag can therefore be used
 as a way to atomically (with respect to other threads) attempt to map an address range: one thread will succeed; all others will report failure.</p>
 
 <p>Note that older kernels which do not recognize the <code>MAP_FIXED_NOREPLACE</code> flag will typically (upon detecting a collision with a preexisting
 mapping) fall back to a "non-<code>MAP_FIXED</code>" type of behavior: they will return an address that is different from the requested address.
 Therefore, backward-compatible software should check the returned address against the requested address.</p>
 
 <p>(since Linux 4.17)</p>
 </li>
 <li><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a> - 
 This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory.
 
 <p>The return address is one page lower than the memory area that is actually created in the process's virtual address space. Touching an address in
 the "guard" page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page
 of the high end of the next lower mapping, at which point touching the "guard" page will result in a <code>SIGSEGV</code> signal.</p>
 </li>
 <li><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> - 
 Allocate the mapping using "huge" pages.
 
 <p>See the Linux kernel source file <code>Documentation/admin-guide/mm/hugetlbpage.rst</code> for further information, as well as NOTES, below.</p>
 
 <p>(since Linux 2.6.32)</p>
 </li>
 <li><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a> - 
 Used in conjunction with <a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a> to select alternative <code>hugetlb</code> page sizes (respectively, 2 MB and 1 GB) on systems that support
 multiple <code>hugetlb</code> page sizes.
 
 <p>More generally, the desired huge page size can be configured by encoding the base-2 logarithm of the desired page size in the six bits at the
 offset <a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a>. (A value of zero in this bit field provides the default huge page size; the default huge page size can be discovered via
 the <code>Hugepagesize</code> field exposed by <code>/proc/meminfo</code>.) Thus, the above two constants are defined as:</p>
 
 <pre><code>
 #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
 #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)</code></pre>
 
 <p>The range of huge page sizes that are supported by the system can be discovered by listing the subdirectories in <code>/sys/kernel/mm/hugepages</code>.</p>
 
 <p>(since Linux 3.8)</p>
 </li>
 <li><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a> - See <a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a>.</li>
 <li><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a> -
 </li>
 <li><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a> -
 </li>
 <li><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a> -
 </li>
 <li><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a> -
 </li>
 <li><a href="#MAP_STACK"><code>MAP_STACK</code></a> -
 </li>
 <li><a href="#MAP_SYNC"><code>MAP_SYNC</code></a> -
 </li>
 <li><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a> -
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.system.linux.MMAN.MAP_UNINITIALIZED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="mmap(long,long,int,int,int,long)">
<h3>mmap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">mmap</span><wbr><span class="parameters">(long&nbsp;addr,
 long&nbsp;length,
 int&nbsp;prot,
 int&nbsp;flags,
 int&nbsp;fd,
 long&nbsp;offset)</span></div>
<div class="block">Creates a new mapping in the virtual address space of the calling process.
 
 <p>The starting address for the new mapping is specified in <code>addr</code>. The <code>length</code> argument specifies the length of the mapping (which must be
 greater than 0).</p>
 
 <p>If <code>addr</code> is <code>NULL</code>, then the kernel chooses the (page-aligned) address at which to create the mapping; this is the most portable method of
 creating a new mapping. If <code>addr</code> is not <code>NULL</code>, then the kernel takes it as a hint about where to place the mapping; on Linux, the kernel will
 pick a nearby page boundary (but always above or equal to the value specified by <code>/proc/sys/vm/mmap_min_addr</code>) and attempt to create the mapping
 there. If another mapping already exists there, the kernel picks a new address that may or may not depend on the hint. The address of the new mapping
 is returned as the result of the call.</p>
 
 <p>The contents of a file mapping (as opposed to an anonymous mapping; see <code>MAP_ANONYMOUS</code> below), are initialized using <code>length</code> bytes
 starting at offset <code>offset</code> in the file (or other object) referred to by the file descriptor <code>fd</code>. <code>offset</code> must be a multiple of the
 page size as returned by <code>sysconf(_SC_PAGE_SIZE)</code>.</p>
 
 <p>After the <code>mmap()</code> call has returned, the file descriptor, <code>fd</code>, can be closed immediately without invalidating the mapping.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>prot</code> - describes the desired memory protection of the mapping (and must not conflict with the open mode of the file). One or more of:<br><table><tr><td><a href="#PROT_EXEC"><code>PROT_EXEC</code></a></td><td><a href="#PROT_READ"><code>PROT_READ</code></a></td><td><a href="#PROT_WRITE"><code>PROT_WRITE</code></a></td><td><a href="#PROT_NONE"><code>PROT_NONE</code></a></td><td><a href="#PROT_GROWSDOWN"><code>PROT_GROWSDOWN</code></a></td><td><a href="#PROT_GROWSUP"><code>PROT_GROWSUP</code></a></td></tr></table></dd>
<dd><code>flags</code> - one or more of:<br><table><tr><td><a href="#MAP_FAILED"><code>MAP_FAILED</code></a></td><td><a href="#MAP_SHARED"><code>MAP_SHARED</code></a></td><td><a href="#MAP_SHARED_VALIDATE"><code>MAP_SHARED_VALIDATE</code></a></td><td><a href="#MAP_PRIVATE"><code>MAP_PRIVATE</code></a></td><td><a href="#MAP_HUGE_SHIFT"><code>MAP_HUGE_SHIFT</code></a></td><td><a href="#MAP_HUGE_MASK"><code>MAP_HUGE_MASK</code></a></td></tr><tr><td><a href="#MAP_32BIT"><code>MAP_32BIT</code></a></td><td><a href="#MAP_ANONYMOUS"><code>MAP_ANONYMOUS</code></a></td><td><a href="#MAP_ANON"><code>MAP_ANON</code></a></td><td><a href="#MAP_DENYWRITE"><code>MAP_DENYWRITE</code></a></td><td><a href="#MAP_EXECUTABLE"><code>MAP_EXECUTABLE</code></a></td><td><a href="#MAP_FILE"><code>MAP_FILE</code></a></td></tr><tr><td><a href="#MAP_FIXED"><code>MAP_FIXED</code></a></td><td><a href="#MAP_FIXED_NOREPLACE"><code>MAP_FIXED_NOREPLACE</code></a></td><td><a href="#MAP_GROWSDOWN"><code>MAP_GROWSDOWN</code></a></td><td><a href="#MAP_HUGETLB"><code>MAP_HUGETLB</code></a></td><td><a href="#MAP_HUGE_2MB"><code>MAP_HUGE_2MB</code></a></td><td><a href="#MAP_HUGE_1GB"><code>MAP_HUGE_1GB</code></a></td></tr><tr><td><a href="#MAP_LOCKED"><code>MAP_LOCKED</code></a></td><td><a href="#MAP_NONBLOCK"><code>MAP_NONBLOCK</code></a></td><td><a href="#MAP_NORESERVE"><code>MAP_NORESERVE</code></a></td><td><a href="#MAP_POPULATE"><code>MAP_POPULATE</code></a></td><td><a href="#MAP_STACK"><code>MAP_STACK</code></a></td><td><a href="#MAP_SYNC"><code>MAP_SYNC</code></a></td></tr><tr><td><a href="#MAP_UNINITIALIZED"><code>MAP_UNINITIALIZED</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>on success, returns a pointer to the mapped area. On error, the value <a href="#MAP_FAILED"><code>MAP_FAILED</code></a> is returned, and <code>errno</code> is set to indicate the error.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nmunmap(long,long)">
<h3>nmunmap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nmunmap</span><wbr><span class="parameters">(long&nbsp;addr,
 long&nbsp;length)</span></div>
<div class="block">Unsafe version of: <a href="#munmap(java.nio.ByteBuffer)"><code>munmap(java.nio.ByteBuffer)</code></a></div>
</section>
</li>
<li>
<section class="detail" id="munmap(java.nio.ByteBuffer)">
<h3>munmap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">munmap</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;addr)</span></div>
<div class="block">Deletes the mappings for the specified address range, and causes further references to addresses within the range to generate invalid memory
 references.
 
 <p>The region is also automatically unmapped when the process is terminated. On the other hand, closing the file descriptor does not unmap the region.</p>
 
 <p>The address <code>addr</code> must be a multiple of the page size (but <code>length</code> need not be). All pages containing a part of the indicated range are
 unmapped, and subsequent references to these pages will generate <code>SIGSEGV</code>. It is not an error if the indicated range does not contain any mapped
 pages.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>on success, returns 0. On failure, it returns -1, and <code>errno</code> is set to indicate the error (probably to <code>EINVAL</code>).</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</div>
</div>
</body>
</html>
