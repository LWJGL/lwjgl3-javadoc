<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) -->
<title>LibIOURing (LWJGL 3.3.2-snapshot)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.lwjgl.system.linux.liburing, class: LibIOURing">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li><a href="#field-summary">Field</a></li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.lwjgl.system.linux.liburing</a></div>
<h1 title="Class LibIOURing" class="title">Class LibIOURing</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.lwjgl.system.linux.liburing.LibIOURing</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">LibIOURing</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Native bindings to <a target="_blank" href="https://github.com/axboe/liburing">io_uring</a>, a Linux-specific API for asynchronous I/O.
 
 <p>It allows the user to submit one or more I/O requests, which are processed asynchronously without blocking the calling process. <code>io_uring</code> gets
 its name from ring buffers which are shared between user space and kernel space. This arrangement allows for efficient I/O, while avoiding the overhead
 of copying buffers between them, where possible. This interface makes <code>io_uring</code> different from other UNIX I/O APIs, wherein, rather than just
 communicate between kernel and user space with system calls, ring buffers are used as the main mode of communication. This arrangement has various
 performance benefits which are discussed in a separate section below. This man page uses the terms shared buffers, shared ring buffers and queues
 interchangeably.</p>
 
 <p>The general programming model you need to follow for io_uring is outlined below</p>
 
 <ul>
 <li>Set up shared buffers with <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a> and <code>mmap(2)</code>, mapping into user space shared buffers for the submission queue (SQ) and the completion
 queue (CQ). You place I/O requests you want to make on the SQ, while the kernel places the results of those operations on the CQ.</li>
 <li>For every I/O request you need to make (like to read a file, write a file, accept a socket connection, etc), you create a submission queue entry,
 or SQE, describe the I/O operation you need to get done and add it to the tail of the submission queue (SQ). Each I/O operation is, in essence, the
 equivalent of a system call you would have made otherwise, if you were not using <code>io_uring</code>. You can add more than one SQE to the queue
 depending on the number of operations you want to request.</li>
 <li>After you add one or more SQEs, you need to call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to tell the kernel to dequeue your I/O requests off the SQ and begin processing them.</li>
 <li>For each SQE you submit, once it is done processing the request, the kernel places a completion queue event or CQE at the tail of the completion
 queue or CQ. The kernel places exactly one matching CQE in the CQ for every SQE you submit on the SQ. After you retrieve a CQE, minimally, you
 might be interested in checking the res field of the CQE structure, which corresponds to the return value of the system call's equivalent, had you
 used it directly without using <code>io_uring</code>. For instance, a read operation under <code>io_uring</code>, started with the <a href="#IORING_OP_READ"><code>OP_READ</code></a> operation, which
 issues the equivalent of the <code>read(2)</code> system call, would return as part of <code>res</code> what <code>read(2)</code> would have returned if called
 directly, without using <code>io_uring</code>.</li>
 <li>Optionally, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> can also wait for a specified number of requests to be processed by the kernel before it returns. If you specified a certain
 number of completions to wait for, the kernel would have placed at least those many number of CQEs on the CQ, which you can then readily read,
 right after the return from <code>io_uring_enter(2)</code>.</li>
 <li>It is important to remember that I/O requests submitted to the kernel can complete in any order. It is not necessary for the kernel to process one
 request after another, in the order you placed them. Given that the interface is a ring, the requests are attempted in order, however that doesn't
 imply any sort of ordering on their completion. When more than one request is in flight, it is not possible to determine which one will complete
 first. When you dequeue CQEs off the CQ, you should always check which submitted request it corresponds to. The most common method for doing so is
 utilizing the <code>user_data</code> field in the request, which is passed back on the completion side.</li>
 </ul>
 
 <p>Adding to and reading from the queues:</p>
 
 <ul>
 <li>You add SQEs to the tail of the SQ. The kernel reads SQEs off the head of the queue.</li>
 <li>The kernel adds CQEs to the tail of the CQ. You read CQEs off the head of the queue.</li>
 </ul>
 
 <h3>Submission queue polling</h3>
 
 <p>One of the goals of <code>io_uring</code> is to provide a means for efficient I/O. To this end, <code>io_uring</code> supports a polling mode that lets you avoid
 the call to <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>, which you use to inform the kernel that you have queued SQEs on to the SQ. With SQ Polling, <code>io_uring</code> starts a kernel
 thread that polls the submission queue for any I/O requests you submit by adding SQEs. With SQ Polling enabled, there is no need for you to call
 <code>io_uring_enter(2)</code>, letting you avoid the overhead of system calls. A designated kernel thread dequeues SQEs off the SQ as you add them and
 dispatches them for asynchronous processing.</p>
 
 <h3>Setting up io_uring</h3>
 
 <p>The main steps in setting up <code>io_uring</code> consist of mapping in the shared buffers with <code>mmap(2)</code> calls.</p>
 
 <h3>Submitting I/O requests</h3>
 
 <p>The process of submitting a request consists of describing the I/O operation you need to get done using an <code>io_uring_sqe</code> structure instance.
 These details describe the equivalent system call and its parameters. Because the range of I/O operations Linux supports are very varied and the
 <code>io_uring_sqe</code> structure needs to be able to describe them, it has several fields, some packed into unions for space efficiency.</p>
 
 <p>To submit an I/O request to <code>io_uring</code>, you need to acquire a submission queue entry (SQE) from the submission queue (SQ), fill it up with
 details of the operation you want to submit and call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. If you want to avoid calling <code>io_uring_enter(2)</code>, you have the option of setting
 up Submission Queue Polling.</p>
 
 <p>SQEs are added to the tail of the submission queue. The kernel picks up SQEs off the head of the SQ. The general algorithm to get the next available
 SQE and update the tail is as follows.</p>
 
 <pre><code>
 struct io_uring_sqe *sqe;
 unsigned tail, index;
 tail = *sqring-&gt;tail;
 index = tail &amp; (*sqring-&gt;ring_mask);
 sqe = &amp;sqring-&gt;sqes[index];
 // fill up details about this I/O request
 describe_io(sqe);
 // fill the sqe index into the SQ ring array
 sqring-&gt;array[index] = index;
 tail++;
 atomic_store_release(sqring-&gt;tail, tail);</code></pre>
 
 <p>To get the index of an entry, the application must mask the current tail index with the size mask of the ring. This holds true for both SQs and CQs.
 Once the SQE is acquired, the necessary fields are filled in, describing the request. While the CQ ring directly indexes the shared array of CQEs, the
 submission side has an indirection array between them. The submission side ring buffer is an index into this array, which in turn contains the index
 into the SQEs.</p>
 
 <p>The following code snippet demonstrates how a read operation, an equivalent of a preadv2(2) system call is described by filling up an SQE with the
 necessary parameters.</p>
 
 <pre><code>
 struct iovec iovecs[16];
  ...
 sqe-&gt;opcode = IORING_OP_READV;
 sqe-&gt;fd = fd;
 sqe-&gt;addr = (unsigned long) iovecs;
 sqe-&gt;len = 16;
 sqe-&gt;off = offset;
 sqe-&gt;flags = 0;</code></pre>
 
 <h4>Memory ordering</h4>
 
 <p>Modern compilers and CPUs freely reorder reads and writes without affecting the program's outcome to optimize performance. Some aspects of this need to
 be kept in mind on SMP systems since <code>io_uring</code> involves buffers shared between kernel and user space. These buffers are both visible and
 modifiable from kernel and user space. As heads and tails belonging to these shared buffers are updated by kernel and user space, changes need to be
 coherently visible on either side, irrespective of whether a CPU switch took place after the kernel-user mode switch happened. We use memory barriers
 to enforce this coherency. Being significantly large subjects on their own, memory barriers are out of scope for further discussion on this man page.</p>
 
 <h4>Letting the kernel know about I/O submissions</h4>
 
 <p>Once you place one or more SQEs on to the SQ, you need to let the kernel know that you've done so. You can do this by calling the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call.
 This system call is also capable of waiting for a specified count of events to complete. This way, you can be sure to find completion events in the
 completion queue without having to poll it for events later.</p>
 
 <h3>Reading completion events</h3>
 
 <p>Similar to the submission queue (SQ), the completion queue (CQ) is a shared buffer between the kernel and user space. Whereas you placed submission
 queue entries on the tail of the SQ and the kernel read off the head, when it comes to the CQ, the kernel places completion queue events or CQEs on the
 tail of the CQ and you read off its head.</p>
 
 <p>Submission is flexible (and thus a bit more complicated) since it needs to be able to encode different types of system calls that take various
 parameters. Completion, on the other hand is simpler since we're looking only for a return value back from the kernel. This is easily understood by
 looking at the completion queue event structure, <a href="IOURingCQE.html" title="class in org.lwjgl.system.linux.liburing"><code>IOURingCQE</code></a>.</p>
 
 <p>Here, <code>user_data</code> is custom data that is passed unchanged from submission to completion. That is, from SQEs to CQEs. This field can be used to
 set context, uniquely identifying submissions that got completed. Given that I/O requests can complete in any order, this field can be used to
 correlate a submission with a completion. <code>res</code> is the result from the system call that was performed as part of the submission; its return
 value. The <code>flags</code> field could carry request-specific metadata in the future, but is currently unused.</p>
 
 <p>The general sequence to read completion events off the completion queue is as follows:</p>
 
 <pre><code>
 unsigned head;
 head = *cqring-&gt;head;
 if (head != atomic_load_acquire(cqring-&gt;tail)) {
     struct io_uring_cqe *cqe;
 
     unsigned index;
 
     index = head &amp; (cqring-&gt;mask);
 
     cqe = &amp;cqring-&gt;cqes[index];
 
     // process completed CQE
 
     process_cqe(cqe);
 
     // CQE consumption complete
 
     head++;
 }
 atomic_store_release(cqring-&gt;head, head);</code></pre>
 
 <p>It helps to be reminded that the kernel adds CQEs to the tail of the CQ, while you need to dequeue them off the head. To get the index of an entry at
 the head, the application must mask the current head index with the size mask of the ring. Once the CQE has been consumed or processed, the head needs
 to be updated to reflect the consumption of the CQE. Attention should be paid to the read and write barriers to ensure successful read and update of
 the head.</p>
 
 <h3>io_uring performance</h3>
 
 <p>Because of the shared ring buffers between kernel and user space, <code>io_uring</code> can be a zero-copy system. Copying buffers to and from becomes
 necessary when system calls that transfer data between kernel and user space are involved. But since the bulk of the communication in <code>io_uring</code>
 is via buffers shared between the kernel and user space, this huge performance overhead is completely avoided.</p>
 
 <p>While system calls may not seem like a significant overhead, in high performance applications, making a lot of them will begin to matter. While
 workarounds the operating system has in place to deal with Spectre and Meltdown are ideally best done away with, unfortunately, some of these
 workarounds are around the system call interface, making system calls not as cheap as before on affected hardware. While newer hardware should not need
 these workarounds, hardware with these vulnerabilities can be expected to be in the wild for a long time. While using synchronous programming
 interfaces or even when using asynchronous programming interfaces under Linux, there is at least one system call involved in the submission of each
 request. In <code>io_uring</code>, on the other hand, you can batch several requests in one go, simply by queueing up multiple SQEs, each describing an I/O
 operation you want and make a single call to <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. This is possible due to <code>io_uring</code>'s shared buffers based design.</p>
 
 <p>While this batching in itself can avoid the overhead associated with potentially multiple and frequent system calls, you can reduce even this overhead
 further with Submission Queue Polling, by having the kernel poll and pick up your SQEs for processing as you add them to the submission queue. This
 avoids the <code>io_uring_enter(2)</code> call you need to make to tell the kernel to pick SQEs up. For high-performance applications, this means even
 lesser system call overheads.</p></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IO_URING_OP_SUPPORTED" class="member-name-link">IO_URING_OP_SUPPORTED</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IO_WQ_BOUND" class="member-name-link">IO_WQ_BOUND</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io-wq</code> worker categories</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IO_WQ_UNBOUND" class="member-name-link">IO_WQ_UNBOUND</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io-wq</code> worker categories</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_ACCEPT_MULTISHOT" class="member-name-link">IORING_ACCEPT_MULTISHOT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Accept flags stored in <code>sqe-&gt;ioprio</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_ASYNC_CANCEL_ALL" class="member-name-link">IORING_ASYNC_CANCEL_ALL</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>ASYNC_CANCEL</code> flags.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_ASYNC_CANCEL_ANY" class="member-name-link">IORING_ASYNC_CANCEL_ANY</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>ASYNC_CANCEL</code> flags.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_ASYNC_CANCEL_FD" class="member-name-link">IORING_ASYNC_CANCEL_FD</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>ASYNC_CANCEL</code> flags.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_ASYNC_CANCEL_FD_FIXED" class="member-name-link">IORING_ASYNC_CANCEL_FD_FIXED</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>ASYNC_CANCEL</code> flags.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_CQ_EVENTFD_DISABLED" class="member-name-link">IORING_CQ_EVENTFD_DISABLED</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>cq_ring-&gt;flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_CQE_BUFFER_SHIFT" class="member-name-link">IORING_CQE_BUFFER_SHIFT</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_CQE_F_BUFFER" class="member-name-link">IORING_CQE_F_BUFFER</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>cqe-&gt;flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_CQE_F_MORE" class="member-name-link">IORING_CQE_F_MORE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>cqe-&gt;flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_CQE_F_NOTIF" class="member-name-link">IORING_CQE_F_NOTIF</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>cqe-&gt;flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_CQE_F_SOCK_NONEMPTY" class="member-name-link">IORING_CQE_F_SOCK_NONEMPTY</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>cqe-&gt;flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_ENTER_EXT_ARG" class="member-name-link">IORING_ENTER_EXT_ARG</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_enter(2)</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_ENTER_GETEVENTS" class="member-name-link">IORING_ENTER_GETEVENTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_enter(2)</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_ENTER_REGISTERED_RING" class="member-name-link">IORING_ENTER_REGISTERED_RING</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_enter(2)</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_ENTER_SQ_WAIT" class="member-name-link">IORING_ENTER_SQ_WAIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_enter(2)</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_ENTER_SQ_WAKEUP" class="member-name-link">IORING_ENTER_SQ_WAKEUP</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_enter(2)</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FEAT_CQE_SKIP" class="member-name-link">IORING_FEAT_CQE_SKIP</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_FEAT_CUR_PERSONALITY" class="member-name-link">IORING_FEAT_CUR_PERSONALITY</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FEAT_EXT_ARG" class="member-name-link">IORING_FEAT_EXT_ARG</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_FEAT_FAST_POLL" class="member-name-link">IORING_FEAT_FAST_POLL</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FEAT_LINKED_FILE" class="member-name-link">IORING_FEAT_LINKED_FILE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_FEAT_NATIVE_WORKERS" class="member-name-link">IORING_FEAT_NATIVE_WORKERS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FEAT_NODROP" class="member-name-link">IORING_FEAT_NODROP</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_FEAT_POLL_32BITS" class="member-name-link">IORING_FEAT_POLL_32BITS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FEAT_RSRC_TAGS" class="member-name-link">IORING_FEAT_RSRC_TAGS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_FEAT_RW_CUR_POS" class="member-name-link">IORING_FEAT_RW_CUR_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FEAT_SINGLE_MMAP" class="member-name-link">IORING_FEAT_SINGLE_MMAP</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_FEAT_SQPOLL_NONFIXED" class="member-name-link">IORING_FEAT_SQPOLL_NONFIXED</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FEAT_SUBMIT_STABLE" class="member-name-link">IORING_FEAT_SUBMIT_STABLE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_params-&gt;features</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_FILE_INDEX_ALLOC" class="member-name-link">IORING_FILE_INDEX_ALLOC</a></code></div>
<div class="col-last even-row-color">
<div class="block">If <code>sqe-&gt;file_index</code> is set to this for opcodes that instantiate a new direct descriptor (like <code>openat/openat2/accept</code>), then io_uring will
 allocate an available direct descriptor instead of having the application pass one in.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_FSYNC_DATASYNC" class="member-name-link">IORING_FSYNC_DATASYNC</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>sqe-&gt;fsync_flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_LINK_TIMEOUT_UPDATE" class="member-name-link">IORING_LINK_TIMEOUT_UPDATE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_MAX_ENTRIES" class="member-name-link">IORING_MAX_ENTRIES</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_MSG_DATA" class="member-name-link">IORING_MSG_DATA</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> command types, stored in <code>sqe-&gt;addr</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_MSG_RING_CQE_SKIP" class="member-name-link">IORING_MSG_RING_CQE_SKIP</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> flags (<code>sqe-&gt;msg_ring_flags</code>)</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_MSG_SEND_FD" class="member-name-link">IORING_MSG_SEND_FD</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> command types, stored in <code>sqe-&gt;addr</code></div>
</div>
<div class="col-first odd-row-color"><code>static final long</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OFF_CQ_RING" class="member-name-link">IORING_OFF_CQ_RING</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Magic offsets for the application to <code>mmap</code> the data it needs</div>
</div>
<div class="col-first even-row-color"><code>static final long</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OFF_SQ_RING" class="member-name-link">IORING_OFF_SQ_RING</a></code></div>
<div class="col-last even-row-color">
<div class="block">Magic offsets for the application to <code>mmap</code> the data it needs</div>
</div>
<div class="col-first odd-row-color"><code>static final long</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OFF_SQES" class="member-name-link">IORING_OFF_SQES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Magic offsets for the application to <code>mmap</code> the data it needs</div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_ACCEPT" class="member-name-link">IORING_OP_ACCEPT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_ASYNC_CANCEL" class="member-name-link">IORING_OP_ASYNC_CANCEL</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_CLOSE" class="member-name-link">IORING_OP_CLOSE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_CONNECT" class="member-name-link">IORING_OP_CONNECT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_EPOLL_CTL" class="member-name-link">IORING_OP_EPOLL_CTL</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_FADVISE" class="member-name-link">IORING_OP_FADVISE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_FALLOCATE" class="member-name-link">IORING_OP_FALLOCATE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_FGETXATTR" class="member-name-link">IORING_OP_FGETXATTR</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_FILES_UPDATE" class="member-name-link">IORING_OP_FILES_UPDATE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_FSETXATTR" class="member-name-link">IORING_OP_FSETXATTR</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_FSYNC" class="member-name-link">IORING_OP_FSYNC</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_GETXATTR" class="member-name-link">IORING_OP_GETXATTR</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_LAST" class="member-name-link">IORING_OP_LAST</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_LINK_TIMEOUT" class="member-name-link">IORING_OP_LINK_TIMEOUT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_LINKAT" class="member-name-link">IORING_OP_LINKAT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_MADVISE" class="member-name-link">IORING_OP_MADVISE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_MKDIRAT" class="member-name-link">IORING_OP_MKDIRAT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_MSG_RING" class="member-name-link">IORING_OP_MSG_RING</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_NOP" class="member-name-link">IORING_OP_NOP</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_OPENAT" class="member-name-link">IORING_OP_OPENAT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_OPENAT2" class="member-name-link">IORING_OP_OPENAT2</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_POLL_ADD" class="member-name-link">IORING_OP_POLL_ADD</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_POLL_REMOVE" class="member-name-link">IORING_OP_POLL_REMOVE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_PROVIDE_BUFFERS" class="member-name-link">IORING_OP_PROVIDE_BUFFERS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_READ" class="member-name-link">IORING_OP_READ</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_READ_FIXED" class="member-name-link">IORING_OP_READ_FIXED</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_READV" class="member-name-link">IORING_OP_READV</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_RECV" class="member-name-link">IORING_OP_RECV</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_RECVMSG" class="member-name-link">IORING_OP_RECVMSG</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_REMOVE_BUFFERS" class="member-name-link">IORING_OP_REMOVE_BUFFERS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_RENAMEAT" class="member-name-link">IORING_OP_RENAMEAT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_SEND" class="member-name-link">IORING_OP_SEND</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_SEND_ZC" class="member-name-link">IORING_OP_SEND_ZC</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_SENDMSG" class="member-name-link">IORING_OP_SENDMSG</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_SETXATTR" class="member-name-link">IORING_OP_SETXATTR</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_SHUTDOWN" class="member-name-link">IORING_OP_SHUTDOWN</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_SOCKET" class="member-name-link">IORING_OP_SOCKET</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_SPLICE" class="member-name-link">IORING_OP_SPLICE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_STATX" class="member-name-link">IORING_OP_STATX</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_SYMLINKAT" class="member-name-link">IORING_OP_SYMLINKAT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_SYNC_FILE_RANGE" class="member-name-link">IORING_OP_SYNC_FILE_RANGE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_TEE" class="member-name-link">IORING_OP_TEE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_TIMEOUT" class="member-name-link">IORING_OP_TIMEOUT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_TIMEOUT_REMOVE" class="member-name-link">IORING_OP_TIMEOUT_REMOVE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_UNLINKAT" class="member-name-link">IORING_OP_UNLINKAT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_URING_CMD" class="member-name-link">IORING_OP_URING_CMD</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_WRITE" class="member-name-link">IORING_OP_WRITE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final byte</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_OP_WRITE_FIXED" class="member-name-link">IORING_OP_WRITE_FIXED</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first even-row-color"><code>static final byte</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_OP_WRITEV" class="member-name-link">IORING_OP_WRITEV</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_op</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_POLL_ADD_LEVEL" class="member-name-link">IORING_POLL_ADD_LEVEL</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>POLL_ADD</code> flags.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_POLL_ADD_MULTI" class="member-name-link">IORING_POLL_ADD_MULTI</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>POLL_ADD</code> flags.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_POLL_UPDATE_EVENTS" class="member-name-link">IORING_POLL_UPDATE_EVENTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>POLL_ADD</code> flags.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_POLL_UPDATE_USER_DATA" class="member-name-link">IORING_POLL_UPDATE_USER_DATA</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>POLL_ADD</code> flags.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_RECV_MULTISHOT" class="member-name-link">IORING_RECV_MULTISHOT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>send/sendmsg</code> and <code>recv/recvmsg</code> flags (<code>sqe-&gt;ioprio</code>)</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_RECVSEND_FIXED_BUF" class="member-name-link">IORING_RECVSEND_FIXED_BUF</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>send/sendmsg</code> and <code>recv/recvmsg</code> flags (<code>sqe-&gt;ioprio</code>)</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_RECVSEND_POLL_FIRST" class="member-name-link">IORING_RECVSEND_POLL_FIRST</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>send/sendmsg</code> and <code>recv/recvmsg</code> flags (<code>sqe-&gt;ioprio</code>)</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_BUFFERS" class="member-name-link">IORING_REGISTER_BUFFERS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_BUFFERS_UPDATE" class="member-name-link">IORING_REGISTER_BUFFERS_UPDATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_BUFFERS2" class="member-name-link">IORING_REGISTER_BUFFERS2</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_ENABLE_RINGS" class="member-name-link">IORING_REGISTER_ENABLE_RINGS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_EVENTFD" class="member-name-link">IORING_REGISTER_EVENTFD</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_EVENTFD_ASYNC" class="member-name-link">IORING_REGISTER_EVENTFD_ASYNC</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_FILE_ALLOC_RANGE" class="member-name-link">IORING_REGISTER_FILE_ALLOC_RANGE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_FILES" class="member-name-link">IORING_REGISTER_FILES</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_FILES_SKIP" class="member-name-link">IORING_REGISTER_FILES_SKIP</a></code></div>
<div class="col-last even-row-color">
<div class="block">Skip updating fd indexes set to this value in the fd table.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_FILES_UPDATE" class="member-name-link">IORING_REGISTER_FILES_UPDATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_FILES_UPDATE2" class="member-name-link">IORING_REGISTER_FILES_UPDATE2</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_FILES2" class="member-name-link">IORING_REGISTER_FILES2</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_IOWQ_AFF" class="member-name-link">IORING_REGISTER_IOWQ_AFF</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS" class="member-name-link">IORING_REGISTER_IOWQ_MAX_WORKERS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_LAST" class="member-name-link">IORING_REGISTER_LAST</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_PBUF_RING" class="member-name-link">IORING_REGISTER_PBUF_RING</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_PERSONALITY" class="member-name-link">IORING_REGISTER_PERSONALITY</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_PROBE" class="member-name-link">IORING_REGISTER_PROBE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_RESTRICTIONS" class="member-name-link">IORING_REGISTER_RESTRICTIONS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_REGISTER_RING_FDS" class="member-name-link">IORING_REGISTER_RING_FDS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_REGISTER_SYNC_CANCEL" class="member-name-link">IORING_REGISTER_SYNC_CANCEL</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_RESTRICTION_LAST" class="member-name-link">IORING_RESTRICTION_LAST</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_RESTRICTION_REGISTER_OP" class="member-name-link">IORING_RESTRICTION_REGISTER_OP</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_RESTRICTION_SQE_FLAGS_ALLOWED" class="member-name-link">IORING_RESTRICTION_SQE_FLAGS_ALLOWED</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_RESTRICTION_SQE_FLAGS_REQUIRED" class="member-name-link">IORING_RESTRICTION_SQE_FLAGS_REQUIRED</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_RESTRICTION_SQE_OP" class="member-name-link">IORING_RESTRICTION_SQE_OP</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_RSRC_REGISTER_SPARSE" class="member-name-link">IORING_RSRC_REGISTER_SPARSE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Register a fully sparse file space, rather than pass in an array of all -1 file descriptors.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SETUP_ATTACH_WQ" class="member-name-link">IORING_SETUP_ATTACH_WQ</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SETUP_CLAMP" class="member-name-link">IORING_SETUP_CLAMP</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SETUP_COOP_TASKRUN" class="member-name-link">IORING_SETUP_COOP_TASKRUN</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SETUP_CQE32" class="member-name-link">IORING_SETUP_CQE32</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SETUP_CQSIZE" class="member-name-link">IORING_SETUP_CQSIZE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SETUP_DEFER_TASKRUN" class="member-name-link">IORING_SETUP_DEFER_TASKRUN</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SETUP_IOPOLL" class="member-name-link">IORING_SETUP_IOPOLL</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SETUP_R_DISABLED" class="member-name-link">IORING_SETUP_R_DISABLED</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SETUP_SINGLE_ISSUER" class="member-name-link">IORING_SETUP_SINGLE_ISSUER</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SETUP_SQ_AFF" class="member-name-link">IORING_SETUP_SQ_AFF</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SETUP_SQE128" class="member-name-link">IORING_SETUP_SQE128</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SETUP_SQPOLL" class="member-name-link">IORING_SETUP_SQPOLL</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SETUP_SUBMIT_ALL" class="member-name-link">IORING_SETUP_SUBMIT_ALL</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SETUP_TASKRUN_FLAG" class="member-name-link">IORING_SETUP_TASKRUN_FLAG</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_setup()</code> flags</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SPLICE_F_FD_IN_FIXED" class="member-name-link">IORING_SPLICE_F_FD_IN_FIXED</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>sqe-&gt;splice_flags</code>, extends <code>splice(2)</code> flags</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SQ_CQ_OVERFLOW" class="member-name-link">IORING_SQ_CQ_OVERFLOW</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>sq_ring-&gt;flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_SQ_NEED_WAKEUP" class="member-name-link">IORING_SQ_NEED_WAKEUP</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>sq_ring-&gt;flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_SQ_TASKRUN" class="member-name-link">IORING_SQ_TASKRUN</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>sq_ring-&gt;flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_TIMEOUT_ABS" class="member-name-link">IORING_TIMEOUT_ABS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_TIMEOUT_BOOTTIME" class="member-name-link">IORING_TIMEOUT_BOOTTIME</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_TIMEOUT_CLOCK_MASK" class="member-name-link">IORING_TIMEOUT_CLOCK_MASK</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_TIMEOUT_ETIME_SUCCESS" class="member-name-link">IORING_TIMEOUT_ETIME_SUCCESS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_TIMEOUT_REALTIME" class="member-name-link">IORING_TIMEOUT_REALTIME</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_TIMEOUT_UPDATE" class="member-name-link">IORING_TIMEOUT_UPDATE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_TIMEOUT_UPDATE_MASK" class="member-name-link">IORING_TIMEOUT_UPDATE_MASK</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>sqe-&gt;timeout_flags</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_UNREGISTER_BUFFERS" class="member-name-link">IORING_UNREGISTER_BUFFERS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_UNREGISTER_EVENTFD" class="member-name-link">IORING_UNREGISTER_EVENTFD</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_UNREGISTER_FILES" class="member-name-link">IORING_UNREGISTER_FILES</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_UNREGISTER_IOWQ_AFF" class="member-name-link">IORING_UNREGISTER_IOWQ_AFF</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_UNREGISTER_PBUF_RING" class="member-name-link">IORING_UNREGISTER_PBUF_RING</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IORING_UNREGISTER_PERSONALITY" class="member-name-link">IORING_UNREGISTER_PERSONALITY</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IORING_UNREGISTER_RING_FDS" class="member-name-link">IORING_UNREGISTER_RING_FDS</a></code></div>
<div class="col-last even-row-color">
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IOSQE_ASYNC" class="member-name-link">IOSQE_ASYNC</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IOSQE_ASYNC_BIT" class="member-name-link">IOSQE_ASYNC_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IOSQE_BUFFER_SELECT" class="member-name-link">IOSQE_BUFFER_SELECT</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IOSQE_BUFFER_SELECT_BIT" class="member-name-link">IOSQE_BUFFER_SELECT_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IOSQE_CQE_SKIP_SUCCESS" class="member-name-link">IOSQE_CQE_SKIP_SUCCESS</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT" class="member-name-link">IOSQE_CQE_SKIP_SUCCESS_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IOSQE_FIXED_FILE" class="member-name-link">IOSQE_FIXED_FILE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IOSQE_FIXED_FILE_BIT" class="member-name-link">IOSQE_FIXED_FILE_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IOSQE_IO_DRAIN" class="member-name-link">IOSQE_IO_DRAIN</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IOSQE_IO_DRAIN_BIT" class="member-name-link">IOSQE_IO_DRAIN_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IOSQE_IO_HARDLINK" class="member-name-link">IOSQE_IO_HARDLINK</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IOSQE_IO_HARDLINK_BIT" class="member-name-link">IOSQE_IO_HARDLINK_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#IOSQE_IO_LINK" class="member-name-link">IOSQE_IO_LINK</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#IOSQE_IO_LINK_BIT" class="member-name-link">IOSQE_IO_LINK_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#io_uring_enter(int,int,int,int,long)" class="member-name-link">io_uring_enter</a><wbr>(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block"><code>io_uring_enter()</code> is used to initiate and complete I/O using the shared submission and completion queues setup by a call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#io_uring_enter2(int,int,int,int,long,int)" class="member-name-link">io_uring_enter2</a><wbr>(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig,
 int&nbsp;sz)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#io_uring_register(int,int,long,int)" class="member-name-link">io_uring_register</a><wbr>(int&nbsp;fd,
 int&nbsp;opcode,
 long&nbsp;arg,
 int&nbsp;nr_args)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">The <code>io_uring_register()</code> system call registers resources (e.g.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)" class="member-name-link">io_uring_setup</a><wbr>(int&nbsp;entries,
 <a href="IOURingParams.html" title="class in org.lwjgl.system.linux.liburing">IOURingParams</a>&nbsp;p)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">The <code>io_uring_setup()</code> system call sets up a submission queue (SQ) and completion queue (CQ) with at least <code>entries</code> entries, and returns a
 file descriptor which can be used to perform subsequent operations on the <code>io_uring</code> instance.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nio_uring_enter(int,int,int,int,long)" class="member-name-link">nio_uring_enter</a><wbr>(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nio_uring_enter2(int,int,int,int,long,int)" class="member-name-link">nio_uring_enter2</a><wbr>(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig,
 int&nbsp;sz)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nio_uring_register(int,int,long,int)" class="member-name-link">nio_uring_register</a><wbr>(int&nbsp;fd,
 int&nbsp;opcode,
 long&nbsp;arg,
 int&nbsp;nr_args)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#io_uring_register(int,int,long,int)"><code>register</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nio_uring_setup(int,long)" class="member-name-link">nio_uring_setup</a><wbr>(int&nbsp;entries,
 long&nbsp;p)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a></div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="IORING_FILE_INDEX_ALLOC">
<h3>IORING_FILE_INDEX_ALLOC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FILE_INDEX_ALLOC</span></div>
<div class="block">If <code>sqe-&gt;file_index</code> is set to this for opcodes that instantiate a new direct descriptor (like <code>openat/openat2/accept</code>), then io_uring will
 allocate an available direct descriptor instead of having the application pass one in.
 
 <p>The picked direct descriptor will be returned in <code>cqe-&gt;res</code>, or <code>-ENFILE</code> if the space is full.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FILE_INDEX_ALLOC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_MAX_ENTRIES">
<h3>IORING_MAX_ENTRIES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_MAX_ENTRIES</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_MAX_ENTRIES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_FIXED_FILE_BIT">
<h3>IOSQE_FIXED_FILE_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_FIXED_FILE_BIT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE_BIT"><code>IOSQE_FIXED_FILE_BIT</code></a></li>
 <li><a href="#IOSQE_IO_DRAIN_BIT"><code>IOSQE_IO_DRAIN_BIT</code></a></li>
 <li><a href="#IOSQE_IO_LINK_BIT"><code>IOSQE_IO_LINK_BIT</code></a></li>
 <li><a href="#IOSQE_IO_HARDLINK_BIT"><code>IOSQE_IO_HARDLINK_BIT</code></a></li>
 <li><a href="#IOSQE_ASYNC_BIT"><code>IOSQE_ASYNC_BIT</code></a></li>
 <li><a href="#IOSQE_BUFFER_SELECT_BIT"><code>IOSQE_BUFFER_SELECT_BIT</code></a></li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT"><code>IOSQE_CQE_SKIP_SUCCESS_BIT</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_FIXED_FILE_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_IO_DRAIN_BIT">
<h3>IOSQE_IO_DRAIN_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_IO_DRAIN_BIT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE_BIT"><code>IOSQE_FIXED_FILE_BIT</code></a></li>
 <li><a href="#IOSQE_IO_DRAIN_BIT"><code>IOSQE_IO_DRAIN_BIT</code></a></li>
 <li><a href="#IOSQE_IO_LINK_BIT"><code>IOSQE_IO_LINK_BIT</code></a></li>
 <li><a href="#IOSQE_IO_HARDLINK_BIT"><code>IOSQE_IO_HARDLINK_BIT</code></a></li>
 <li><a href="#IOSQE_ASYNC_BIT"><code>IOSQE_ASYNC_BIT</code></a></li>
 <li><a href="#IOSQE_BUFFER_SELECT_BIT"><code>IOSQE_BUFFER_SELECT_BIT</code></a></li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT"><code>IOSQE_CQE_SKIP_SUCCESS_BIT</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_IO_DRAIN_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_IO_LINK_BIT">
<h3>IOSQE_IO_LINK_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_IO_LINK_BIT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE_BIT"><code>IOSQE_FIXED_FILE_BIT</code></a></li>
 <li><a href="#IOSQE_IO_DRAIN_BIT"><code>IOSQE_IO_DRAIN_BIT</code></a></li>
 <li><a href="#IOSQE_IO_LINK_BIT"><code>IOSQE_IO_LINK_BIT</code></a></li>
 <li><a href="#IOSQE_IO_HARDLINK_BIT"><code>IOSQE_IO_HARDLINK_BIT</code></a></li>
 <li><a href="#IOSQE_ASYNC_BIT"><code>IOSQE_ASYNC_BIT</code></a></li>
 <li><a href="#IOSQE_BUFFER_SELECT_BIT"><code>IOSQE_BUFFER_SELECT_BIT</code></a></li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT"><code>IOSQE_CQE_SKIP_SUCCESS_BIT</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_IO_LINK_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_IO_HARDLINK_BIT">
<h3>IOSQE_IO_HARDLINK_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_IO_HARDLINK_BIT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE_BIT"><code>IOSQE_FIXED_FILE_BIT</code></a></li>
 <li><a href="#IOSQE_IO_DRAIN_BIT"><code>IOSQE_IO_DRAIN_BIT</code></a></li>
 <li><a href="#IOSQE_IO_LINK_BIT"><code>IOSQE_IO_LINK_BIT</code></a></li>
 <li><a href="#IOSQE_IO_HARDLINK_BIT"><code>IOSQE_IO_HARDLINK_BIT</code></a></li>
 <li><a href="#IOSQE_ASYNC_BIT"><code>IOSQE_ASYNC_BIT</code></a></li>
 <li><a href="#IOSQE_BUFFER_SELECT_BIT"><code>IOSQE_BUFFER_SELECT_BIT</code></a></li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT"><code>IOSQE_CQE_SKIP_SUCCESS_BIT</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_IO_HARDLINK_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_ASYNC_BIT">
<h3>IOSQE_ASYNC_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_ASYNC_BIT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE_BIT"><code>IOSQE_FIXED_FILE_BIT</code></a></li>
 <li><a href="#IOSQE_IO_DRAIN_BIT"><code>IOSQE_IO_DRAIN_BIT</code></a></li>
 <li><a href="#IOSQE_IO_LINK_BIT"><code>IOSQE_IO_LINK_BIT</code></a></li>
 <li><a href="#IOSQE_IO_HARDLINK_BIT"><code>IOSQE_IO_HARDLINK_BIT</code></a></li>
 <li><a href="#IOSQE_ASYNC_BIT"><code>IOSQE_ASYNC_BIT</code></a></li>
 <li><a href="#IOSQE_BUFFER_SELECT_BIT"><code>IOSQE_BUFFER_SELECT_BIT</code></a></li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT"><code>IOSQE_CQE_SKIP_SUCCESS_BIT</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_ASYNC_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_BUFFER_SELECT_BIT">
<h3>IOSQE_BUFFER_SELECT_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_BUFFER_SELECT_BIT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE_BIT"><code>IOSQE_FIXED_FILE_BIT</code></a></li>
 <li><a href="#IOSQE_IO_DRAIN_BIT"><code>IOSQE_IO_DRAIN_BIT</code></a></li>
 <li><a href="#IOSQE_IO_LINK_BIT"><code>IOSQE_IO_LINK_BIT</code></a></li>
 <li><a href="#IOSQE_IO_HARDLINK_BIT"><code>IOSQE_IO_HARDLINK_BIT</code></a></li>
 <li><a href="#IOSQE_ASYNC_BIT"><code>IOSQE_ASYNC_BIT</code></a></li>
 <li><a href="#IOSQE_BUFFER_SELECT_BIT"><code>IOSQE_BUFFER_SELECT_BIT</code></a></li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT"><code>IOSQE_CQE_SKIP_SUCCESS_BIT</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_BUFFER_SELECT_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_CQE_SKIP_SUCCESS_BIT">
<h3>IOSQE_CQE_SKIP_SUCCESS_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_CQE_SKIP_SUCCESS_BIT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bits
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE_BIT"><code>IOSQE_FIXED_FILE_BIT</code></a></li>
 <li><a href="#IOSQE_IO_DRAIN_BIT"><code>IOSQE_IO_DRAIN_BIT</code></a></li>
 <li><a href="#IOSQE_IO_LINK_BIT"><code>IOSQE_IO_LINK_BIT</code></a></li>
 <li><a href="#IOSQE_IO_HARDLINK_BIT"><code>IOSQE_IO_HARDLINK_BIT</code></a></li>
 <li><a href="#IOSQE_ASYNC_BIT"><code>IOSQE_ASYNC_BIT</code></a></li>
 <li><a href="#IOSQE_BUFFER_SELECT_BIT"><code>IOSQE_BUFFER_SELECT_BIT</code></a></li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS_BIT"><code>IOSQE_CQE_SKIP_SUCCESS_BIT</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_CQE_SKIP_SUCCESS_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_FIXED_FILE">
<h3>IOSQE_FIXED_FILE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_FIXED_FILE</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> - 
 When this flag is specified, <code>fd</code> is an index into the files array registered with the <code>io_uring</code> instance (see the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>
 section of the <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> man page).
 
 <p>Note that this isn't always available for all commands. If used on a command that doesn't support fixed files, the SQE will error with
 <code>-EBADF</code>.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a> - 
 When this flag is specified, the SQE will not be started before previously submitted SQEs have completed, and new SQEs will not be started before
 this one completes.
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> - 
 When this flag is specified, it forms a link with the next SQE in the submission ring.
 
 <p>That next SQE will not be started before the previous request completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The
 tail of the chain is denoted by the first SQE that does not have this flag set. Chains are not supported across submission boundaries. Even if the
 last SQE in a submission has this flag set, it will still terminate the current chain. This flag has no effect on previous SQE submissions, nor
 does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual
 SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. <code>io_uring</code>
 considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links
 is broken, the remaining unstarted part of the chain will be terminated and completed with <code>-ECANCELED</code> as the error code.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a> - 
 Like <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, but it doesn't sever regardless of the completion result.
 
 <p>Note that the link will still sever if we fail submitting the parent request, hard links are only resilient in the presence of completion results
 for requests that did submit correctly. <code>IOSQE_IO_HARDLINK</code> implies <code>IOSQE_IO_LINK</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IOSQE_ASYNC"><code>IOSQE_ASYNC</code></a> - 
 Normal operation for <code>io_uring</code> is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner.
 
 <p>To support more efficient overlapped operation of requests that the application knows/assumes will always (or most of the time) block, the
 application can ask for an sqe to be issued async from the start.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> - 
 Used in conjunction with the <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> command, which registers a pool of buffers to be used by commands that read or receive data.
 
 <p>When buffers are registered for this use case, and this flag is set in the command, <code>io_uring</code> will grab a buffer from this pool when the
 request is ready to receive or read data. If successful, the resulting CQE will have <a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> set in the flags part of the struct, and the
 upper <a href="#IORING_CQE_BUFFER_SHIFT"><code>CQE_BUFFER_SHIFT</code></a> bits will contain the ID of the selected buffers. This allows the application to know exactly which buffer was selected for
 the operation. If no buffers are available and this flag is set, then the request will fail with <code>-ENOBUFS</code> as the error code. Once a buffer
 has been used, it is no longer available in the kernel pool. The application must re-register the given buffer again when it is ready to recycle it
 (eg has completed using it).</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> - 
 Don't generate a CQE if the request completes successfully.
 
 <p>If the request fails, an appropriate CQE will be posted as usual and if there is no <a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a>, CQEs for all linked requests will be
 omitted. The notion of failure/success is <code>opcode</code> specific and is the same as with breaking chains of <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>. One special case is
 when the request has a linked timeout, then the CQE generation for the linked timeout is decided solely by whether it has
 <code>IOSQE_CQE_SKIP_SUCCESS</code> set, regardless whether it timed out or was cancelled. In other words, if a linked timeout has the flag set, it's
 guaranteed to not post a CQE.</p>
 
 <p>The semantics are chosen to accommodate several use cases. First, when all but the last request of a normal link without linked timeouts are marked
 with the flag, only one CQE per link is posted. Additionally, it enables supression of CQEs in cases where the side effects of a successfully
 executed operation is enough for userspace to know the state of the system. One such example would be writing to a synchronisation file.</p>
 
 <p>This flag is incompatible with <a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a>. Using both of them in a single ring is undefined behavior, even when they are not used together in
 a single request. Currently, after the first request with <code>IOSQE_CQE_SKIP_SUCCESS</code>, all subsequent requests marked with drain will be failed
 at submission time. Note that the error reporting is best effort only, and restrictions may change in the future.</p>
 
 <p>Available since 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_FIXED_FILE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_IO_DRAIN">
<h3>IOSQE_IO_DRAIN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_IO_DRAIN</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> - 
 When this flag is specified, <code>fd</code> is an index into the files array registered with the <code>io_uring</code> instance (see the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>
 section of the <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> man page).
 
 <p>Note that this isn't always available for all commands. If used on a command that doesn't support fixed files, the SQE will error with
 <code>-EBADF</code>.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a> - 
 When this flag is specified, the SQE will not be started before previously submitted SQEs have completed, and new SQEs will not be started before
 this one completes.
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> - 
 When this flag is specified, it forms a link with the next SQE in the submission ring.
 
 <p>That next SQE will not be started before the previous request completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The
 tail of the chain is denoted by the first SQE that does not have this flag set. Chains are not supported across submission boundaries. Even if the
 last SQE in a submission has this flag set, it will still terminate the current chain. This flag has no effect on previous SQE submissions, nor
 does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual
 SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. <code>io_uring</code>
 considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links
 is broken, the remaining unstarted part of the chain will be terminated and completed with <code>-ECANCELED</code> as the error code.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a> - 
 Like <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, but it doesn't sever regardless of the completion result.
 
 <p>Note that the link will still sever if we fail submitting the parent request, hard links are only resilient in the presence of completion results
 for requests that did submit correctly. <code>IOSQE_IO_HARDLINK</code> implies <code>IOSQE_IO_LINK</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IOSQE_ASYNC"><code>IOSQE_ASYNC</code></a> - 
 Normal operation for <code>io_uring</code> is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner.
 
 <p>To support more efficient overlapped operation of requests that the application knows/assumes will always (or most of the time) block, the
 application can ask for an sqe to be issued async from the start.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> - 
 Used in conjunction with the <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> command, which registers a pool of buffers to be used by commands that read or receive data.
 
 <p>When buffers are registered for this use case, and this flag is set in the command, <code>io_uring</code> will grab a buffer from this pool when the
 request is ready to receive or read data. If successful, the resulting CQE will have <a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> set in the flags part of the struct, and the
 upper <a href="#IORING_CQE_BUFFER_SHIFT"><code>CQE_BUFFER_SHIFT</code></a> bits will contain the ID of the selected buffers. This allows the application to know exactly which buffer was selected for
 the operation. If no buffers are available and this flag is set, then the request will fail with <code>-ENOBUFS</code> as the error code. Once a buffer
 has been used, it is no longer available in the kernel pool. The application must re-register the given buffer again when it is ready to recycle it
 (eg has completed using it).</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> - 
 Don't generate a CQE if the request completes successfully.
 
 <p>If the request fails, an appropriate CQE will be posted as usual and if there is no <a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a>, CQEs for all linked requests will be
 omitted. The notion of failure/success is <code>opcode</code> specific and is the same as with breaking chains of <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>. One special case is
 when the request has a linked timeout, then the CQE generation for the linked timeout is decided solely by whether it has
 <code>IOSQE_CQE_SKIP_SUCCESS</code> set, regardless whether it timed out or was cancelled. In other words, if a linked timeout has the flag set, it's
 guaranteed to not post a CQE.</p>
 
 <p>The semantics are chosen to accommodate several use cases. First, when all but the last request of a normal link without linked timeouts are marked
 with the flag, only one CQE per link is posted. Additionally, it enables supression of CQEs in cases where the side effects of a successfully
 executed operation is enough for userspace to know the state of the system. One such example would be writing to a synchronisation file.</p>
 
 <p>This flag is incompatible with <a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a>. Using both of them in a single ring is undefined behavior, even when they are not used together in
 a single request. Currently, after the first request with <code>IOSQE_CQE_SKIP_SUCCESS</code>, all subsequent requests marked with drain will be failed
 at submission time. Note that the error reporting is best effort only, and restrictions may change in the future.</p>
 
 <p>Available since 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_IO_DRAIN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_IO_LINK">
<h3>IOSQE_IO_LINK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_IO_LINK</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> - 
 When this flag is specified, <code>fd</code> is an index into the files array registered with the <code>io_uring</code> instance (see the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>
 section of the <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> man page).
 
 <p>Note that this isn't always available for all commands. If used on a command that doesn't support fixed files, the SQE will error with
 <code>-EBADF</code>.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a> - 
 When this flag is specified, the SQE will not be started before previously submitted SQEs have completed, and new SQEs will not be started before
 this one completes.
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> - 
 When this flag is specified, it forms a link with the next SQE in the submission ring.
 
 <p>That next SQE will not be started before the previous request completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The
 tail of the chain is denoted by the first SQE that does not have this flag set. Chains are not supported across submission boundaries. Even if the
 last SQE in a submission has this flag set, it will still terminate the current chain. This flag has no effect on previous SQE submissions, nor
 does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual
 SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. <code>io_uring</code>
 considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links
 is broken, the remaining unstarted part of the chain will be terminated and completed with <code>-ECANCELED</code> as the error code.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a> - 
 Like <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, but it doesn't sever regardless of the completion result.
 
 <p>Note that the link will still sever if we fail submitting the parent request, hard links are only resilient in the presence of completion results
 for requests that did submit correctly. <code>IOSQE_IO_HARDLINK</code> implies <code>IOSQE_IO_LINK</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IOSQE_ASYNC"><code>IOSQE_ASYNC</code></a> - 
 Normal operation for <code>io_uring</code> is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner.
 
 <p>To support more efficient overlapped operation of requests that the application knows/assumes will always (or most of the time) block, the
 application can ask for an sqe to be issued async from the start.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> - 
 Used in conjunction with the <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> command, which registers a pool of buffers to be used by commands that read or receive data.
 
 <p>When buffers are registered for this use case, and this flag is set in the command, <code>io_uring</code> will grab a buffer from this pool when the
 request is ready to receive or read data. If successful, the resulting CQE will have <a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> set in the flags part of the struct, and the
 upper <a href="#IORING_CQE_BUFFER_SHIFT"><code>CQE_BUFFER_SHIFT</code></a> bits will contain the ID of the selected buffers. This allows the application to know exactly which buffer was selected for
 the operation. If no buffers are available and this flag is set, then the request will fail with <code>-ENOBUFS</code> as the error code. Once a buffer
 has been used, it is no longer available in the kernel pool. The application must re-register the given buffer again when it is ready to recycle it
 (eg has completed using it).</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> - 
 Don't generate a CQE if the request completes successfully.
 
 <p>If the request fails, an appropriate CQE will be posted as usual and if there is no <a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a>, CQEs for all linked requests will be
 omitted. The notion of failure/success is <code>opcode</code> specific and is the same as with breaking chains of <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>. One special case is
 when the request has a linked timeout, then the CQE generation for the linked timeout is decided solely by whether it has
 <code>IOSQE_CQE_SKIP_SUCCESS</code> set, regardless whether it timed out or was cancelled. In other words, if a linked timeout has the flag set, it's
 guaranteed to not post a CQE.</p>
 
 <p>The semantics are chosen to accommodate several use cases. First, when all but the last request of a normal link without linked timeouts are marked
 with the flag, only one CQE per link is posted. Additionally, it enables supression of CQEs in cases where the side effects of a successfully
 executed operation is enough for userspace to know the state of the system. One such example would be writing to a synchronisation file.</p>
 
 <p>This flag is incompatible with <a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a>. Using both of them in a single ring is undefined behavior, even when they are not used together in
 a single request. Currently, after the first request with <code>IOSQE_CQE_SKIP_SUCCESS</code>, all subsequent requests marked with drain will be failed
 at submission time. Note that the error reporting is best effort only, and restrictions may change in the future.</p>
 
 <p>Available since 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_IO_LINK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_IO_HARDLINK">
<h3>IOSQE_IO_HARDLINK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_IO_HARDLINK</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> - 
 When this flag is specified, <code>fd</code> is an index into the files array registered with the <code>io_uring</code> instance (see the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>
 section of the <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> man page).
 
 <p>Note that this isn't always available for all commands. If used on a command that doesn't support fixed files, the SQE will error with
 <code>-EBADF</code>.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a> - 
 When this flag is specified, the SQE will not be started before previously submitted SQEs have completed, and new SQEs will not be started before
 this one completes.
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> - 
 When this flag is specified, it forms a link with the next SQE in the submission ring.
 
 <p>That next SQE will not be started before the previous request completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The
 tail of the chain is denoted by the first SQE that does not have this flag set. Chains are not supported across submission boundaries. Even if the
 last SQE in a submission has this flag set, it will still terminate the current chain. This flag has no effect on previous SQE submissions, nor
 does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual
 SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. <code>io_uring</code>
 considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links
 is broken, the remaining unstarted part of the chain will be terminated and completed with <code>-ECANCELED</code> as the error code.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a> - 
 Like <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, but it doesn't sever regardless of the completion result.
 
 <p>Note that the link will still sever if we fail submitting the parent request, hard links are only resilient in the presence of completion results
 for requests that did submit correctly. <code>IOSQE_IO_HARDLINK</code> implies <code>IOSQE_IO_LINK</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IOSQE_ASYNC"><code>IOSQE_ASYNC</code></a> - 
 Normal operation for <code>io_uring</code> is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner.
 
 <p>To support more efficient overlapped operation of requests that the application knows/assumes will always (or most of the time) block, the
 application can ask for an sqe to be issued async from the start.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> - 
 Used in conjunction with the <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> command, which registers a pool of buffers to be used by commands that read or receive data.
 
 <p>When buffers are registered for this use case, and this flag is set in the command, <code>io_uring</code> will grab a buffer from this pool when the
 request is ready to receive or read data. If successful, the resulting CQE will have <a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> set in the flags part of the struct, and the
 upper <a href="#IORING_CQE_BUFFER_SHIFT"><code>CQE_BUFFER_SHIFT</code></a> bits will contain the ID of the selected buffers. This allows the application to know exactly which buffer was selected for
 the operation. If no buffers are available and this flag is set, then the request will fail with <code>-ENOBUFS</code> as the error code. Once a buffer
 has been used, it is no longer available in the kernel pool. The application must re-register the given buffer again when it is ready to recycle it
 (eg has completed using it).</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> - 
 Don't generate a CQE if the request completes successfully.
 
 <p>If the request fails, an appropriate CQE will be posted as usual and if there is no <a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a>, CQEs for all linked requests will be
 omitted. The notion of failure/success is <code>opcode</code> specific and is the same as with breaking chains of <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>. One special case is
 when the request has a linked timeout, then the CQE generation for the linked timeout is decided solely by whether it has
 <code>IOSQE_CQE_SKIP_SUCCESS</code> set, regardless whether it timed out or was cancelled. In other words, if a linked timeout has the flag set, it's
 guaranteed to not post a CQE.</p>
 
 <p>The semantics are chosen to accommodate several use cases. First, when all but the last request of a normal link without linked timeouts are marked
 with the flag, only one CQE per link is posted. Additionally, it enables supression of CQEs in cases where the side effects of a successfully
 executed operation is enough for userspace to know the state of the system. One such example would be writing to a synchronisation file.</p>
 
 <p>This flag is incompatible with <a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a>. Using both of them in a single ring is undefined behavior, even when they are not used together in
 a single request. Currently, after the first request with <code>IOSQE_CQE_SKIP_SUCCESS</code>, all subsequent requests marked with drain will be failed
 at submission time. Note that the error reporting is best effort only, and restrictions may change in the future.</p>
 
 <p>Available since 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_IO_HARDLINK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_ASYNC">
<h3>IOSQE_ASYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_ASYNC</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> - 
 When this flag is specified, <code>fd</code> is an index into the files array registered with the <code>io_uring</code> instance (see the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>
 section of the <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> man page).
 
 <p>Note that this isn't always available for all commands. If used on a command that doesn't support fixed files, the SQE will error with
 <code>-EBADF</code>.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a> - 
 When this flag is specified, the SQE will not be started before previously submitted SQEs have completed, and new SQEs will not be started before
 this one completes.
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> - 
 When this flag is specified, it forms a link with the next SQE in the submission ring.
 
 <p>That next SQE will not be started before the previous request completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The
 tail of the chain is denoted by the first SQE that does not have this flag set. Chains are not supported across submission boundaries. Even if the
 last SQE in a submission has this flag set, it will still terminate the current chain. This flag has no effect on previous SQE submissions, nor
 does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual
 SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. <code>io_uring</code>
 considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links
 is broken, the remaining unstarted part of the chain will be terminated and completed with <code>-ECANCELED</code> as the error code.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a> - 
 Like <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, but it doesn't sever regardless of the completion result.
 
 <p>Note that the link will still sever if we fail submitting the parent request, hard links are only resilient in the presence of completion results
 for requests that did submit correctly. <code>IOSQE_IO_HARDLINK</code> implies <code>IOSQE_IO_LINK</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IOSQE_ASYNC"><code>IOSQE_ASYNC</code></a> - 
 Normal operation for <code>io_uring</code> is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner.
 
 <p>To support more efficient overlapped operation of requests that the application knows/assumes will always (or most of the time) block, the
 application can ask for an sqe to be issued async from the start.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> - 
 Used in conjunction with the <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> command, which registers a pool of buffers to be used by commands that read or receive data.
 
 <p>When buffers are registered for this use case, and this flag is set in the command, <code>io_uring</code> will grab a buffer from this pool when the
 request is ready to receive or read data. If successful, the resulting CQE will have <a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> set in the flags part of the struct, and the
 upper <a href="#IORING_CQE_BUFFER_SHIFT"><code>CQE_BUFFER_SHIFT</code></a> bits will contain the ID of the selected buffers. This allows the application to know exactly which buffer was selected for
 the operation. If no buffers are available and this flag is set, then the request will fail with <code>-ENOBUFS</code> as the error code. Once a buffer
 has been used, it is no longer available in the kernel pool. The application must re-register the given buffer again when it is ready to recycle it
 (eg has completed using it).</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> - 
 Don't generate a CQE if the request completes successfully.
 
 <p>If the request fails, an appropriate CQE will be posted as usual and if there is no <a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a>, CQEs for all linked requests will be
 omitted. The notion of failure/success is <code>opcode</code> specific and is the same as with breaking chains of <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>. One special case is
 when the request has a linked timeout, then the CQE generation for the linked timeout is decided solely by whether it has
 <code>IOSQE_CQE_SKIP_SUCCESS</code> set, regardless whether it timed out or was cancelled. In other words, if a linked timeout has the flag set, it's
 guaranteed to not post a CQE.</p>
 
 <p>The semantics are chosen to accommodate several use cases. First, when all but the last request of a normal link without linked timeouts are marked
 with the flag, only one CQE per link is posted. Additionally, it enables supression of CQEs in cases where the side effects of a successfully
 executed operation is enough for userspace to know the state of the system. One such example would be writing to a synchronisation file.</p>
 
 <p>This flag is incompatible with <a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a>. Using both of them in a single ring is undefined behavior, even when they are not used together in
 a single request. Currently, after the first request with <code>IOSQE_CQE_SKIP_SUCCESS</code>, all subsequent requests marked with drain will be failed
 at submission time. Note that the error reporting is best effort only, and restrictions may change in the future.</p>
 
 <p>Available since 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_ASYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_BUFFER_SELECT">
<h3>IOSQE_BUFFER_SELECT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_BUFFER_SELECT</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> - 
 When this flag is specified, <code>fd</code> is an index into the files array registered with the <code>io_uring</code> instance (see the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>
 section of the <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> man page).
 
 <p>Note that this isn't always available for all commands. If used on a command that doesn't support fixed files, the SQE will error with
 <code>-EBADF</code>.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a> - 
 When this flag is specified, the SQE will not be started before previously submitted SQEs have completed, and new SQEs will not be started before
 this one completes.
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> - 
 When this flag is specified, it forms a link with the next SQE in the submission ring.
 
 <p>That next SQE will not be started before the previous request completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The
 tail of the chain is denoted by the first SQE that does not have this flag set. Chains are not supported across submission boundaries. Even if the
 last SQE in a submission has this flag set, it will still terminate the current chain. This flag has no effect on previous SQE submissions, nor
 does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual
 SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. <code>io_uring</code>
 considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links
 is broken, the remaining unstarted part of the chain will be terminated and completed with <code>-ECANCELED</code> as the error code.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a> - 
 Like <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, but it doesn't sever regardless of the completion result.
 
 <p>Note that the link will still sever if we fail submitting the parent request, hard links are only resilient in the presence of completion results
 for requests that did submit correctly. <code>IOSQE_IO_HARDLINK</code> implies <code>IOSQE_IO_LINK</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IOSQE_ASYNC"><code>IOSQE_ASYNC</code></a> - 
 Normal operation for <code>io_uring</code> is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner.
 
 <p>To support more efficient overlapped operation of requests that the application knows/assumes will always (or most of the time) block, the
 application can ask for an sqe to be issued async from the start.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> - 
 Used in conjunction with the <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> command, which registers a pool of buffers to be used by commands that read or receive data.
 
 <p>When buffers are registered for this use case, and this flag is set in the command, <code>io_uring</code> will grab a buffer from this pool when the
 request is ready to receive or read data. If successful, the resulting CQE will have <a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> set in the flags part of the struct, and the
 upper <a href="#IORING_CQE_BUFFER_SHIFT"><code>CQE_BUFFER_SHIFT</code></a> bits will contain the ID of the selected buffers. This allows the application to know exactly which buffer was selected for
 the operation. If no buffers are available and this flag is set, then the request will fail with <code>-ENOBUFS</code> as the error code. Once a buffer
 has been used, it is no longer available in the kernel pool. The application must re-register the given buffer again when it is ready to recycle it
 (eg has completed using it).</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> - 
 Don't generate a CQE if the request completes successfully.
 
 <p>If the request fails, an appropriate CQE will be posted as usual and if there is no <a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a>, CQEs for all linked requests will be
 omitted. The notion of failure/success is <code>opcode</code> specific and is the same as with breaking chains of <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>. One special case is
 when the request has a linked timeout, then the CQE generation for the linked timeout is decided solely by whether it has
 <code>IOSQE_CQE_SKIP_SUCCESS</code> set, regardless whether it timed out or was cancelled. In other words, if a linked timeout has the flag set, it's
 guaranteed to not post a CQE.</p>
 
 <p>The semantics are chosen to accommodate several use cases. First, when all but the last request of a normal link without linked timeouts are marked
 with the flag, only one CQE per link is posted. Additionally, it enables supression of CQEs in cases where the side effects of a successfully
 executed operation is enough for userspace to know the state of the system. One such example would be writing to a synchronisation file.</p>
 
 <p>This flag is incompatible with <a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a>. Using both of them in a single ring is undefined behavior, even when they are not used together in
 a single request. Currently, after the first request with <code>IOSQE_CQE_SKIP_SUCCESS</code>, all subsequent requests marked with drain will be failed
 at submission time. Note that the error reporting is best effort only, and restrictions may change in the future.</p>
 
 <p>Available since 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_BUFFER_SELECT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IOSQE_CQE_SKIP_SUCCESS">
<h3>IOSQE_CQE_SKIP_SUCCESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IOSQE_CQE_SKIP_SUCCESS</span></div>
<div class="block"><code>io_uring_sqe-&gt;flags</code> bitfield values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> - 
 When this flag is specified, <code>fd</code> is an index into the files array registered with the <code>io_uring</code> instance (see the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>
 section of the <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> man page).
 
 <p>Note that this isn't always available for all commands. If used on a command that doesn't support fixed files, the SQE will error with
 <code>-EBADF</code>.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a> - 
 When this flag is specified, the SQE will not be started before previously submitted SQEs have completed, and new SQEs will not be started before
 this one completes.
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> - 
 When this flag is specified, it forms a link with the next SQE in the submission ring.
 
 <p>That next SQE will not be started before the previous request completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The
 tail of the chain is denoted by the first SQE that does not have this flag set. Chains are not supported across submission boundaries. Even if the
 last SQE in a submission has this flag set, it will still terminate the current chain. This flag has no effect on previous SQE submissions, nor
 does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual
 SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. <code>io_uring</code>
 considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links
 is broken, the remaining unstarted part of the chain will be terminated and completed with <code>-ECANCELED</code> as the error code.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a> - 
 Like <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, but it doesn't sever regardless of the completion result.
 
 <p>Note that the link will still sever if we fail submitting the parent request, hard links are only resilient in the presence of completion results
 for requests that did submit correctly. <code>IOSQE_IO_HARDLINK</code> implies <code>IOSQE_IO_LINK</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IOSQE_ASYNC"><code>IOSQE_ASYNC</code></a> - 
 Normal operation for <code>io_uring</code> is to try and issue an sqe as non-blocking first, and if that fails, execute it in an async manner.
 
 <p>To support more efficient overlapped operation of requests that the application knows/assumes will always (or most of the time) block, the
 application can ask for an sqe to be issued async from the start.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> - 
 Used in conjunction with the <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> command, which registers a pool of buffers to be used by commands that read or receive data.
 
 <p>When buffers are registered for this use case, and this flag is set in the command, <code>io_uring</code> will grab a buffer from this pool when the
 request is ready to receive or read data. If successful, the resulting CQE will have <a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> set in the flags part of the struct, and the
 upper <a href="#IORING_CQE_BUFFER_SHIFT"><code>CQE_BUFFER_SHIFT</code></a> bits will contain the ID of the selected buffers. This allows the application to know exactly which buffer was selected for
 the operation. If no buffers are available and this flag is set, then the request will fail with <code>-ENOBUFS</code> as the error code. Once a buffer
 has been used, it is no longer available in the kernel pool. The application must re-register the given buffer again when it is ready to recycle it
 (eg has completed using it).</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> - 
 Don't generate a CQE if the request completes successfully.
 
 <p>If the request fails, an appropriate CQE will be posted as usual and if there is no <a href="#IOSQE_IO_HARDLINK"><code>IOSQE_IO_HARDLINK</code></a>, CQEs for all linked requests will be
 omitted. The notion of failure/success is <code>opcode</code> specific and is the same as with breaking chains of <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>. One special case is
 when the request has a linked timeout, then the CQE generation for the linked timeout is decided solely by whether it has
 <code>IOSQE_CQE_SKIP_SUCCESS</code> set, regardless whether it timed out or was cancelled. In other words, if a linked timeout has the flag set, it's
 guaranteed to not post a CQE.</p>
 
 <p>The semantics are chosen to accommodate several use cases. First, when all but the last request of a normal link without linked timeouts are marked
 with the flag, only one CQE per link is posted. Additionally, it enables supression of CQEs in cases where the side effects of a successfully
 executed operation is enough for userspace to know the state of the system. One such example would be writing to a synchronisation file.</p>
 
 <p>This flag is incompatible with <a href="#IOSQE_IO_DRAIN"><code>IOSQE_IO_DRAIN</code></a>. Using both of them in a single ring is undefined behavior, even when they are not used together in
 a single request. Currently, after the first request with <code>IOSQE_CQE_SKIP_SUCCESS</code>, all subsequent requests marked with drain will be failed
 at submission time. Note that the error reporting is best effort only, and restrictions may change in the future.</p>
 
 <p>Available since 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IOSQE_CQE_SKIP_SUCCESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_IOPOLL">
<h3>IORING_SETUP_IOPOLL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_IOPOLL</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_IOPOLL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_SQPOLL">
<h3>IORING_SETUP_SQPOLL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_SQPOLL</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_SQPOLL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_SQ_AFF">
<h3>IORING_SETUP_SQ_AFF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_SQ_AFF</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_SQ_AFF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_CQSIZE">
<h3>IORING_SETUP_CQSIZE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_CQSIZE</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_CQSIZE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_CLAMP">
<h3>IORING_SETUP_CLAMP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_CLAMP</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_CLAMP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_ATTACH_WQ">
<h3>IORING_SETUP_ATTACH_WQ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_ATTACH_WQ</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_ATTACH_WQ">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_R_DISABLED">
<h3>IORING_SETUP_R_DISABLED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_R_DISABLED</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_R_DISABLED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_SUBMIT_ALL">
<h3>IORING_SETUP_SUBMIT_ALL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_SUBMIT_ALL</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_SUBMIT_ALL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_COOP_TASKRUN">
<h3>IORING_SETUP_COOP_TASKRUN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_COOP_TASKRUN</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_COOP_TASKRUN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_TASKRUN_FLAG">
<h3>IORING_SETUP_TASKRUN_FLAG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_TASKRUN_FLAG</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_TASKRUN_FLAG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_SQE128">
<h3>IORING_SETUP_SQE128</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_SQE128</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_SQE128">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_CQE32">
<h3>IORING_SETUP_CQE32</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_CQE32</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_CQE32">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_SINGLE_ISSUER">
<h3>IORING_SETUP_SINGLE_ISSUER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_SINGLE_ISSUER</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_SINGLE_ISSUER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SETUP_DEFER_TASKRUN">
<h3>IORING_SETUP_DEFER_TASKRUN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SETUP_DEFER_TASKRUN</span></div>
<div class="block"><code>io_uring_setup()</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> - 
 Perform busy-waiting for an I/O completion, as opposed to getting notifications via an asynchronous IRQ (Interrupt Request).
 
 <p>The file system (if any) and block device must support polling in order for this to work. Busy-waiting provides lower latency, but may consume more
 CPU resources than interrupt driven I/O. Currently, this feature is usable only on a file descriptor opened using the <code>O_DIRECT</code> flag. When a
 read or write is submitted to a polled context, the application must poll for completions on the CQ ring by calling <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>. It is illegal to mix
 and match polled and non-polled I/O on an io_uring instance.</p>
 </li>
 <li><a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> - 
 When this flag is specified, a kernel thread is created to perform submission queue polling.
 
 <p>An <code>io_uring</code> instance configured in this way enables an application to issue I/O without ever context switching into the kernel. By using
 the submission queue to fill in new submission queue entries and watching for completions on the completion queue, the application can submit and
 reap I/Os without doing a single system call.</p>
 
 <p>If the kernel thread is idle for more than <code>sq_thread_idle</code> milliseconds, it will set the <a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> bit in the flags field of the
 struct <code>io_sq_ring</code>. When this happens, the application must call <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to wake the kernel thread. If I/O is kept busy, the kernel thread
 will never sleep. An application making use of this feature will need to guard the <code>io_uring_enter()</code> call with the following code sequence:</p>
 
 <pre><code>
 // Ensure that the wakeup flag is read after the tail pointer
 // has been written. It's important to use memory load acquire
 // semantics for the flags read, as otherwise the application
 // and the kernel might not agree on the consistency of the
 // wakeup flag.
 unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);
 if (flags &amp; IORING_SQ_NEED_WAKEUP)
     io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</code></pre>
 
 <p>where <code>sq_ring</code> is a submission queue ring setup using the struct <code>io_sqring_offsets</code> described below.</p>
 
 <p>Before version 5.11 of the Linux kernel, to successfully use this feature, the application must register a set of files to be used for IO through
 <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> using the <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> opcode. Failure to do so will result in submitted IO being errored with <code>EBADF</code>. The presence of this
 feature can be detected by the <a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> feature flag. In version 5.11 and later, it is no longer necessary to register files to use
 this feature. 5.11 also allows using this as non-root, if the user has the <code>CAP_SYS_NICE</code> capability.</p>
 </li>
 <li><a href="#IORING_SETUP_SQ_AFF"><code>SETUP_SQ_AFF</code></a> - 
 If this flag is specified, then the poll thread will be bound to the cpu set in the <code>sq_thread_cpu</code> field of the struct
 <code>io_uring_params</code>. This flag is only meaningful when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is specified. When <code>cgroup</code> setting <code>cpuset.cpus</code> changes
 (typically in container environment), the bounded cpu set may be changed as well.
 </li>
 <li><a href="#IORING_SETUP_CQSIZE"><code>SETUP_CQSIZE</code></a> - 
 Create the completion queue with struct <code>io_uring_params.cq_entries</code> entries.
 
 <p>The value must be greater than entries, and may be rounded up to the next power-of-two.</p>
 </li>
 <li><a href="#IORING_SETUP_CLAMP"><code>SETUP_CLAMP</code></a> - 
 If this flag is specified, and if entries exceeds <a href="#IORING_MAX_ENTRIES"><code>MAX_ENTRIES</code></a>, then entries will be clamped at <code>IORING_MAX_ENTRIES</code>.
 
 <p>If the flag <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set, and if the value of struct <code>io_uring_params.cq_entries</code> exceeds <code>IORING_MAX_CQ_ENTRIES</code>, then it will
 be clamped at <code>IORING_MAX_CQ_ENTRIES</code>.</p>
 </li>
 <li><a href="#IORING_SETUP_ATTACH_WQ"><code>SETUP_ATTACH_WQ</code></a> - 
 This flag should be set in conjunction with struct <code>io_uring_params.wq_fd</code> being set to an existing <code>io_uring</code> ring file descriptor.
 
 <p>When set, the <code>io_uring</code> instance being created will share the asynchronous worker thread backend of the specified <code>io_uring</code> ring,
 rather than create a new separate thread pool.</p>
 </li>
 <li><a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> - 
 If this flag is specified, the io_uring ring starts in a disabled state.
 
 <p>In this state, restrictions can be registered, but submissions are not allowed. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to enable the ring.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_SETUP_SUBMIT_ALL"><code>SETUP_SUBMIT_ALL</code></a> - 
 Continue submit on error.
 
 <p>Normally io_uring stops submitting a batch of request, if one of these requests results in an error. This can cause submission of less than what is
 expected, if a request ends in error while being submitted. If the ring is created with this flag, <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> will continue submitting requests even
 if it encounters an error submitting a request. CQEs are still posted for errored request regardless of whether or not this flag is set at ring
 creation time, the only difference is if the submit sequence is halted or continued when an error is observed.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a> - 
 Cooperative task running.
 
 <p>By default, io_uring will interrupt a task running in userspace when a completion event comes in. This is to ensure that completions run in a
 timely manner. For a lot of use cases, this is overkill and can cause reduced performance from both the inter-processor interrupt used to do this,
 the kernel/user transition, the needless interruption of the tasks userspace activities, and reduced batching if completions come in at a rapid
 rate. Most applications don't need the forceful interruption, as the events are processed at any kernel/user transition. The exception are setups
 where the application uses multiple threads operating on the same ring, where the application waiting on completions isn't the one that submitted
 them. For most other use cases, setting this flag will improve performance.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_TASKRUN_FLAG"><code>SETUP_TASKRUN_FLAG</code></a> - 
 Used in conjunction with <a href="#IORING_SETUP_COOP_TASKRUN"><code>SETUP_COOP_TASKRUN</code></a>, this provides a flag, <a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a>, which is set in the SQ ring <code>flags</code> whenever completions are
 pending that should be processed. liburing will check for this flag even when doing <a href="LibURing.html#io_uring_peek_cqe(org.lwjgl.system.linux.liburing.IOURing,org.lwjgl.PointerBuffer)"><code>peek_cqe</code></a> and enter the kernel to process them, and
 applications can do the same. This makes <code>IORING_SETUP_TASKRUN_FLAG</code> safe to use even when applications rely on a peek style operation on the
 CQ ring to see if anything might be pending to reap.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SQE128"><code>SETUP_SQE128</code></a> - 
 If set, io_uring will use 128-byte SQEs rather than the normal 64-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_CQE32"><code>SETUP_CQE32</code></a> - 
 If set, io_uring will use 32-byte CQEs rather than the normal 32-byte sized variant.
 
 <p>This is a requirement for using certain request types, as of 5.19 only the <a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a> passthrough command for NVMe passthrough needs this.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> - 
 A hint to the kernel that only a single task can submit requests, which is used for internal optimisations.
 
 <p>The kernel enforces the rule, which only affects <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> calls submitting requests and will fail them with <code>-EEXIST</code> if the restriction is
 violated. The submitter task may differ from the task that created the ring. Note that when <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> is set it is considered that the polling
 task is doing all submissions on behalf of the userspace and so it always complies with the rule disregarding how many userspace tasks do
 <code>io_uring_enter</code>.</p>
 
 <p>Available since 5.20.</p>
 </li>
 <li><a href="#IORING_SETUP_DEFER_TASKRUN"><code>SETUP_DEFER_TASKRUN</code></a> - 
 Defer running task work to get events.
 
 <p>By default, io_uring will process all outstanding work at the end of any system call or thread interrupt. This can delay the application from
 making other progress. Setting this flag will hint to io_uring that it should defer work until an <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> call with the <a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> flag set.
 This allows the application to request work to run just before it wants to process completions. This flag requires the <a href="#IORING_SETUP_SINGLE_ISSUER"><code>SETUP_SINGLE_ISSUER</code></a> flag to
 be set, and also enforces that the call to <code>io_uring_enter</code> is called from the same thread that submitted requests. Note that if this flag is
 set then it is the application's responsibility to periodically trigger work (for example via any of the CQE waiting functions) or else completions
 may not be delivered.</p>
 
 <p>Available since 6.1.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SETUP_DEFER_TASKRUN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_NOP">
<h3>IORING_OP_NOP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_NOP</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_NOP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_READV">
<h3>IORING_OP_READV</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_READV</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_READV">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_WRITEV">
<h3>IORING_OP_WRITEV</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_WRITEV</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_WRITEV">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_FSYNC">
<h3>IORING_OP_FSYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_FSYNC</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_FSYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_READ_FIXED">
<h3>IORING_OP_READ_FIXED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_READ_FIXED</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_READ_FIXED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_WRITE_FIXED">
<h3>IORING_OP_WRITE_FIXED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_WRITE_FIXED</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_WRITE_FIXED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_POLL_ADD">
<h3>IORING_OP_POLL_ADD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_POLL_ADD</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_POLL_ADD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_POLL_REMOVE">
<h3>IORING_OP_POLL_REMOVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_POLL_REMOVE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_POLL_REMOVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SYNC_FILE_RANGE">
<h3>IORING_OP_SYNC_FILE_RANGE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SYNC_FILE_RANGE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SYNC_FILE_RANGE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SENDMSG">
<h3>IORING_OP_SENDMSG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SENDMSG</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SENDMSG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_RECVMSG">
<h3>IORING_OP_RECVMSG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_RECVMSG</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_RECVMSG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_TIMEOUT">
<h3>IORING_OP_TIMEOUT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_TIMEOUT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_TIMEOUT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_TIMEOUT_REMOVE">
<h3>IORING_OP_TIMEOUT_REMOVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_TIMEOUT_REMOVE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_TIMEOUT_REMOVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_ACCEPT">
<h3>IORING_OP_ACCEPT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_ACCEPT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_ACCEPT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_ASYNC_CANCEL">
<h3>IORING_OP_ASYNC_CANCEL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_ASYNC_CANCEL</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_ASYNC_CANCEL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_LINK_TIMEOUT">
<h3>IORING_OP_LINK_TIMEOUT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_LINK_TIMEOUT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_LINK_TIMEOUT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_CONNECT">
<h3>IORING_OP_CONNECT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_CONNECT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_CONNECT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_FALLOCATE">
<h3>IORING_OP_FALLOCATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_FALLOCATE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_FALLOCATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_OPENAT">
<h3>IORING_OP_OPENAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_OPENAT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_OPENAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_CLOSE">
<h3>IORING_OP_CLOSE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_CLOSE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_CLOSE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_FILES_UPDATE">
<h3>IORING_OP_FILES_UPDATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_FILES_UPDATE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_FILES_UPDATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_STATX">
<h3>IORING_OP_STATX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_STATX</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_STATX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_READ">
<h3>IORING_OP_READ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_READ</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_READ">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_WRITE">
<h3>IORING_OP_WRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_WRITE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_WRITE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_FADVISE">
<h3>IORING_OP_FADVISE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_FADVISE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_FADVISE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_MADVISE">
<h3>IORING_OP_MADVISE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_MADVISE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_MADVISE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SEND">
<h3>IORING_OP_SEND</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SEND</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SEND">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_RECV">
<h3>IORING_OP_RECV</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_RECV</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_RECV">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_OPENAT2">
<h3>IORING_OP_OPENAT2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_OPENAT2</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_OPENAT2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_EPOLL_CTL">
<h3>IORING_OP_EPOLL_CTL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_EPOLL_CTL</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_EPOLL_CTL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SPLICE">
<h3>IORING_OP_SPLICE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SPLICE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SPLICE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_PROVIDE_BUFFERS">
<h3>IORING_OP_PROVIDE_BUFFERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_PROVIDE_BUFFERS</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_PROVIDE_BUFFERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_REMOVE_BUFFERS">
<h3>IORING_OP_REMOVE_BUFFERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_REMOVE_BUFFERS</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_REMOVE_BUFFERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_TEE">
<h3>IORING_OP_TEE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_TEE</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_TEE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SHUTDOWN">
<h3>IORING_OP_SHUTDOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SHUTDOWN</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SHUTDOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_RENAMEAT">
<h3>IORING_OP_RENAMEAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_RENAMEAT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_RENAMEAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_UNLINKAT">
<h3>IORING_OP_UNLINKAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_UNLINKAT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_UNLINKAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_MKDIRAT">
<h3>IORING_OP_MKDIRAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_MKDIRAT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_MKDIRAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SYMLINKAT">
<h3>IORING_OP_SYMLINKAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SYMLINKAT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SYMLINKAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_LINKAT">
<h3>IORING_OP_LINKAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_LINKAT</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_LINKAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_MSG_RING">
<h3>IORING_OP_MSG_RING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_MSG_RING</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_MSG_RING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_FSETXATTR">
<h3>IORING_OP_FSETXATTR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_FSETXATTR</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_FSETXATTR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SETXATTR">
<h3>IORING_OP_SETXATTR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SETXATTR</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SETXATTR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_FGETXATTR">
<h3>IORING_OP_FGETXATTR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_FGETXATTR</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_FGETXATTR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_GETXATTR">
<h3>IORING_OP_GETXATTR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_GETXATTR</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_GETXATTR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SOCKET">
<h3>IORING_OP_SOCKET</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SOCKET</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SOCKET">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_URING_CMD">
<h3>IORING_OP_URING_CMD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_URING_CMD</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_URING_CMD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_SEND_ZC">
<h3>IORING_OP_SEND_ZC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_SEND_ZC</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_SEND_ZC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OP_LAST">
<h3>IORING_OP_LAST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">byte</span>&nbsp;<span class="element-name">IORING_OP_LAST</span></div>
<div class="block"><code>io_uring_op</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_OP_NOP"><code>OP_NOP</code></a> - Do not perform any I/O. This is useful for testing the performance of the <code>io_uring</code> implementation itself.</li>
 <li><a href="#IORING_OP_READV"><code>OP_READV</code></a> - Vectored read operation, similar to <code>preadv2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> - Vectored write operation, similar to <code>pwritev2(2)</code>. If the file is not seekable, <code>off</code> must be set to zero.</li>
 <li><a href="#IORING_OP_FSYNC"><code>OP_FSYNC</code></a> - 
 File sync. See also <code>fsync(2)</code>.
 
 <p>Note that, while I/O is initiated in the order in which it appears inthe submission queue, completions are unordered. For example, an application
 which places a write I/O followed by an fsync in the submission queue cannot expect the fsync to apply to the write. The two operations execute in
 parallel, so the fsync may complete before the write is issued to the storage. The same is also true for previously issued writes that have not
 completed prior to the fsync.</p>
 </li>
 <li><a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> - Read from pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed reads.</li>
 <li><a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> - Write to pre-mapped buffers. See <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> for details on how to setup a context for fixed writes.</li>
 <li><a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> - 
 Poll the <code>fd</code> specified in the submission queue entry for the events specified in the <code>poll_events</code> field.
 
 <p>Unlike poll or epoll without <code>EPOLLONESHOT</code>, by default this interface always works in one shot mode. That is, once the poll operation is
 completed, it will have to be resubmitted.</p>
 
 <p>If <a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> is set in the SQE <code>len</code> field, then the poll will work in multi shot mode instead. That means it'll repatedly trigger when
 the requested event becomes true, and hence multiple CQEs can be generated from this single SQE. The CQE <code>flags</code> field will have <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>
 set on completion if the application should expect further CQE entries from the original request. If this flag isn't set on completion, then the
 poll request has been terminated and no further events will be generated. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a> is set in the SQE <code>len</code> field, then the request will update an existing poll request with the mask of events passed in
 with this request. The lookup is based on the <code>user_data</code> field of the original SQE submitted, and this values is passed in the <code>addr</code>
 field of the SQE. This mode is available since 5.13.</p>
 
 <p>If <a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a> is set in the SQE <code>len</code> field, then the request will update the <code>user_data</code> of an existing poll request based
 on the value passed in the <code>off</code> field. This mode is available since 5.13.</p>
 
 <p>This command works like an <code>asyncpoll(2)</code> and the completion event result is the returned mask of events. For the variants that update
 <code>user_data</code> or <code>events</code>, the completion result will be similar to <a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a>.</p>
 </li>
 <li><a href="#IORING_OP_POLL_REMOVE"><code>OP_POLL_REMOVE</code></a> - 
 Remove an existing poll request.
 
 <p>If found, the <code>res</code> field of the struct <code>io_uring_cqe</code> will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>, or
 <code>-EALREADY</code> if the poll request was in the process of completing already.</p>
 </li>
 <li><a href="#IORING_OP_SYNC_FILE_RANGE"><code>OP_SYNC_FILE_RANGE</code></a> - 
 Issue the equivalent of a <code>sync_file_range(2)</code> on the file descriptor.
 
 <p>The <code>fd</code> field is the file descriptor to sync, the <code>off</code> field holds the offset in bytes, the <code>len</code> field holds the length in
 bytes, and the <code>sync_range_flags</code> field holds the flags for the command. See also <code>sync_file_range(2)</code> for the general description of
 the related system call.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a> - 
 Issue the equivalent of a <code>sendmsg(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the <code>msghdr</code> structure, and <code>msg_flags</code>
 holds the flags associated with the system call. See also <code>sendmsg(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_RECVMSG"><code>OP_RECVMSG</code></a> - 
 Works just like <a href="#IORING_OP_SENDMSG"><code>OP_SENDMSG</code></a>, except for <code>recvmsg(2)</code> instead. See the description of <code>IORING_OP_SENDMSG</code>.
 
 <p>Available since 5.3.</p>
 </li>
 <li><a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a> - 
 This command will register a timeout operation.
 
 <p>The <code>addr</code> field must contain a pointer to a <code>struct timespec64</code> structure, <code>len</code> must contain 1 to signify one
 <code>timespec64</code> structure, <code>timeout_flags</code> may contain <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a> for an absolute timeout value, or 0 for a relative timeout.
 <code>off</code> may contain a completion event count. A timeout will trigger a wakeup event on the completion ring for anyone waiting for events. A
 timeout condition is met when either the specified timeout expires, or the specified number of events have completed. Either condition will trigger
 the event. If set to 0, completed events are not counted, which effectively acts like a timer. <code>io_uring</code> timeouts use the
 <code>CLOCK_MONOTONIC</code> clock source. The request will complete with <code>-ETIME</code> if the timeout got completed through expiration of the timer,
 or 0 if the timeout got completed through requests completing on their own. If the timeout was cancelled before it expired, the request will
 complete with <code>-ECANCELED</code>.</p>
 
 <p>Available since 5.4.</p>
 
 <p>Since 5.15, this command also supports the following modifiers in <code>timeout_flags</code>:</p>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>. This clock source differs
 in that it includes time elapsed if the system was suspend while having a timeout request in-flight.</li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a>: If set, then the clock source used is <code>CLOCK_BOOTTIME</code> instead of <code>CLOCK_MONOTONIC</code>.</li>
 </ul>
 </li>
 <li><a href="#IORING_OP_TIMEOUT_REMOVE"><code>OP_TIMEOUT_REMOVE</code></a> - 
 If <code>timeout_flags</code> are zero, then it attempts to remove an existing timeout operation. <code>addr</code> must contain the <code>user_data</code> field
 of the previously issued timeout operation. If the specified timeout request is found and cancelled successfully, this request will terminate with
 a result value of 0. If the timeout request was found but expiration was already in progress, this request will terminate with a result value of
 <code>-EBUSY</code>. If the timeout request wasn't found, the request will terminate with a result value of <code>-ENOENT</code>.
 
 <p>Available since 5.5.</p>
 
 <p>If <code>timeout_flags</code> contain <a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a>, instead of removing an existing operation, it updates it. <code>addr</code> and return values are same
 as before. <code>addr2</code> field must contain a pointer to a <code>struct timespec64</code> structure. <code>timeout_flags</code> may also contain
 <a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a>, in which case the value given is an absolute one, not a relative one.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> - 
 Issue the equivalent of an <code>accept4(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the pointer to the <code>sockaddr</code> structure, and <code>addr2</code>
 must contain a pointer to the <code>socklen_t</code> <code>addrlen</code> field. Flags can be passed using the <code>accept_flags</code> field. See also
 <code>accept4(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.5.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If the index points to a valid empty slot, the installation is guaranteed to not fail. If there is already a file in the
 slot, it will be replaced, similar to <a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a>. Please note that only <code>io_uring</code> has access to such files and no other syscall can
 use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_ASYNC_CANCEL"><code>OP_ASYNC_CANCEL</code></a> - 
 Attempt to cancel an already issued request.
 
 <p><code>addr</code> must contain the <code>user_data</code> field of the request that should be cancelled. The cancellation request will complete with one of
 the following results codes. If found, the <code>res</code> field of the cqe will contain 0. If not found, <code>res</code> will contain <code>-ENOENT</code>. If
 found and attempted cancelled, the <code>res</code> field will contain <code>-EALREADY</code>. In this case, the request may or may not terminate. In
 general, requests that are interruptible (like socket IO) will get cancelled, while disk IO requests cannot be cancelled if already started.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_LINK_TIMEOUT"><code>OP_LINK_TIMEOUT</code></a> - 
 This request must be linked with another request through <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a> which is described below.
 
 <p>Unlike <a href="#IORING_OP_TIMEOUT"><code>OP_TIMEOUT</code></a>, <code>IORING_OP_LINK_TIMEOUT</code> acts on the linked request, not the completion queue. The format of the command is otherwise
 like <code>IORING_OP_TIMEOUT</code>, except there's no completion event count as it's tied to a specific request. If used, the timeout specified in the
 command will cancel the linked command, unless the linked command completes before the timeout. The timeout will complete with <code>-ETIME</code> if
 the timer expired and the linked request was attempted cancelled, or <code>-ECANCELED</code> if the timer got cancelled because of completion of the
 linked request. Like <code>IORING_OP_TIMEOUT</code> the clock source used is <code>CLOCK_MONOTONIC</code>.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_CONNECT"><code>OP_CONNECT</code></a> - 
 Issue the equivalent of a <code>connect(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain the const pointer to the <code>sockaddr</code> structure, and
 <code>off</code> must contain the <code>socklen_t</code> <code>addrlen</code> field. See also <code>connect(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.5.</p>
 </li>
 <li><a href="#IORING_OP_FALLOCATE"><code>OP_FALLOCATE</code></a> - 
 Issue the equivalent of a <code>fallocate(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>len</code> must contain the mode associated with the operation, <code>off</code> must contain the offset
 on which to operate, and <code>addr</code> must contain the length. See also <code>fallocate(2)</code> for the general description of the related system
 call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a> - 
 Issue the equivalent of a <code>openat(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>open_flags</code> should contain
 any flags passed in, and <code>len</code> is access mode of the file. See also <code>openat(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_CLOSE"><code>OP_CLOSE</code></a> - 
 Issue the equivalent of a <code>close(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be closed. See also <code>close(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, this command can be used to close files that were direct opened through <a href="#IORING_OP_OPENAT"><code>OP_OPENAT</code></a>,
 <a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a>, or <a href="#IORING_OP_ACCEPT"><code>OP_ACCEPT</code></a> using the <code>io_uring</code> specific direct descriptors. Note that only one of the descriptor fields may be set. The
 direct close feature is available since the 5.15 kernel, where direct descriptors were introduced.</p>
 </li>
 <li><a href="#IORING_OP_FILES_UPDATE"><code>OP_FILES_UPDATE</code></a> - 
 This command is an alternative to using <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> which then works in an async fashion, like the rest of the <code>io_uring</code>
 commands.
 
 <p>The arguments passed in are the same. <code>addr</code> must contain a pointer to the array of file descriptors, <code>len</code> must contain the length of
 the array, and <code>off</code> must contain the offset at which to operate. Note that the array of file descriptors pointed to in <code>addr</code> must
 remain valid until this operation has completed.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_STATX"><code>OP_STATX</code></a> - 
 Issue the equivalent of a <code>statx(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> string, <code>statx_flags</code> is the
 <code>flags</code> argument, <code>len</code> should be the <code>mask</code> argument, and <code>off</code> must contain a pointer to the <code>statxbuf</code> to be
 filled in. See also <code>statx(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_READ"><code>OP_READ</code></a> - 
 Issue the equivalent of a <code>pread(2)</code> or <code>pwrite(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to be operated on, <code>addr</code> contains the buffer in question, <code>len</code> contains the length of the IO
 operation, and <code>offs</code> contains the read or write offset. If <code>fd</code> does not refer to a seekable file, <code>off</code> must be set to zero.
 If <code>offs</code> is set to -1, the offset will use (and advance) the file position, like the <code>read(2)</code> and <code>write(2)</code> system calls.
 These are non-vectored versions of the <a href="#IORING_OP_READV"><code>OP_READV</code></a> and <a href="#IORING_OP_WRITEV"><code>OP_WRITEV</code></a> opcodes. See also <code>read(2)</code> and <code>write(2)</code> for the general description
 of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_WRITE"><code>OP_WRITE</code></a> - See <a href="#IORING_OP_READ"><code>OP_READ</code></a>.</li>
 <li><a href="#IORING_OP_FADVISE"><code>OP_FADVISE</code></a> - 
 Issue the equivalent of a <code>posix_fadvise(2)</code> system call.
 
 <p><code>fd</code> must be set to the file descriptor, <code>off</code> must contain the offset on which to operate, <code>len</code> must contain the length, and
 <code>fadvise_advice</code> must contain the advice associated with the operation. See also <code>posix_fadvise(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_MADVISE"><code>OP_MADVISE</code></a> - 
 Issue the equivalent of a <code>madvise(2)</code> system call.
 
 <p><code>addr</code> must contain the address to operate on, <code>len</code> must contain the length on which to operate, and <code>fadvise_advice</code> must
 contain the advice associated with the operation. See also <code>madvise(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SEND"><code>OP_SEND</code></a> - 
 Issue the equivalent of a <code>send(2)</code> system call.
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. See also <code>send(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_RECV"><code>OP_RECV</code></a> - 
 Works just like <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, except for <code>recv(2)</code> instead. See the description of <code>IORING_OP_SEND</code>.
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_OPENAT2"><code>OP_OPENAT2</code></a> - 
 Issue the equivalent of a <code>openat2(2)</code> system call.
 
 <p><code>fd</code> is the <code>dirfd</code> argument, <code>addr</code> must contain a pointer to the <code>*pathname</code> argument, <code>len</code> should contain the
 size of the <code>open_how</code> structure, and <code>off</code> should be set to the address of the <code>open_how</code> structure. See also <code>openat2(2)</code>
 for the general description of the related system call.</p>
 
 <p>Available since 5.6.</p>
 
 <p>If the <code>file_index</code> field is set to a positive number, the file won't be installed into the normal file table as usual but will be placed
 into the fixed file table at index <code>file_index - 1</code>. In this case, instead of returning a file descriptor, the result will contain either 0
 on success or an error. If there is already a file registered at this index, the request will fail with <code>-EBADF</code>. Only <code>io_uring</code> has
 access to such files and no other syscall can use them. See <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> and <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_EPOLL_CTL"><code>OP_EPOLL_CTL</code></a> - 
 Add, remove or modify entries in the interest list of <code>epoll(7)</code>. See <code>epoll_ctl(2)</code> for details of the system call.
 
 <p><code>fd</code> holds the file descriptor that represents the epoll instance, <code>addr</code> holds the file descriptor to add, remove or modify,
 <code>len</code> holds the operation (<code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_DEL</code>, <code>EPOLL_CTL_MOD</code>) to perform and, <code>off</code> holds a pointer
 to the <code>epoll_events</code> structure.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_OP_SPLICE"><code>OP_SPLICE</code></a> - 
 Issue the equivalent of a <code>splice(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>splice_off_in</code> is an offset to read from, <code>fd</code> is the file descriptor to
 write to, <code>off</code> is an offset from which to start writing to. A sentinel value of -1 is used to pass the equivalent of a <code>NULL</code> for the offsets
 to <code>splice(2)</code>. <code>len</code> contains the number of bytes to copy. <code>splice_flags</code> contains a bit mask for the flag field associated with
 the system call. Please note that one of the file descriptors must refer to a pipe. See also <code>splice(2)</code> for the general description of the
 related system call.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a> - 
 This command allows an application to register a group of buffers to be used by commands that read/receive data.
 
 <p>Using buffers in this manner can eliminate the need to separate the poll + read, which provides a convenient point in time to allocate a buffer for
 a given request. It's often infeasible to have as many buffers available as pending reads or receive. With this feature, the application can have
 its pool of buffers ready in the kernel, and when the file or socket is ready to read/receive data, a buffer can be selected for the operation.</p>
 
 <p><code>fd</code> must contain the number of buffers to provide, <code>addr</code> must contain the starting address to add buffers from, <code>len</code> must
 contain the length of each buffer to add from the range, <code>buf_group</code> must contain the group ID of this range of buffers, and <code>off</code> must
 contain the starting buffer ID of this range of buffers. With that set, the kernel adds buffers starting with the memory address in <code>addr</code>,
 each with a length of <code>len</code>. Hence the application should provide <code>len * fd</code> worth of memory in <code>addr</code>. Buffers are grouped by
 the group ID, and each buffer within this group will be identical in size according to the above arguments. This allows the application to provide
 different groups of buffers, and this is often used to have differently sized buffers available depending on what the expectations are of the
 individual request. When submitting a request that should use a provided buffer, the <a href="#IOSQE_BUFFER_SELECT"><code>IOSQE_BUFFER_SELECT</code></a> flag must be set, and <code>buf_group</code>
 must be set to the desired buffer group ID where the buffer should be selected from.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_REMOVE_BUFFERS"><code>OP_REMOVE_BUFFERS</code></a> - 
 Remove buffers previously registered with <a href="#IORING_OP_PROVIDE_BUFFERS"><code>OP_PROVIDE_BUFFERS</code></a>.
 
 <p><code>fd</code> must contain the number of buffers to remove, and <code>buf_group</code> must contain the buffer group ID from which to remove the buffers.</p>
 
 <p>Available since 5.7.</p>
 </li>
 <li><a href="#IORING_OP_TEE"><code>OP_TEE</code></a> - 
 Issue the equivalent of a <code>tee(2)</code> system call.
 
 <p><code>splice_fd_in</code> is the file descriptor to read from, <code>fd</code> is the file descriptor to write to, <code>len</code> contains the number of bytes
 to copy, and <code>splice_flags</code> contains a bit mask for the flag field associated with the system call. Please note that both of the file
 descriptors must refer to a pipe. See also <code>tee(2)</code> for the general description of the related system call.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_OP_SHUTDOWN"><code>OP_SHUTDOWN</code></a> - 
 Issue the equivalent of a <code>shutdown(2)</code> system call.
 
 <p><code>fd</code> is the file descriptor to the socket being shutdown and <code>len</code> must be set to the <code>how</code> argument. No other fields should be
 set.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_RENAMEAT"><code>OP_RENAMEAT</code></a> - 
 Issue the equivalent of a <code>renameat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>addr2</code> should be set to the <code>newpath</code>, and finally
 <code>rename_flags</code> should be set to the <code>flags</code> passed in to <code>renameat2(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_UNLINKAT"><code>OP_UNLINKAT</code></a> - 
 Issue the equivalent of a <code>unlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>unlink_flags</code> should be set to the
 <code>flags</code> being passed in to <code>unlinkat(2)</code>.</p>
 
 <p>Available since 5.11.</p>
 </li>
 <li><a href="#IORING_OP_MKDIRAT"><code>OP_MKDIRAT</code></a> - 
 Issue the equivalent of a <code>mkdirat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>dirfd</code>, <code>addr</code> should be set to the <code>pathname</code>, and <code>len</code> should be set to the
 <code>mode</code> being passed in to <code>mkdirat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_SYMLINKAT"><code>OP_SYMLINKAT</code></a> - 
 Issue the equivalent of a <code>symlinkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>newdirfd</code>, <code>addr</code> should be set to the <code>target</code> and <code>addr2</code> should be set to the
 <code>linkpath</code> being passed in to <code>symlinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_LINKAT"><code>OP_LINKAT</code></a> - 
 Issue the equivalent of a <code>linkat2(2)</code> system call.
 
 <p><code>fd</code> should be set to the <code>olddirfd</code>, <code>addr</code> should be set to the <code>oldpath</code>, <code>len</code> should be set to the
 <code>newdirfd</code>, <code>addr2</code> should be set to the <code>newpath</code>, and <code>hardlink_flags</code> should be set to the <code>flags</code> being passed in
 <code>tolinkat(2)</code>.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> - 
 Send a message to an io_uring.
 
 <p><code>fd</code> must be set to a file descriptor of a ring that the application has access to, <code>len</code> can be set to any 32-bit value that the
 application wishes to pass on, and <code>off</code> should be set any 64-bit value that the application wishes to send. On the target ring, a CQE will
 be posted with the <code>res</code> field matching the <code>len</code> set, and a <code>user_data</code> field matching the <code>off</code> value being passed in.
 This request type can be used to either just wake or interrupt anyone waiting for completions on the target ring, or it can be used to pass
 messages via the two fields.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_OP_FSETXATTR"><code>OP_FSETXATTR</code></a></li>
 <li><a href="#IORING_OP_SETXATTR"><code>OP_SETXATTR</code></a></li>
 <li><a href="#IORING_OP_FGETXATTR"><code>OP_FGETXATTR</code></a></li>
 <li><a href="#IORING_OP_GETXATTR"><code>OP_GETXATTR</code></a></li>
 <li><a href="#IORING_OP_SOCKET"><code>OP_SOCKET</code></a></li>
 <li><a href="#IORING_OP_URING_CMD"><code>OP_URING_CMD</code></a></li>
 <li><a href="#IORING_OP_SEND_ZC"><code>OP_SEND_ZC</code></a> - 
 Issue the zerocopy equivalent of a <code>send(2)</code> system call.
 
 <p>Similar to <a href="#IORING_OP_SEND"><code>OP_SEND</code></a>, but tries to avoid making intermediate copies of data. Zerocopy execution is not guaranteed and it may fall back to copying.</p>
 
 <p>The <code>flags</code> field of the first <code>"struct io_uring_cqe"</code> may likely contain <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a>, which means that there will be a second
 completion event / notification for the request, with the <code>user_data</code> field set to the same value. The user must not modify the data buffer
 until the notification is posted. The first cqe follows the usual rules and so its <code>res</code> field will contain the number of bytes sent or a
 negative error code. The notification's <code>res</code> field will be set to zero and the <code>flags</code> field will contain <a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a>. The two step
 model is needed because the kernel may hold on to buffers for a long time, e.g. waiting for a TCP ACK, and having a separate cqe for request
 completions allows userspace to push more data without extra delays. Note, notifications are only responsible for controlling the lifetime of the
 buffers, and as such don't mean anything about whether the data has atually been sent out or received by the other end.</p>
 
 <p><code>fd</code> must be set to the socket file descriptor, <code>addr</code> must contain a pointer to the buffer, <code>len</code> denotes the length of the
 buffer to send, and <code>msg_flags</code> holds the flags associated with the system call. When <code>addr2</code> is non-zero it points to the address of
 the target with <code>addr_len</code> specifying its size, turning the request into a <code>sendto(2)</code> system call equivalent.</p>
 
 <p>Available since 6.0.</p>
 </li>
 <li><a href="#IORING_OP_LAST"><code>OP_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OP_LAST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FSYNC_DATASYNC">
<h3>IORING_FSYNC_DATASYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FSYNC_DATASYNC</span></div>
<div class="block"><code>sqe-&gt;fsync_flags</code></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FSYNC_DATASYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_TIMEOUT_ABS">
<h3>IORING_TIMEOUT_ABS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_TIMEOUT_ABS</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_TIMEOUT_ABS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_TIMEOUT_UPDATE">
<h3>IORING_TIMEOUT_UPDATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_TIMEOUT_UPDATE</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_TIMEOUT_UPDATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_TIMEOUT_BOOTTIME">
<h3>IORING_TIMEOUT_BOOTTIME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_TIMEOUT_BOOTTIME</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_TIMEOUT_BOOTTIME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_TIMEOUT_REALTIME">
<h3>IORING_TIMEOUT_REALTIME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_TIMEOUT_REALTIME</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_TIMEOUT_REALTIME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_LINK_TIMEOUT_UPDATE">
<h3>IORING_LINK_TIMEOUT_UPDATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_LINK_TIMEOUT_UPDATE</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_LINK_TIMEOUT_UPDATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_TIMEOUT_ETIME_SUCCESS">
<h3>IORING_TIMEOUT_ETIME_SUCCESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_TIMEOUT_ETIME_SUCCESS</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_TIMEOUT_ETIME_SUCCESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_TIMEOUT_CLOCK_MASK">
<h3>IORING_TIMEOUT_CLOCK_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_TIMEOUT_CLOCK_MASK</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_TIMEOUT_CLOCK_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_TIMEOUT_UPDATE_MASK">
<h3>IORING_TIMEOUT_UPDATE_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_TIMEOUT_UPDATE_MASK</span></div>
<div class="block"><code>sqe-&gt;timeout_flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_TIMEOUT_ABS"><code>TIMEOUT_ABS</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE"><code>TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_BOOTTIME"><code>TIMEOUT_BOOTTIME</code></a></li>
 <li><a href="#IORING_TIMEOUT_REALTIME"><code>TIMEOUT_REALTIME</code></a></li>
 <li><a href="#IORING_LINK_TIMEOUT_UPDATE"><code>LINK_TIMEOUT_UPDATE</code></a></li>
 <li><a href="#IORING_TIMEOUT_ETIME_SUCCESS"><code>TIMEOUT_ETIME_SUCCESS</code></a></li>
 <li><a href="#IORING_TIMEOUT_CLOCK_MASK"><code>TIMEOUT_CLOCK_MASK</code></a></li>
 <li><a href="#IORING_TIMEOUT_UPDATE_MASK"><code>TIMEOUT_UPDATE_MASK</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_TIMEOUT_UPDATE_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SPLICE_F_FD_IN_FIXED">
<h3>IORING_SPLICE_F_FD_IN_FIXED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SPLICE_F_FD_IN_FIXED</span></div>
<div class="block"><code>sqe-&gt;splice_flags</code>, extends <code>splice(2)</code> flags</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SPLICE_F_FD_IN_FIXED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_POLL_ADD_MULTI">
<h3>IORING_POLL_ADD_MULTI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_POLL_ADD_MULTI</span></div>
<div class="block"><code>POLL_ADD</code> flags. Note that since <code>sqe-&gt;poll_events</code> is the flag space, the command flags for <code>POLL_ADD</code> are stored in
 <code>sqe-&gt;len</code>.
 
 <p><code>IORING_POLL_UPDATE</code>: Update existing poll request, matching <code>sqe-&gt;addr</code> as the old <code>user_data</code> field.</p>
 
 <p><code>IORING_POLL_LEVEL</code>: Level triggered poll.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> - Multishot poll. Sets <code>IORING_CQE_F_MORE</code> if the poll handler will continue to report CQEs on behalf of the same SQE.</li>
 <li><a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a></li>
 <li><a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a></li>
 <li><a href="#IORING_POLL_ADD_LEVEL"><code>POLL_ADD_LEVEL</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_POLL_ADD_MULTI">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_POLL_UPDATE_EVENTS">
<h3>IORING_POLL_UPDATE_EVENTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_POLL_UPDATE_EVENTS</span></div>
<div class="block"><code>POLL_ADD</code> flags. Note that since <code>sqe-&gt;poll_events</code> is the flag space, the command flags for <code>POLL_ADD</code> are stored in
 <code>sqe-&gt;len</code>.
 
 <p><code>IORING_POLL_UPDATE</code>: Update existing poll request, matching <code>sqe-&gt;addr</code> as the old <code>user_data</code> field.</p>
 
 <p><code>IORING_POLL_LEVEL</code>: Level triggered poll.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> - Multishot poll. Sets <code>IORING_CQE_F_MORE</code> if the poll handler will continue to report CQEs on behalf of the same SQE.</li>
 <li><a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a></li>
 <li><a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a></li>
 <li><a href="#IORING_POLL_ADD_LEVEL"><code>POLL_ADD_LEVEL</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_POLL_UPDATE_EVENTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_POLL_UPDATE_USER_DATA">
<h3>IORING_POLL_UPDATE_USER_DATA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_POLL_UPDATE_USER_DATA</span></div>
<div class="block"><code>POLL_ADD</code> flags. Note that since <code>sqe-&gt;poll_events</code> is the flag space, the command flags for <code>POLL_ADD</code> are stored in
 <code>sqe-&gt;len</code>.
 
 <p><code>IORING_POLL_UPDATE</code>: Update existing poll request, matching <code>sqe-&gt;addr</code> as the old <code>user_data</code> field.</p>
 
 <p><code>IORING_POLL_LEVEL</code>: Level triggered poll.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> - Multishot poll. Sets <code>IORING_CQE_F_MORE</code> if the poll handler will continue to report CQEs on behalf of the same SQE.</li>
 <li><a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a></li>
 <li><a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a></li>
 <li><a href="#IORING_POLL_ADD_LEVEL"><code>POLL_ADD_LEVEL</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_POLL_UPDATE_USER_DATA">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_POLL_ADD_LEVEL">
<h3>IORING_POLL_ADD_LEVEL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_POLL_ADD_LEVEL</span></div>
<div class="block"><code>POLL_ADD</code> flags. Note that since <code>sqe-&gt;poll_events</code> is the flag space, the command flags for <code>POLL_ADD</code> are stored in
 <code>sqe-&gt;len</code>.
 
 <p><code>IORING_POLL_UPDATE</code>: Update existing poll request, matching <code>sqe-&gt;addr</code> as the old <code>user_data</code> field.</p>
 
 <p><code>IORING_POLL_LEVEL</code>: Level triggered poll.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_POLL_ADD_MULTI"><code>POLL_ADD_MULTI</code></a> - Multishot poll. Sets <code>IORING_CQE_F_MORE</code> if the poll handler will continue to report CQEs on behalf of the same SQE.</li>
 <li><a href="#IORING_POLL_UPDATE_EVENTS"><code>POLL_UPDATE_EVENTS</code></a></li>
 <li><a href="#IORING_POLL_UPDATE_USER_DATA"><code>POLL_UPDATE_USER_DATA</code></a></li>
 <li><a href="#IORING_POLL_ADD_LEVEL"><code>POLL_ADD_LEVEL</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_POLL_ADD_LEVEL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ASYNC_CANCEL_ALL">
<h3>IORING_ASYNC_CANCEL_ALL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ASYNC_CANCEL_ALL</span></div>
<div class="block"><code>ASYNC_CANCEL</code> flags.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ASYNC_CANCEL_ALL"><code>ASYNC_CANCEL_ALL</code></a> - 
 Cancel all requests that match the given criteria, rather than just canceling the first one found.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD"><code>ASYNC_CANCEL_FD</code></a> - 
 Match based on the file descriptor used in the original request rather than the <code>user_data</code>.
 
 <p>This is what <a href="LibURing.html#io_uring_prep_cancel_fd(org.lwjgl.system.linux.liburing.IOURingSQE,int,int)"><code>prep_cancel_fd</code></a> sets up.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_ANY"><code>ASYNC_CANCEL_ANY</code></a> - 
 Match any request in the ring, regardless of <code>user_data</code> or file descriptor.
 
 <p>Can be used to cancel any pending request in the ring.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD_FIXED"><code>ASYNC_CANCEL_FD_FIXED</code></a> - <code>fd</code> passed in is a fixed descriptor</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ASYNC_CANCEL_ALL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ASYNC_CANCEL_FD">
<h3>IORING_ASYNC_CANCEL_FD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ASYNC_CANCEL_FD</span></div>
<div class="block"><code>ASYNC_CANCEL</code> flags.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ASYNC_CANCEL_ALL"><code>ASYNC_CANCEL_ALL</code></a> - 
 Cancel all requests that match the given criteria, rather than just canceling the first one found.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD"><code>ASYNC_CANCEL_FD</code></a> - 
 Match based on the file descriptor used in the original request rather than the <code>user_data</code>.
 
 <p>This is what <a href="LibURing.html#io_uring_prep_cancel_fd(org.lwjgl.system.linux.liburing.IOURingSQE,int,int)"><code>prep_cancel_fd</code></a> sets up.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_ANY"><code>ASYNC_CANCEL_ANY</code></a> - 
 Match any request in the ring, regardless of <code>user_data</code> or file descriptor.
 
 <p>Can be used to cancel any pending request in the ring.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD_FIXED"><code>ASYNC_CANCEL_FD_FIXED</code></a> - <code>fd</code> passed in is a fixed descriptor</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ASYNC_CANCEL_FD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ASYNC_CANCEL_ANY">
<h3>IORING_ASYNC_CANCEL_ANY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ASYNC_CANCEL_ANY</span></div>
<div class="block"><code>ASYNC_CANCEL</code> flags.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ASYNC_CANCEL_ALL"><code>ASYNC_CANCEL_ALL</code></a> - 
 Cancel all requests that match the given criteria, rather than just canceling the first one found.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD"><code>ASYNC_CANCEL_FD</code></a> - 
 Match based on the file descriptor used in the original request rather than the <code>user_data</code>.
 
 <p>This is what <a href="LibURing.html#io_uring_prep_cancel_fd(org.lwjgl.system.linux.liburing.IOURingSQE,int,int)"><code>prep_cancel_fd</code></a> sets up.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_ANY"><code>ASYNC_CANCEL_ANY</code></a> - 
 Match any request in the ring, regardless of <code>user_data</code> or file descriptor.
 
 <p>Can be used to cancel any pending request in the ring.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD_FIXED"><code>ASYNC_CANCEL_FD_FIXED</code></a> - <code>fd</code> passed in is a fixed descriptor</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ASYNC_CANCEL_ANY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ASYNC_CANCEL_FD_FIXED">
<h3>IORING_ASYNC_CANCEL_FD_FIXED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ASYNC_CANCEL_FD_FIXED</span></div>
<div class="block"><code>ASYNC_CANCEL</code> flags.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ASYNC_CANCEL_ALL"><code>ASYNC_CANCEL_ALL</code></a> - 
 Cancel all requests that match the given criteria, rather than just canceling the first one found.
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD"><code>ASYNC_CANCEL_FD</code></a> - 
 Match based on the file descriptor used in the original request rather than the <code>user_data</code>.
 
 <p>This is what <a href="LibURing.html#io_uring_prep_cancel_fd(org.lwjgl.system.linux.liburing.IOURingSQE,int,int)"><code>prep_cancel_fd</code></a> sets up.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_ANY"><code>ASYNC_CANCEL_ANY</code></a> - 
 Match any request in the ring, regardless of <code>user_data</code> or file descriptor.
 
 <p>Can be used to cancel any pending request in the ring.</p>
 
 <p>Available since 5.19.</p>
 </li>
 <li><a href="#IORING_ASYNC_CANCEL_FD_FIXED"><code>ASYNC_CANCEL_FD_FIXED</code></a> - <code>fd</code> passed in is a fixed descriptor</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ASYNC_CANCEL_FD_FIXED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RECVSEND_POLL_FIRST">
<h3>IORING_RECVSEND_POLL_FIRST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RECVSEND_POLL_FIRST</span></div>
<div class="block"><code>send/sendmsg</code> and <code>recv/recvmsg</code> flags (<code>sqe-&gt;ioprio</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RECVSEND_POLL_FIRST"><code>RECVSEND_POLL_FIRST</code></a> - 
 If set, io_uring will assume the socket is currently empty and attempting to receive data will be unsuccessful.
 
 <p>For this case, io_uring will arm internal poll and trigger a receive of the data when the socket has data to be read. This initial receive attempt
 can be wasteful for the case where the socket is expected to be empty, setting this flag will bypass the initial receive attempt and go straight to
 arming poll. If poll does indicate that data is ready to be received, the operation will proceed.</p>
 
 <p>Can be used with the CQE <a href="#IORING_CQE_F_SOCK_NONEMPTY"><code>CQE_F_SOCK_NONEMPTY</code></a> flag, which io_uring will set on CQEs after a <code>recv(2)</code> or <code>recvmsg(2)</code> operation. If
 set, the socket still had data to be read after the operation completed.</p>
 
 <p>Both these flags are available since 5.19.</p>
 </li>
 <li><a href="#IORING_RECV_MULTISHOT"><code>RECV_MULTISHOT</code></a> - 
 Multishot <code>recv</code>.
 
 <p>Sets <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a> if the handler will continue to report CQEs on behalf of the same SQE.</p>
 </li>
 <li><a href="#IORING_RECVSEND_FIXED_BUF"><code>RECVSEND_FIXED_BUF</code></a> - Use registered buffers, the index is stored in the <code>buf_index</code> field.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RECVSEND_POLL_FIRST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RECV_MULTISHOT">
<h3>IORING_RECV_MULTISHOT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RECV_MULTISHOT</span></div>
<div class="block"><code>send/sendmsg</code> and <code>recv/recvmsg</code> flags (<code>sqe-&gt;ioprio</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RECVSEND_POLL_FIRST"><code>RECVSEND_POLL_FIRST</code></a> - 
 If set, io_uring will assume the socket is currently empty and attempting to receive data will be unsuccessful.
 
 <p>For this case, io_uring will arm internal poll and trigger a receive of the data when the socket has data to be read. This initial receive attempt
 can be wasteful for the case where the socket is expected to be empty, setting this flag will bypass the initial receive attempt and go straight to
 arming poll. If poll does indicate that data is ready to be received, the operation will proceed.</p>
 
 <p>Can be used with the CQE <a href="#IORING_CQE_F_SOCK_NONEMPTY"><code>CQE_F_SOCK_NONEMPTY</code></a> flag, which io_uring will set on CQEs after a <code>recv(2)</code> or <code>recvmsg(2)</code> operation. If
 set, the socket still had data to be read after the operation completed.</p>
 
 <p>Both these flags are available since 5.19.</p>
 </li>
 <li><a href="#IORING_RECV_MULTISHOT"><code>RECV_MULTISHOT</code></a> - 
 Multishot <code>recv</code>.
 
 <p>Sets <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a> if the handler will continue to report CQEs on behalf of the same SQE.</p>
 </li>
 <li><a href="#IORING_RECVSEND_FIXED_BUF"><code>RECVSEND_FIXED_BUF</code></a> - Use registered buffers, the index is stored in the <code>buf_index</code> field.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RECV_MULTISHOT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RECVSEND_FIXED_BUF">
<h3>IORING_RECVSEND_FIXED_BUF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RECVSEND_FIXED_BUF</span></div>
<div class="block"><code>send/sendmsg</code> and <code>recv/recvmsg</code> flags (<code>sqe-&gt;ioprio</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RECVSEND_POLL_FIRST"><code>RECVSEND_POLL_FIRST</code></a> - 
 If set, io_uring will assume the socket is currently empty and attempting to receive data will be unsuccessful.
 
 <p>For this case, io_uring will arm internal poll and trigger a receive of the data when the socket has data to be read. This initial receive attempt
 can be wasteful for the case where the socket is expected to be empty, setting this flag will bypass the initial receive attempt and go straight to
 arming poll. If poll does indicate that data is ready to be received, the operation will proceed.</p>
 
 <p>Can be used with the CQE <a href="#IORING_CQE_F_SOCK_NONEMPTY"><code>CQE_F_SOCK_NONEMPTY</code></a> flag, which io_uring will set on CQEs after a <code>recv(2)</code> or <code>recvmsg(2)</code> operation. If
 set, the socket still had data to be read after the operation completed.</p>
 
 <p>Both these flags are available since 5.19.</p>
 </li>
 <li><a href="#IORING_RECV_MULTISHOT"><code>RECV_MULTISHOT</code></a> - 
 Multishot <code>recv</code>.
 
 <p>Sets <a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a> if the handler will continue to report CQEs on behalf of the same SQE.</p>
 </li>
 <li><a href="#IORING_RECVSEND_FIXED_BUF"><code>RECVSEND_FIXED_BUF</code></a> - Use registered buffers, the index is stored in the <code>buf_index</code> field.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RECVSEND_FIXED_BUF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ACCEPT_MULTISHOT">
<h3>IORING_ACCEPT_MULTISHOT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ACCEPT_MULTISHOT</span></div>
<div class="block">Accept flags stored in <code>sqe-&gt;ioprio</code></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ACCEPT_MULTISHOT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_MSG_DATA">
<h3>IORING_MSG_DATA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_MSG_DATA</span></div>
<div class="block"><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> command types, stored in <code>sqe-&gt;addr</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_MSG_DATA"><code>MSG_DATA</code></a> - pass <code>sqe-&gt;len</code> as <code>res</code> and <code>off</code> as <code>user_data</code></li>
 <li><a href="#IORING_MSG_SEND_FD"><code>MSG_SEND_FD</code></a> - send a registered fd to another ring</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_MSG_DATA">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_MSG_SEND_FD">
<h3>IORING_MSG_SEND_FD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_MSG_SEND_FD</span></div>
<div class="block"><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> command types, stored in <code>sqe-&gt;addr</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_MSG_DATA"><code>MSG_DATA</code></a> - pass <code>sqe-&gt;len</code> as <code>res</code> and <code>off</code> as <code>user_data</code></li>
 <li><a href="#IORING_MSG_SEND_FD"><code>MSG_SEND_FD</code></a> - send a registered fd to another ring</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_MSG_SEND_FD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_MSG_RING_CQE_SKIP">
<h3>IORING_MSG_RING_CQE_SKIP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_MSG_RING_CQE_SKIP</span></div>
<div class="block"><a href="#IORING_OP_MSG_RING"><code>OP_MSG_RING</code></a> flags (<code>sqe-&gt;msg_ring_flags</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_MSG_RING_CQE_SKIP"><code>MSG_RING_CQE_SKIP</code></a> - Don't post a CQE to the target ring. Not applicable for <a href="#IORING_MSG_DATA"><code>MSG_DATA</code></a>, obviously.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_MSG_RING_CQE_SKIP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_CQE_F_BUFFER">
<h3>IORING_CQE_F_BUFFER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_CQE_F_BUFFER</span></div>
<div class="block"><code>cqe-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> - If set, the upper 16 bits are the buffer ID</li>
 <li><a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a> - If set, parent SQE will generate more CQE entries</li>
 <li><a href="#IORING_CQE_F_SOCK_NONEMPTY"><code>CQE_F_SOCK_NONEMPTY</code></a> - If set, more data to read after socket <code>recv</code>.</li>
 <li><a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a> - Set for notification CQEs. Can be used to distinct them from sends.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_CQE_F_BUFFER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_CQE_F_MORE">
<h3>IORING_CQE_F_MORE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_CQE_F_MORE</span></div>
<div class="block"><code>cqe-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> - If set, the upper 16 bits are the buffer ID</li>
 <li><a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a> - If set, parent SQE will generate more CQE entries</li>
 <li><a href="#IORING_CQE_F_SOCK_NONEMPTY"><code>CQE_F_SOCK_NONEMPTY</code></a> - If set, more data to read after socket <code>recv</code>.</li>
 <li><a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a> - Set for notification CQEs. Can be used to distinct them from sends.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_CQE_F_MORE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_CQE_F_SOCK_NONEMPTY">
<h3>IORING_CQE_F_SOCK_NONEMPTY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_CQE_F_SOCK_NONEMPTY</span></div>
<div class="block"><code>cqe-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> - If set, the upper 16 bits are the buffer ID</li>
 <li><a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a> - If set, parent SQE will generate more CQE entries</li>
 <li><a href="#IORING_CQE_F_SOCK_NONEMPTY"><code>CQE_F_SOCK_NONEMPTY</code></a> - If set, more data to read after socket <code>recv</code>.</li>
 <li><a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a> - Set for notification CQEs. Can be used to distinct them from sends.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_CQE_F_SOCK_NONEMPTY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_CQE_F_NOTIF">
<h3>IORING_CQE_F_NOTIF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_CQE_F_NOTIF</span></div>
<div class="block"><code>cqe-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_CQE_F_BUFFER"><code>CQE_F_BUFFER</code></a> - If set, the upper 16 bits are the buffer ID</li>
 <li><a href="#IORING_CQE_F_MORE"><code>CQE_F_MORE</code></a> - If set, parent SQE will generate more CQE entries</li>
 <li><a href="#IORING_CQE_F_SOCK_NONEMPTY"><code>CQE_F_SOCK_NONEMPTY</code></a> - If set, more data to read after socket <code>recv</code>.</li>
 <li><a href="#IORING_CQE_F_NOTIF"><code>CQE_F_NOTIF</code></a> - Set for notification CQEs. Can be used to distinct them from sends.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_CQE_F_NOTIF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_CQE_BUFFER_SHIFT">
<h3>IORING_CQE_BUFFER_SHIFT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_CQE_BUFFER_SHIFT</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_CQE_BUFFER_SHIFT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OFF_SQ_RING">
<h3>IORING_OFF_SQ_RING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">IORING_OFF_SQ_RING</span></div>
<div class="block">Magic offsets for the application to <code>mmap</code> the data it needs</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OFF_SQ_RING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OFF_CQ_RING">
<h3>IORING_OFF_CQ_RING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">IORING_OFF_CQ_RING</span></div>
<div class="block">Magic offsets for the application to <code>mmap</code> the data it needs</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OFF_CQ_RING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_OFF_SQES">
<h3>IORING_OFF_SQES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">IORING_OFF_SQES</span></div>
<div class="block">Magic offsets for the application to <code>mmap</code> the data it needs</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_OFF_SQES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SQ_NEED_WAKEUP">
<h3>IORING_SQ_NEED_WAKEUP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SQ_NEED_WAKEUP</span></div>
<div class="block"><code>sq_ring-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> - needs <code>io_uring_enter</code> wakeup</li>
 <li><a href="#IORING_SQ_CQ_OVERFLOW"><code>SQ_CQ_OVERFLOW</code></a> - CQ ring is overflown</li>
 <li><a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a> - task should enter the kernel</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SQ_NEED_WAKEUP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SQ_CQ_OVERFLOW">
<h3>IORING_SQ_CQ_OVERFLOW</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SQ_CQ_OVERFLOW</span></div>
<div class="block"><code>sq_ring-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> - needs <code>io_uring_enter</code> wakeup</li>
 <li><a href="#IORING_SQ_CQ_OVERFLOW"><code>SQ_CQ_OVERFLOW</code></a> - CQ ring is overflown</li>
 <li><a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a> - task should enter the kernel</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SQ_CQ_OVERFLOW">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_SQ_TASKRUN">
<h3>IORING_SQ_TASKRUN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_SQ_TASKRUN</span></div>
<div class="block"><code>sq_ring-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_SQ_NEED_WAKEUP"><code>SQ_NEED_WAKEUP</code></a> - needs <code>io_uring_enter</code> wakeup</li>
 <li><a href="#IORING_SQ_CQ_OVERFLOW"><code>SQ_CQ_OVERFLOW</code></a> - CQ ring is overflown</li>
 <li><a href="#IORING_SQ_TASKRUN"><code>SQ_TASKRUN</code></a> - task should enter the kernel</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_SQ_TASKRUN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_CQ_EVENTFD_DISABLED">
<h3>IORING_CQ_EVENTFD_DISABLED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_CQ_EVENTFD_DISABLED</span></div>
<div class="block"><code>cq_ring-&gt;flags</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> - disable <code>eventfd</code> notifications</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_CQ_EVENTFD_DISABLED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ENTER_GETEVENTS">
<h3>IORING_ENTER_GETEVENTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ENTER_GETEVENTS</span></div>
<div class="block"><code>io_uring_enter(2)</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> - 
 If this flag is set, then the system call will wait for the specificied number of events in <code>min_complete</code> before returning.
 
 <p>This flag can be set along with <code>to_submit</code> to both submit and complete events in a single system call.</p>
 </li>
 <li><a href="#IORING_ENTER_SQ_WAKEUP"><code>ENTER_SQ_WAKEUP</code></a> - If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then this flag asks the kernel to wakeup the SQ kernel thread to submit IO.</li>
 <li><a href="#IORING_ENTER_SQ_WAIT"><code>ENTER_SQ_WAIT</code></a> - 
 If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then the application has no real insight into when the SQ kernel thread has consumed entries from
 the SQ ring. This can lead to a situation where the application can no longer get a free SQE entry to submit, without knowing when it one becomes
 available as the SQ kernel thread consumes them. If the system call is used with this flag set, then it will wait until at least one entry is free
 in the SQ ring.
 </li>
 <li><a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> - 
 Since kernel 5.11, the system calls arguments have been modified to look like the following:
 
 <pre><code>
 int io_uring_enter(unsigned int fd, unsigned int to_submit,
                    unsigned int min_complete, unsigned int flags,
                    const void *arg, size_t argsz);</code></pre>
 
 <p>which is behaves just like the original definition by default. However, if <code>IORING_ENTER_EXT_ARG</code> is set, then instead of a <code>sigset_t</code>
 being passed in, a pointer to a struct <code>io_uring_getevents_arg</code> is used instead and <code>argsz</code> must be set to the size of this structure.</p>
 
 <p>The definition is <a href="IOURingGeteventsArg.html" title="class in org.lwjgl.system.linux.liburing"><code>IOURingGeteventsArg</code></a> which allows passing in both a signal mask as well as pointer to a struct <code>__kernel_timespec</code> timeout
 value. If <code>ts</code> is set to a valid pointer, then this time value indicates the timeout for waiting on events. If an application is waiting on
 events and wishes to stop waiting after a specified amount of time, then this can be accomplished directly in version 5.11 and newer by using this
 feature.</p>
 </li>
 <li><a href="#IORING_ENTER_REGISTERED_RING"><code>ENTER_REGISTERED_RING</code></a> - 
 If the ring file descriptor has been registered through use of <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>, then setting this flag will tell the kernel that the
 <code>ring_fd</code> passed in is the registered ring offset rather than a normal file descriptor.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ENTER_GETEVENTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ENTER_SQ_WAKEUP">
<h3>IORING_ENTER_SQ_WAKEUP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ENTER_SQ_WAKEUP</span></div>
<div class="block"><code>io_uring_enter(2)</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> - 
 If this flag is set, then the system call will wait for the specificied number of events in <code>min_complete</code> before returning.
 
 <p>This flag can be set along with <code>to_submit</code> to both submit and complete events in a single system call.</p>
 </li>
 <li><a href="#IORING_ENTER_SQ_WAKEUP"><code>ENTER_SQ_WAKEUP</code></a> - If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then this flag asks the kernel to wakeup the SQ kernel thread to submit IO.</li>
 <li><a href="#IORING_ENTER_SQ_WAIT"><code>ENTER_SQ_WAIT</code></a> - 
 If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then the application has no real insight into when the SQ kernel thread has consumed entries from
 the SQ ring. This can lead to a situation where the application can no longer get a free SQE entry to submit, without knowing when it one becomes
 available as the SQ kernel thread consumes them. If the system call is used with this flag set, then it will wait until at least one entry is free
 in the SQ ring.
 </li>
 <li><a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> - 
 Since kernel 5.11, the system calls arguments have been modified to look like the following:
 
 <pre><code>
 int io_uring_enter(unsigned int fd, unsigned int to_submit,
                    unsigned int min_complete, unsigned int flags,
                    const void *arg, size_t argsz);</code></pre>
 
 <p>which is behaves just like the original definition by default. However, if <code>IORING_ENTER_EXT_ARG</code> is set, then instead of a <code>sigset_t</code>
 being passed in, a pointer to a struct <code>io_uring_getevents_arg</code> is used instead and <code>argsz</code> must be set to the size of this structure.</p>
 
 <p>The definition is <a href="IOURingGeteventsArg.html" title="class in org.lwjgl.system.linux.liburing"><code>IOURingGeteventsArg</code></a> which allows passing in both a signal mask as well as pointer to a struct <code>__kernel_timespec</code> timeout
 value. If <code>ts</code> is set to a valid pointer, then this time value indicates the timeout for waiting on events. If an application is waiting on
 events and wishes to stop waiting after a specified amount of time, then this can be accomplished directly in version 5.11 and newer by using this
 feature.</p>
 </li>
 <li><a href="#IORING_ENTER_REGISTERED_RING"><code>ENTER_REGISTERED_RING</code></a> - 
 If the ring file descriptor has been registered through use of <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>, then setting this flag will tell the kernel that the
 <code>ring_fd</code> passed in is the registered ring offset rather than a normal file descriptor.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ENTER_SQ_WAKEUP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ENTER_SQ_WAIT">
<h3>IORING_ENTER_SQ_WAIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ENTER_SQ_WAIT</span></div>
<div class="block"><code>io_uring_enter(2)</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> - 
 If this flag is set, then the system call will wait for the specificied number of events in <code>min_complete</code> before returning.
 
 <p>This flag can be set along with <code>to_submit</code> to both submit and complete events in a single system call.</p>
 </li>
 <li><a href="#IORING_ENTER_SQ_WAKEUP"><code>ENTER_SQ_WAKEUP</code></a> - If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then this flag asks the kernel to wakeup the SQ kernel thread to submit IO.</li>
 <li><a href="#IORING_ENTER_SQ_WAIT"><code>ENTER_SQ_WAIT</code></a> - 
 If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then the application has no real insight into when the SQ kernel thread has consumed entries from
 the SQ ring. This can lead to a situation where the application can no longer get a free SQE entry to submit, without knowing when it one becomes
 available as the SQ kernel thread consumes them. If the system call is used with this flag set, then it will wait until at least one entry is free
 in the SQ ring.
 </li>
 <li><a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> - 
 Since kernel 5.11, the system calls arguments have been modified to look like the following:
 
 <pre><code>
 int io_uring_enter(unsigned int fd, unsigned int to_submit,
                    unsigned int min_complete, unsigned int flags,
                    const void *arg, size_t argsz);</code></pre>
 
 <p>which is behaves just like the original definition by default. However, if <code>IORING_ENTER_EXT_ARG</code> is set, then instead of a <code>sigset_t</code>
 being passed in, a pointer to a struct <code>io_uring_getevents_arg</code> is used instead and <code>argsz</code> must be set to the size of this structure.</p>
 
 <p>The definition is <a href="IOURingGeteventsArg.html" title="class in org.lwjgl.system.linux.liburing"><code>IOURingGeteventsArg</code></a> which allows passing in both a signal mask as well as pointer to a struct <code>__kernel_timespec</code> timeout
 value. If <code>ts</code> is set to a valid pointer, then this time value indicates the timeout for waiting on events. If an application is waiting on
 events and wishes to stop waiting after a specified amount of time, then this can be accomplished directly in version 5.11 and newer by using this
 feature.</p>
 </li>
 <li><a href="#IORING_ENTER_REGISTERED_RING"><code>ENTER_REGISTERED_RING</code></a> - 
 If the ring file descriptor has been registered through use of <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>, then setting this flag will tell the kernel that the
 <code>ring_fd</code> passed in is the registered ring offset rather than a normal file descriptor.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ENTER_SQ_WAIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ENTER_EXT_ARG">
<h3>IORING_ENTER_EXT_ARG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ENTER_EXT_ARG</span></div>
<div class="block"><code>io_uring_enter(2)</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> - 
 If this flag is set, then the system call will wait for the specificied number of events in <code>min_complete</code> before returning.
 
 <p>This flag can be set along with <code>to_submit</code> to both submit and complete events in a single system call.</p>
 </li>
 <li><a href="#IORING_ENTER_SQ_WAKEUP"><code>ENTER_SQ_WAKEUP</code></a> - If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then this flag asks the kernel to wakeup the SQ kernel thread to submit IO.</li>
 <li><a href="#IORING_ENTER_SQ_WAIT"><code>ENTER_SQ_WAIT</code></a> - 
 If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then the application has no real insight into when the SQ kernel thread has consumed entries from
 the SQ ring. This can lead to a situation where the application can no longer get a free SQE entry to submit, without knowing when it one becomes
 available as the SQ kernel thread consumes them. If the system call is used with this flag set, then it will wait until at least one entry is free
 in the SQ ring.
 </li>
 <li><a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> - 
 Since kernel 5.11, the system calls arguments have been modified to look like the following:
 
 <pre><code>
 int io_uring_enter(unsigned int fd, unsigned int to_submit,
                    unsigned int min_complete, unsigned int flags,
                    const void *arg, size_t argsz);</code></pre>
 
 <p>which is behaves just like the original definition by default. However, if <code>IORING_ENTER_EXT_ARG</code> is set, then instead of a <code>sigset_t</code>
 being passed in, a pointer to a struct <code>io_uring_getevents_arg</code> is used instead and <code>argsz</code> must be set to the size of this structure.</p>
 
 <p>The definition is <a href="IOURingGeteventsArg.html" title="class in org.lwjgl.system.linux.liburing"><code>IOURingGeteventsArg</code></a> which allows passing in both a signal mask as well as pointer to a struct <code>__kernel_timespec</code> timeout
 value. If <code>ts</code> is set to a valid pointer, then this time value indicates the timeout for waiting on events. If an application is waiting on
 events and wishes to stop waiting after a specified amount of time, then this can be accomplished directly in version 5.11 and newer by using this
 feature.</p>
 </li>
 <li><a href="#IORING_ENTER_REGISTERED_RING"><code>ENTER_REGISTERED_RING</code></a> - 
 If the ring file descriptor has been registered through use of <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>, then setting this flag will tell the kernel that the
 <code>ring_fd</code> passed in is the registered ring offset rather than a normal file descriptor.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ENTER_EXT_ARG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_ENTER_REGISTERED_RING">
<h3>IORING_ENTER_REGISTERED_RING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_ENTER_REGISTERED_RING</span></div>
<div class="block"><code>io_uring_enter(2)</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a> - 
 If this flag is set, then the system call will wait for the specificied number of events in <code>min_complete</code> before returning.
 
 <p>This flag can be set along with <code>to_submit</code> to both submit and complete events in a single system call.</p>
 </li>
 <li><a href="#IORING_ENTER_SQ_WAKEUP"><code>ENTER_SQ_WAKEUP</code></a> - If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then this flag asks the kernel to wakeup the SQ kernel thread to submit IO.</li>
 <li><a href="#IORING_ENTER_SQ_WAIT"><code>ENTER_SQ_WAIT</code></a> - 
 If the ring has been created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a>, then the application has no real insight into when the SQ kernel thread has consumed entries from
 the SQ ring. This can lead to a situation where the application can no longer get a free SQE entry to submit, without knowing when it one becomes
 available as the SQ kernel thread consumes them. If the system call is used with this flag set, then it will wait until at least one entry is free
 in the SQ ring.
 </li>
 <li><a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> - 
 Since kernel 5.11, the system calls arguments have been modified to look like the following:
 
 <pre><code>
 int io_uring_enter(unsigned int fd, unsigned int to_submit,
                    unsigned int min_complete, unsigned int flags,
                    const void *arg, size_t argsz);</code></pre>
 
 <p>which is behaves just like the original definition by default. However, if <code>IORING_ENTER_EXT_ARG</code> is set, then instead of a <code>sigset_t</code>
 being passed in, a pointer to a struct <code>io_uring_getevents_arg</code> is used instead and <code>argsz</code> must be set to the size of this structure.</p>
 
 <p>The definition is <a href="IOURingGeteventsArg.html" title="class in org.lwjgl.system.linux.liburing"><code>IOURingGeteventsArg</code></a> which allows passing in both a signal mask as well as pointer to a struct <code>__kernel_timespec</code> timeout
 value. If <code>ts</code> is set to a valid pointer, then this time value indicates the timeout for waiting on events. If an application is waiting on
 events and wishes to stop waiting after a specified amount of time, then this can be accomplished directly in version 5.11 and newer by using this
 feature.</p>
 </li>
 <li><a href="#IORING_ENTER_REGISTERED_RING"><code>ENTER_REGISTERED_RING</code></a> - 
 If the ring file descriptor has been registered through use of <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>, then setting this flag will tell the kernel that the
 <code>ring_fd</code> passed in is the registered ring offset rather than a normal file descriptor.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_ENTER_REGISTERED_RING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_SINGLE_MMAP">
<h3>IORING_FEAT_SINGLE_MMAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_SINGLE_MMAP</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_SINGLE_MMAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_NODROP">
<h3>IORING_FEAT_NODROP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_NODROP</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_NODROP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_SUBMIT_STABLE">
<h3>IORING_FEAT_SUBMIT_STABLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_SUBMIT_STABLE</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_SUBMIT_STABLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_RW_CUR_POS">
<h3>IORING_FEAT_RW_CUR_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_RW_CUR_POS</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_RW_CUR_POS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_CUR_PERSONALITY">
<h3>IORING_FEAT_CUR_PERSONALITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_CUR_PERSONALITY</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_CUR_PERSONALITY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_FAST_POLL">
<h3>IORING_FEAT_FAST_POLL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_FAST_POLL</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_FAST_POLL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_POLL_32BITS">
<h3>IORING_FEAT_POLL_32BITS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_POLL_32BITS</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_POLL_32BITS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_SQPOLL_NONFIXED">
<h3>IORING_FEAT_SQPOLL_NONFIXED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_SQPOLL_NONFIXED</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_SQPOLL_NONFIXED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_EXT_ARG">
<h3>IORING_FEAT_EXT_ARG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_EXT_ARG</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_EXT_ARG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_NATIVE_WORKERS">
<h3>IORING_FEAT_NATIVE_WORKERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_NATIVE_WORKERS</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_NATIVE_WORKERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_RSRC_TAGS">
<h3>IORING_FEAT_RSRC_TAGS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_RSRC_TAGS</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_RSRC_TAGS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_CQE_SKIP">
<h3>IORING_FEAT_CQE_SKIP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_CQE_SKIP</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_CQE_SKIP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_FEAT_LINKED_FILE">
<h3>IORING_FEAT_LINKED_FILE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_FEAT_LINKED_FILE</span></div>
<div class="block"><code>io_uring_params-&gt;features</code> flags
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_FEAT_SINGLE_MMAP"><code>FEAT_SINGLE_MMAP</code></a> - 
 If this flag is set, the two SQ and CQ rings can be mapped with a single <code>mmap(2)</code> call.
 
 <p>The SQEs must still be allocated separately. This brings the necessary <code>mmap(2)</code> calls down from three to two.</p>
 
 <p>Available since kernel 5.4.</p>
 </li>
 <li><a href="#IORING_FEAT_NODROP"><code>FEAT_NODROP</code></a> - 
 If this flag is set, <code>io_uring</code> supports never dropping completion events.
 
 <p>If a completion event occurs and the CQ ring is full, the kernel stores the event internally until such a time that the CQ ring has room for more
 entries. If this overflow condition is entered, attempting to submit more IO will fail with the <code>-EBUSY</code> error value, if it can't flush the
 overflown events to the CQ ring. If this happens, the application must reap events from the CQ ring and attempt the submit again.</p>
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_SUBMIT_STABLE"><code>FEAT_SUBMIT_STABLE</code></a> - 
 If this flag is set, applications can be certain that any data for async offload has been consumed when the kernel has consumed the SQE.
 
 <p>Available since kernel 5.5.</p>
 </li>
 <li><a href="#IORING_FEAT_RW_CUR_POS"><code>FEAT_RW_CUR_POS</code></a> - 
 If this flag is set, applications can specify <code>offset == -1</code> with <code>IORING_OP_{READV,WRITEV}</code>, <code>IORING_OP_{READ,WRITE}_FIXED</code>, and
 <code>IORING_OP_{READ,WRITE}</code> to mean current file position, which behaves like <code>preadv2(2)</code> and <code>pwritev2(2)</code> with
 <code>offset == -1</code>.
 
 <p>It'll use (and update) the current file position. This obviously comes with the caveat that if the application has multiple reads or writes in
 flight, then the end result will not be as expected. This is similar to threads sharing a file descriptor and doing IO using the current file
 position.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_CUR_PERSONALITY"><code>FEAT_CUR_PERSONALITY</code></a> - 
 If this flag is set, then <code>io_uring</code> guarantees that both sync and async execution of a request assumes the credentials of the task that
 called <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> to queue the requests.
 
 <p>If this flag isn't set, then requests are issued with the credentials of the task that originally registered the <code>io_uring</code>. If only one task
 is using a ring, then this flag doesn't matter as the credentials will always be the same. Note that this is the default behavior, tasks can still
 register different personalities through <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> with <a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> and specify the personality to use in the sqe.</p>
 
 <p>Available since kernel 5.6.</p>
 </li>
 <li><a href="#IORING_FEAT_FAST_POLL"><code>FEAT_FAST_POLL</code></a> - 
 If this flag is set, then <code>io_uring</code> supports using an internal poll mechanism to drive data/space readiness.
 
 <p>This means that requests that cannot read or write data to a file no longer need to be punted to an async thread for handling, instead they will
 begin operation when the file is ready. This is similar to doing poll + read/write in userspace, but eliminates the need to do so. If this flag is
 set, requests waiting on space/data consume a lot less resources doing so as they are not blocking a thread.</p>
 
 <p>Available since kernel 5.7.</p>
 </li>
 <li><a href="#IORING_FEAT_POLL_32BITS"><code>FEAT_POLL_32BITS</code></a> - 
 If this flag is set, the <a href="#IORING_OP_POLL_ADD"><code>OP_POLL_ADD</code></a> command accepts the full 32-bit range of epoll based flags.
 
 <p>Most notably <code>EPOLLEXCLUSIVE</code> which allows exclusive (waking single waiters) behavior.</p>
 
 <p>Available since kernel 5.9.</p>
 </li>
 <li><a href="#IORING_FEAT_SQPOLL_NONFIXED"><code>FEAT_SQPOLL_NONFIXED</code></a> - 
 If this flag is set, the <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> feature no longer requires the use of fixed files.
 
 <p>Any normal file descriptor can be used for IO commands without needing registration.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_EXT_ARG"><code>FEAT_EXT_ARG</code></a> - 
 If this flag is set, then the <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system call supports passing in an extended argument instead of just the <code>sigset_t</code> of earlier
 kernels.
 
 <p>This extended argument is of type <code>struct io_uring_getevents_arg</code> and allows the caller to pass in both a <code>sigset_t</code> and a timeout
 argument for waiting on events. A pointer to this struct must be passed in if <a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a> is set in the flags for the enter system call.</p>
 
 <p>Available since kernel 5.11.</p>
 </li>
 <li><a href="#IORING_FEAT_NATIVE_WORKERS"><code>FEAT_NATIVE_WORKERS</code></a> - 
 If this flag is set, <code>io_uring</code> is using native workers for its async helpers.
 
 <p>Previous kernels used kernel threads that assumed the identity of the original <code>io_uring</code> owning task, but later kernels will actively create
 what looks more like regular process threads instead.</p>
 
 <p>Available since kernel 5.12.</p>
 </li>
 <li><a href="#IORING_FEAT_RSRC_TAGS"><code>FEAT_RSRC_TAGS</code></a> - 
 If this flag is set, then <code>io_uring</code> supports a variety of features related to fixed files and buffers.
 
 <p>In particular, it indicates that registered buffers can be updated in-place, whereas before the full set would have to be unregistered first.</p>
 
 <p>Available since kernel 5.13.</p>
 </li>
 <li><a href="#IORING_FEAT_CQE_SKIP"><code>FEAT_CQE_SKIP</code></a> - 
 If this flag is set, then io_uring supports setting <a href="#IOSQE_CQE_SKIP_SUCCESS"><code>IOSQE_CQE_SKIP_SUCCESS</code></a> in the submitted SQE, indicating that no CQE should be generated for
 this SQE if it executes normally. If an error happens processing the SQE, a CQE with the appropriate error value will still be generated.
 
 <p>Available since kernel 5.17.</p>
 </li>
 <li><a href="#IORING_FEAT_LINKED_FILE"><code>FEAT_LINKED_FILE</code></a> - 
 If this flag is set, then io_uring supports sane assignment of files for SQEs that have dependencies. For example, if a chain of SQEs are submitted
 with <a href="#IOSQE_IO_LINK"><code>IOSQE_IO_LINK</code></a>, then kernels without this flag will prepare the file for each link upfront. If a previous link opens a file with a known
 index, eg if direct descriptors are used with open or accept, then file assignment needs to happen post execution of that SQE. If this flag is set,
 then the kernel will defer file assignment until execution of a given request is started.
 
 <p>Available since kernel 5.17.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_FEAT_LINKED_FILE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_BUFFERS">
<h3>IORING_REGISTER_BUFFERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_BUFFERS</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_BUFFERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_UNREGISTER_BUFFERS">
<h3>IORING_UNREGISTER_BUFFERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_UNREGISTER_BUFFERS</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_UNREGISTER_BUFFERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_FILES">
<h3>IORING_REGISTER_FILES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_FILES</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_FILES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_UNREGISTER_FILES">
<h3>IORING_UNREGISTER_FILES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_UNREGISTER_FILES</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_UNREGISTER_FILES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_EVENTFD">
<h3>IORING_REGISTER_EVENTFD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_EVENTFD</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_EVENTFD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_UNREGISTER_EVENTFD">
<h3>IORING_UNREGISTER_EVENTFD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_UNREGISTER_EVENTFD</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_UNREGISTER_EVENTFD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_FILES_UPDATE">
<h3>IORING_REGISTER_FILES_UPDATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_FILES_UPDATE</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_FILES_UPDATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_EVENTFD_ASYNC">
<h3>IORING_REGISTER_EVENTFD_ASYNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_EVENTFD_ASYNC</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_EVENTFD_ASYNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_PROBE">
<h3>IORING_REGISTER_PROBE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_PROBE</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_PROBE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_PERSONALITY">
<h3>IORING_REGISTER_PERSONALITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_PERSONALITY</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_PERSONALITY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_UNREGISTER_PERSONALITY">
<h3>IORING_UNREGISTER_PERSONALITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_UNREGISTER_PERSONALITY</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_UNREGISTER_PERSONALITY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_RESTRICTIONS">
<h3>IORING_REGISTER_RESTRICTIONS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_RESTRICTIONS</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_RESTRICTIONS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_ENABLE_RINGS">
<h3>IORING_REGISTER_ENABLE_RINGS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_ENABLE_RINGS</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_ENABLE_RINGS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_FILES2">
<h3>IORING_REGISTER_FILES2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_FILES2</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_FILES2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_FILES_UPDATE2">
<h3>IORING_REGISTER_FILES_UPDATE2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_FILES_UPDATE2</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_FILES_UPDATE2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_BUFFERS2">
<h3>IORING_REGISTER_BUFFERS2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_BUFFERS2</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_BUFFERS2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_BUFFERS_UPDATE">
<h3>IORING_REGISTER_BUFFERS_UPDATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_BUFFERS_UPDATE</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_BUFFERS_UPDATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_IOWQ_AFF">
<h3>IORING_REGISTER_IOWQ_AFF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_IOWQ_AFF</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_IOWQ_AFF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_UNREGISTER_IOWQ_AFF">
<h3>IORING_UNREGISTER_IOWQ_AFF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_UNREGISTER_IOWQ_AFF</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_UNREGISTER_IOWQ_AFF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_IOWQ_MAX_WORKERS">
<h3>IORING_REGISTER_IOWQ_MAX_WORKERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_IOWQ_MAX_WORKERS</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_IOWQ_MAX_WORKERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_RING_FDS">
<h3>IORING_REGISTER_RING_FDS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_RING_FDS</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_RING_FDS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_UNREGISTER_RING_FDS">
<h3>IORING_UNREGISTER_RING_FDS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_UNREGISTER_RING_FDS</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_UNREGISTER_RING_FDS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_PBUF_RING">
<h3>IORING_REGISTER_PBUF_RING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_PBUF_RING</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_PBUF_RING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_UNREGISTER_PBUF_RING">
<h3>IORING_UNREGISTER_PBUF_RING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_UNREGISTER_PBUF_RING</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_UNREGISTER_PBUF_RING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_SYNC_CANCEL">
<h3>IORING_REGISTER_SYNC_CANCEL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_SYNC_CANCEL</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_SYNC_CANCEL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_FILE_ALLOC_RANGE">
<h3>IORING_REGISTER_FILE_ALLOC_RANGE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_FILE_ALLOC_RANGE</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_FILE_ALLOC_RANGE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_LAST">
<h3>IORING_REGISTER_LAST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_LAST</span></div>
<div class="block"><a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcodes</code> and arguments
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> - 
 <code>arg</code> points to a struct <code>iovec</code> array of <code>nr_args</code> entries.
 
 <p>The buffers associated with the <code>iovecs</code> will be locked in memory and charged against the user's <code>RLIMIT_MEMLOCK</code> resource limit.
 See <code>getrlimit(2)</code> for more information. Additionally, there is a size limit of 1GiB per buffer. Currently, the buffers must be anonymous,
 non-file-backed memory, such as that returned by <code>malloc(3)</code> or <code>mmap(2)</code> with the <code>MAP_ANONYMOUS</code> flag set. It is expected that
 this limitation will be lifted in the future. Huge pages are supported as well. Note that the entire huge page will be pinned in the kernel, even
 if only a portion of it is used.</p>
 
 <p>After a successful call, the supplied buffers are mapped into the kernel and eligible for I/O. To make use of them, the application must specify
 the <a href="#IORING_OP_READ_FIXED"><code>OP_READ_FIXED</code></a> or <a href="#IORING_OP_WRITE_FIXED"><code>OP_WRITE_FIXED</code></a> <code>opcodes</code> in the submission queue entry (see the struct <code>io_uring_sqe</code> definition in <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a>),
 and set the <code>buf_index</code> field to the desired buffer index. The memory range described by the submission queue entry's <code>addr</code> and
 <code>len</code> fields must fall within the indexed buffer.</p>
 
 <p>It is perfectly valid to setup a large buffer and then only use part of it for an I/O, as long as the range is within the originally mapped region.</p>
 
 <p>An application can increase or decrease the size or number of registered buffers by first unregistering the existing buffers, and then issuing a
 new call to <code>io_uring_register()</code> with the new buffers.</p>
 
 <p>Note that before 5.13 registering buffers would wait for the ring to idle. If the application currently has requests in-flight, the registration
 will wait for those to finish before proceeding.</p>
 
 <p>An application need not unregister buffers explicitly before shutting down the io_uring instance.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_BUFFERS"><code>UNREGISTER_BUFFERS</code></a> - 
 This operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered buffers associated with the <code>io_uring</code> instance will be released.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a> - 
 Register files for I/O.
 
 <p><code>arg</code> contains a pointer to an array of <code>nr_args</code> file descriptors (signed 32 bit integers). To make use of the registered files, the
 <a href="#IOSQE_FIXED_FILE"><code>IOSQE_FIXED_FILE</code></a> flag must be set in the <code>flags</code> member of the struct <code>io_uring_sqe</code>, and the <code>fd</code> member is set to the index of
 the file in the file descriptor array.</p>
 
 <p>The file set may be sparse, meaning that the <code>fd</code> field in the array may be set to -1. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update files in
 place.</p>
 
 <p>Note that before 5.13 registering files would wait for the ring to idle. If the application currently has requests in-flight, the registration will
 wait for those to finish before proceeding. See <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> for how to update an existing set without that limitation.</p>
 
 <p>Files are automatically unregistered when the io_uring instance is torn down. An application needs only unregister if it wishes to register a new
 set of fds.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_FILES"><code>UNREGISTER_FILES</code></a> - 
 This operation requires no argument, and <code>arg</code> must be passed as <code>NULL</code>.
 
 <p>All previously registered files associated with the <code>io_uring</code> instance will be unregistered.</p>
 
 <p>Available since 5.1.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a> - 
 It's possible to use <code>eventfd(2)</code> to get notified of completion events on an <code>io_uring</code> instance. If this is desired, an eventfd file
 descriptor can be registered through this operation.
 
 <p><code>arg</code> must contain a pointer to the eventfd file descriptor, and <code>nr_args</code> must be 1.</p>
 
 <p>Available since 5.2.</p>
 
 <p>An application can temporarily disable notifications, coming through the registered eventfd, by setting the <a href="#IORING_CQ_EVENTFD_DISABLED"><code>CQ_EVENTFD_DISABLED</code></a> bit in the
 <code>flags</code> field of the CQ ring.</p>
 
 <p>Available since 5.8.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_EVENTFD"><code>UNREGISTER_EVENTFD</code></a> - 
 Unregister an eventfd file descriptor to stop notifications.
 
 <p>Since only one eventfd descriptor is currently supported, this operation takes no argument, and <code>arg</code> must be passed as <code>NULL</code> and
 <code>nr_args</code> must be zero.</p>
 
 <p>Available since 5.2.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a> - 
 This operation replaces existing files in the registered file set with new ones, either turning a sparse entry (one where <code>fd</code> is equal to
 -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_files_update</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update. <code>nr_args</code> must contain the number of descriptors in the passed in array.</p>
 
 <p>Available since 5.5.</p>
 
 <p>File descriptors can be skipped if they are set to <a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a>. Skipping an fd will not touch the file associated with the previous fd at
 that index.</p>
 
 <p>Available since 5.12.</p>
 </li>
 <li><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a> - 
 This works just like <a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a>, except notifications are only posted for events that complete in an async manner.
 
 <p>This means that events that complete inline while being submitted do not trigger a notification event. The arguments supplied are the same as for
 <code>IORING_REGISTER_EVENTFD</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a> - 
 This operation returns a structure, <code>io_uring_probe</code>, which contains information about the <code>opcodes</code> supported by <code>io_uring</code> on
 the running kernel.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_probe</code>, and <code>nr_args</code> must contain the size of the ops array in that probe
 struct. The <code>ops</code> array is of the type <code>io_uring_probe_op</code>, which holds the value of the <code>opcode</code> and a <code>flags</code> field. If
 the flags field has <a href="#IO_URING_OP_SUPPORTED"><code>IO_URING_OP_SUPPORTED</code></a> set, then this opcode is supported on the running kernel.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a> - 
 This operation registers credentials of the running application with <code>io_uring</code>, and returns an id associated with these credentials.
 
 <p>Applications wishing to share a ring between separate users/processes can pass in this credential id in the sqe personality field. If set, that
 particular sqe will be issued with these credentials. Must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_PERSONALITY"><code>UNREGISTER_PERSONALITY</code></a> - 
 This operation unregisters a previously registered personality with <code>io_uring</code>.
 
 <p><code>nr_args</code> must be set to the id in question, and <code>arg</code> must be set to <code>NULL</code>.</p>
 
 <p>Available since 5.6.</p>
 </li>
 <li><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a> - 
 <code>arg</code> points to a struct <code>io_uring_restriction</code> array of <code>nr_args</code> entries.
 
 <p>With an entry it is possible to allow an <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> <code>opcode</code>, or specify which <code>opcode</code> and flags of the submission queue entry are
 allowed, or require certain flags to be specified (these flags must be set on each submission queue entry).</p>
 
 <p>All the restrictions must be submitted with a single <code>io_uring_register()</code> call and they are handled as an allowlist (<code>opcodes</code> and
 flags not registered, are not allowed).</p>
 
 <p>Restrictions can be registered only if the <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> must be specified in the call to
 <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a> - 
 This operation enables an <code>io_uring</code> ring started in a disabled state (<a href="#IORING_SETUP_R_DISABLED"><code>SETUP_R_DISABLED</code></a> was specified in the call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>).
 
 <p>While the <code>io_uring</code> ring is disabled, submissions are not allowed and registrations are not restricted. After the execution of this
 operation, the <code>io_uring</code> ring is enabled: submissions and registration are allowed, but they will be validated following the registered
 restrictions (if any). This operation takes no argument, must be invoked with <code>arg</code> set to <code>NULL</code> and <code>nr_args</code> set to zero.</p>
 
 <p>Available since 5.10.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a> - 
 Register files for I/O. Similar to <a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a>.
 
 <p><code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The <code>data</code> field contains a pointer to an array of <code>nr</code> file descriptors (signed 32 bit integers). <code>tags</code> field should either be
 0 or or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for more info on resource tagging.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, don't necessarily deallocate resources, they might be held until all requests using that
 resource complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a> - 
 Similar to <a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a>, replaces existing files in the registered file set with new ones, either turning a sparse entry (one where fd is
 equal to -1) into a real one, removing an existing entry (new one is set to -1), or replacing an existing entry with a new existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of file descriptors to use for the update stored in data. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of
 descriptors in the passed in arrays. See <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> - 
 Register buffers for I/O.
 
 <p>Similar to <a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a> but aims to have a more extensible ABI. <code>arg</code> points to a struct <code>io_uring_rsrc_register</code>, and
 <code>nr_args</code> should be set to the number of bytes in the structure.</p>
 
 <p>The data field contains a pointer to a struct <code>iovec</code> array of <code>nr</code> entries. The <code>tags</code> field should either be 0, then tagging is
 disabled, or point to an array of <code>nr</code> "tags" (unsigned 64 bit integers). If a tag is zero, then tagging for this particular resource (a
 buffer in this case) is disabled. Otherwise, after the resource had been unregistered and it's not used anymore, a CQE will be posted with
 <code>user_data</code> set to the specified tag and all other fields zeroed.</p>
 
 <p>Note that resource updates, e.g. <a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a>, don't necessarily deallocate resources by the time it returns, but they might be held
 alive until all requests using it complete.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a> - 
 Updates registered buffers with new ones, either turning a sparse entry into a real one, or replacing an existing entry.
 
 <p><code>arg</code> must contain a pointer to a struct <code>io_uring_rsrc_update2</code>, which contains an offset on which to start the update, and an array
 of struct <code>iovec</code>. <code>tags</code> points to an array of tags. <code>nr</code> must contain the number of descriptors in the passed in arrays. See
 <a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a> for the resource tagging description.</p>
 
 <p>Available since 5.13.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a> - 
 By default, async workers created by <code>io_uring</code> will inherit the CPU mask of its parent.
 
 <p>This is usually all the CPUs in the system, unless the parent is being run with a limited set. If this isn't the desired outcome, the application
 may explicitly tell <code>io_uring</code> what CPUs the async workers may run on.</p>
 
 <p><code>arg</code> must point to a <code>cpu_set_t</code> mask, and <code>nr_args</code> the byte size of that mask.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_IOWQ_AFF"><code>UNREGISTER_IOWQ_AFF</code></a> - 
 Undoes a CPU mask previously set with <a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a>.
 
 <p>Must not have <code>arg</code> or <code>nr_args</code> set.</p>
 
 <p>Available since 5.14.</p>
 </li>
 <li><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a> - 
 By default, <code>io_uring</code> limits the unbounded workers created to the maximum processor count set by <code>RLIMIT_NPROC</code> and the bounded
 workers is a function of the SQ ring size and the number of CPUs in the system. Sometimes this can be excessive (or too little, for bounded), and
 this command provides a way to change the count per ring (per NUMA node) instead.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of two values, with the values in the array being set to the maximum count of
 workers per NUMA node. Index 0 holds the bounded worker count, and index 1 holds the unbounded worker count. On successful return, the passed in
 array will contain the previous maximum valyes for each type. If the count being passed in is 0, then this command returns the current maximum
 values and doesn't modify the current setting. <code>nr_args</code> must be set to 2, as the command takes two values.</p>
 
 <p>Available since 5.15.</p>
 </li>
 <li><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a> - 
 Whenever <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> is called to submit request or wait for completions, the kernel must grab a reference to the file descriptor. If the application
 using io_uring is threaded, the file table is marked as shared, and the reference grab and put of the file descriptor count is more expensive than
 it is for a non-threaded application.
 
 <p>Similarly to how io_uring allows registration of files, this allow registration of the ring file descriptor itself. This reduces the overhead of
 the <code>io_uring_enter (2)</code> system call.</p>
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 The <code>data</code> field of this struct must point to an io_uring file descriptor, and the <code>offset</code> field can be either <code>-1</code> or an
 explicit offset desired for the registered file descriptor value. If <code>-1</code> is used, then upon successful return of this system call, the field
 will contain the value of the registered file descriptor to be used for future <code>io_uring_enter (2)</code> system calls.</p>
 
 <p>On successful completion of this request, the returned descriptors may be used instead of the real file descriptor for <code>io_uring_enter (2)</code>,
 provided that <code>IORING_ENTER_REGISTERED_RING</code> is set in the <code>flags</code> for the system call. This flag tells the kernel that a registered
 descriptor is used rather than a real file descriptor.</p>
 
 <p>Each thread or process using a ring must register the file descriptor directly by issuing this request.</p>
 
 <p>The maximum number of supported registered ring descriptors is currently limited to <code>16</code>.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_UNREGISTER_RING_FDS"><code>UNREGISTER_RING_FDS</code></a> - 
 Unregister descriptors previously registered with <a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a>.
 
 <p><code>arg</code> must be set to an unsigned int pointer to an array of type <code>struct io_uring_rsrc_register</code> of <code>nr_args</code> number of entries.
 Only the <code>offset</code> field should be set in the structure, containing the registered file descriptor offset previously returned from
 <code>IORING_REGISTER_RING_FDS</code> that the application wishes to unregister.</p>
 
 <p>Note that this isn't done automatically on ring exit, if the thread or task that previously registered a ring file descriptor isn't exiting. It is
 recommended to manually unregister any previously registered ring descriptors if the ring is closed and the task persists. This will free up a
 registration slot, making it available for future use.</p>
 
 <p>Available since 5.18.</p>
 </li>
 <li><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a> - register ring based provide buffer group</li>
 <li><a href="#IORING_UNREGISTER_PBUF_RING"><code>UNREGISTER_PBUF_RING</code></a> - unregister ring based provide buffer group</li>
 <li><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a> - sync cancelation API</li>
 <li><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a> - register a range of fixed file slots for automatic slot allocation</li>
 <li><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_LAST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RSRC_REGISTER_SPARSE">
<h3>IORING_RSRC_REGISTER_SPARSE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RSRC_REGISTER_SPARSE</span></div>
<div class="block">Register a fully sparse file space, rather than pass in an array of all -1 file descriptors.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RSRC_REGISTER_SPARSE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IO_WQ_BOUND">
<h3>IO_WQ_BOUND</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IO_WQ_BOUND</span></div>
<div class="block"><code>io-wq</code> worker categories
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IO_WQ_BOUND"><code>IO_WQ_BOUND</code></a></li>
 <li><a href="#IO_WQ_UNBOUND"><code>IO_WQ_UNBOUND</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IO_WQ_BOUND">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IO_WQ_UNBOUND">
<h3>IO_WQ_UNBOUND</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IO_WQ_UNBOUND</span></div>
<div class="block"><code>io-wq</code> worker categories
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IO_WQ_BOUND"><code>IO_WQ_BOUND</code></a></li>
 <li><a href="#IO_WQ_UNBOUND"><code>IO_WQ_UNBOUND</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IO_WQ_UNBOUND">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_REGISTER_FILES_SKIP">
<h3>IORING_REGISTER_FILES_SKIP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_REGISTER_FILES_SKIP</span></div>
<div class="block">Skip updating fd indexes set to this value in the fd table.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_REGISTER_FILES_SKIP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IO_URING_OP_SUPPORTED">
<h3>IO_URING_OP_SUPPORTED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IO_URING_OP_SUPPORTED</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IO_URING_OP_SUPPORTED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RESTRICTION_REGISTER_OP">
<h3>IORING_RESTRICTION_REGISTER_OP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RESTRICTION_REGISTER_OP</span></div>
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RESTRICTION_REGISTER_OP"><code>RESTRICTION_REGISTER_OP</code></a> - Allow an <code>io_uring_register(2)</code> opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_OP"><code>RESTRICTION_SQE_OP</code></a> - Allow an sqe opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_ALLOWED"><code>RESTRICTION_SQE_FLAGS_ALLOWED</code></a> - Allow sqe flags</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_REQUIRED"><code>RESTRICTION_SQE_FLAGS_REQUIRED</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 <li><a href="#IORING_RESTRICTION_LAST"><code>RESTRICTION_LAST</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RESTRICTION_REGISTER_OP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RESTRICTION_SQE_OP">
<h3>IORING_RESTRICTION_SQE_OP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RESTRICTION_SQE_OP</span></div>
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RESTRICTION_REGISTER_OP"><code>RESTRICTION_REGISTER_OP</code></a> - Allow an <code>io_uring_register(2)</code> opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_OP"><code>RESTRICTION_SQE_OP</code></a> - Allow an sqe opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_ALLOWED"><code>RESTRICTION_SQE_FLAGS_ALLOWED</code></a> - Allow sqe flags</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_REQUIRED"><code>RESTRICTION_SQE_FLAGS_REQUIRED</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 <li><a href="#IORING_RESTRICTION_LAST"><code>RESTRICTION_LAST</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RESTRICTION_SQE_OP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RESTRICTION_SQE_FLAGS_ALLOWED">
<h3>IORING_RESTRICTION_SQE_FLAGS_ALLOWED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RESTRICTION_SQE_FLAGS_ALLOWED</span></div>
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RESTRICTION_REGISTER_OP"><code>RESTRICTION_REGISTER_OP</code></a> - Allow an <code>io_uring_register(2)</code> opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_OP"><code>RESTRICTION_SQE_OP</code></a> - Allow an sqe opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_ALLOWED"><code>RESTRICTION_SQE_FLAGS_ALLOWED</code></a> - Allow sqe flags</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_REQUIRED"><code>RESTRICTION_SQE_FLAGS_REQUIRED</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 <li><a href="#IORING_RESTRICTION_LAST"><code>RESTRICTION_LAST</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RESTRICTION_SQE_FLAGS_ALLOWED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RESTRICTION_SQE_FLAGS_REQUIRED">
<h3>IORING_RESTRICTION_SQE_FLAGS_REQUIRED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RESTRICTION_SQE_FLAGS_REQUIRED</span></div>
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RESTRICTION_REGISTER_OP"><code>RESTRICTION_REGISTER_OP</code></a> - Allow an <code>io_uring_register(2)</code> opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_OP"><code>RESTRICTION_SQE_OP</code></a> - Allow an sqe opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_ALLOWED"><code>RESTRICTION_SQE_FLAGS_ALLOWED</code></a> - Allow sqe flags</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_REQUIRED"><code>RESTRICTION_SQE_FLAGS_REQUIRED</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 <li><a href="#IORING_RESTRICTION_LAST"><code>RESTRICTION_LAST</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RESTRICTION_SQE_FLAGS_REQUIRED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="IORING_RESTRICTION_LAST">
<h3>IORING_RESTRICTION_LAST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">IORING_RESTRICTION_LAST</span></div>
<div class="block"><code>io_uring_restriction-&gt;opcode</code> values
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#IORING_RESTRICTION_REGISTER_OP"><code>RESTRICTION_REGISTER_OP</code></a> - Allow an <code>io_uring_register(2)</code> opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_OP"><code>RESTRICTION_SQE_OP</code></a> - Allow an sqe opcode</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_ALLOWED"><code>RESTRICTION_SQE_FLAGS_ALLOWED</code></a> - Allow sqe flags</li>
 <li><a href="#IORING_RESTRICTION_SQE_FLAGS_REQUIRED"><code>RESTRICTION_SQE_FLAGS_REQUIRED</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 <li><a href="#IORING_RESTRICTION_LAST"><code>RESTRICTION_LAST</code></a> - Require sqe flags (these flags must be set on each submission)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../../constant-values.html#org.lwjgl.system.linux.liburing.LibIOURing.IORING_RESTRICTION_LAST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="nio_uring_setup(int,long)">
<h3>nio_uring_setup</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nio_uring_setup</span><wbr><span class="parameters">(int&nbsp;entries,
 long&nbsp;p)</span></div>
<div class="block">Unsafe version of: <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a></div>
</section>
</li>
<li>
<section class="detail" id="io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)">
<h3>io_uring_setup</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">io_uring_setup</span><wbr><span class="parameters">(int&nbsp;entries,
 <a href="IOURingParams.html" title="class in org.lwjgl.system.linux.liburing">IOURingParams</a>&nbsp;p)</span></div>
<div class="block">The <code>io_uring_setup()</code> system call sets up a submission queue (SQ) and completion queue (CQ) with at least <code>entries</code> entries, and returns a
 file descriptor which can be used to perform subsequent operations on the <code>io_uring</code> instance.
 
 <p>The submission and completion queues are shared between userspace and the kernel, which eliminates the need to copy data when initiating and completing
 I/O.</p>
 
 <p>Closing the file descriptor returned by <code>io_uring_setup(2)</code> will free all resources associated with the <code>io_uring</code> context.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p</code> - used by the application to pass options to the kernel, and by the kernel to convey information about the ring buffers</dd>
<dt>Returns:</dt>
<dd>a new file descriptor on success.
         
         <p>The application may then provide the file descriptor in a subsequent <code>mmap(2)</code> call to map the submission and completion queues, or to the
         <a href="#io_uring_register(int,int,long,int)"><code>register</code></a> or <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a> system calls.</p>
         
         <p>On error, <code>-1</code> is returned and <code>errno</code> is set appropriately.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nio_uring_register(int,int,long,int)">
<h3>nio_uring_register</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nio_uring_register</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;opcode,
 long&nbsp;arg,
 int&nbsp;nr_args)</span></div>
<div class="block">Unsafe version of: <a href="#io_uring_register(int,int,long,int)"><code>register</code></a></div>
</section>
</li>
<li>
<section class="detail" id="io_uring_register(int,int,long,int)">
<h3>io_uring_register</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">io_uring_register</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;opcode,
 long&nbsp;arg,
 int&nbsp;nr_args)</span></div>
<div class="block">The <code>io_uring_register()</code> system call registers resources (e.g. user buffers, files, eventfd, personality, restrictions) for use in an
 <code>io_uring</code> instance referenced by <code>fd</code>.
 
 <p>Registering files or user buffers allows the kernel to take long term references to internal data structures or create long term mappings of
 application memory, greatly reducing per-I/O overhead.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>fd</code> - the file descriptor returned by a call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a></dd>
<dd><code>opcode</code> - one of:<br><table><tr><td><a href="#IORING_REGISTER_BUFFERS"><code>REGISTER_BUFFERS</code></a></td><td><a href="#IORING_REGISTER_FILES"><code>REGISTER_FILES</code></a></td><td><a href="#IORING_REGISTER_EVENTFD"><code>REGISTER_EVENTFD</code></a></td><td><a href="#IORING_REGISTER_FILES_UPDATE"><code>REGISTER_FILES_UPDATE</code></a></td></tr><tr><td><a href="#IORING_REGISTER_EVENTFD_ASYNC"><code>REGISTER_EVENTFD_ASYNC</code></a></td><td><a href="#IORING_REGISTER_PROBE"><code>REGISTER_PROBE</code></a></td><td><a href="#IORING_REGISTER_PERSONALITY"><code>REGISTER_PERSONALITY</code></a></td><td><a href="#IORING_REGISTER_RESTRICTIONS"><code>REGISTER_RESTRICTIONS</code></a></td></tr><tr><td><a href="#IORING_REGISTER_ENABLE_RINGS"><code>REGISTER_ENABLE_RINGS</code></a></td><td><a href="#IORING_REGISTER_FILES2"><code>REGISTER_FILES2</code></a></td><td><a href="#IORING_REGISTER_FILES_UPDATE2"><code>REGISTER_FILES_UPDATE2</code></a></td><td><a href="#IORING_REGISTER_BUFFERS2"><code>REGISTER_BUFFERS2</code></a></td></tr><tr><td><a href="#IORING_REGISTER_BUFFERS_UPDATE"><code>REGISTER_BUFFERS_UPDATE</code></a></td><td><a href="#IORING_REGISTER_IOWQ_AFF"><code>REGISTER_IOWQ_AFF</code></a></td><td><a href="#IORING_REGISTER_IOWQ_MAX_WORKERS"><code>REGISTER_IOWQ_MAX_WORKERS</code></a></td><td><a href="#IORING_REGISTER_RING_FDS"><code>REGISTER_RING_FDS</code></a></td></tr><tr><td><a href="#IORING_REGISTER_PBUF_RING"><code>REGISTER_PBUF_RING</code></a></td><td><a href="#IORING_REGISTER_SYNC_CANCEL"><code>REGISTER_SYNC_CANCEL</code></a></td><td><a href="#IORING_REGISTER_FILE_ALLOC_RANGE"><code>REGISTER_FILE_ALLOC_RANGE</code></a></td><td><a href="#IORING_REGISTER_LAST"><code>REGISTER_LAST</code></a></td></tr><tr><td><a href="#IORING_REGISTER_FILES_SKIP"><code>REGISTER_FILES_SKIP</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>on success, returns 0. On error, -1 is returned, and <code>errno</code> is set accordingly.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nio_uring_enter2(int,int,int,int,long,int)">
<h3>nio_uring_enter2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nio_uring_enter2</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig,
 int&nbsp;sz)</span></div>
</section>
</li>
<li>
<section class="detail" id="io_uring_enter2(int,int,int,int,long,int)">
<h3>io_uring_enter2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">io_uring_enter2</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig,
 int&nbsp;sz)</span></div>
</section>
</li>
<li>
<section class="detail" id="nio_uring_enter(int,int,int,int,long)">
<h3>nio_uring_enter</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nio_uring_enter</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig)</span></div>
<div class="block">Unsafe version of: <a href="#io_uring_enter(int,int,int,int,long)"><code>enter</code></a></div>
</section>
</li>
<li>
<section class="detail" id="io_uring_enter(int,int,int,int,long)">
<h3>io_uring_enter</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">io_uring_enter</span><wbr><span class="parameters">(int&nbsp;fd,
 int&nbsp;to_submit,
 int&nbsp;min_complete,
 int&nbsp;flags,
 long&nbsp;sig)</span></div>
<div class="block"><code>io_uring_enter()</code> is used to initiate and complete I/O using the shared submission and completion queues setup by a call to <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a>.
 
 <p>A single call can both submit new I/O and wait for completions of I/O initiated by this call or previous calls to <code>io_uring_enter()</code>.</p>
 
 <p>If the <code>io_uring</code> instance was configured for polling, by specifying <a href="#IORING_SETUP_IOPOLL"><code>SETUP_IOPOLL</code></a> in the call to <code>io_uring_setup()</code>, then
 <code>min_complete</code> has a slightly different meaning. Passing a value of 0 instructs the kernel to return any events which are already complete,
 without blocking. If <code>min_complete</code> is a non-zero value, the kernel will still return immediately if any completion events are available. If no
 event completions are available, then the call will poll either until one or more completions become available, or until the process has exceeded its
 scheduler time slice.</p>
 
 <p>Note that, for interrupt driven I/O (where <code>IORING_SETUP_IOPOLL</code> was not specified in the call to <code>io_uring_setup()</code>), an application may
 check the completion queue for event completions without entering the kernel at all.</p>
 
 <p>When the system call returns that a certain amount of SQEs have been consumed and submitted, it's safe to reuse SQE entries in the ring. This is true
 even if the actual IO submission had to be punted to async context, which means that the SQE may in fact not have been submitted yet. If the kernel
 requires later use of a particular SQE entry, it will have made a private copy of it.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>fd</code> - the file descriptor returned by <a href="#io_uring_setup(int,org.lwjgl.system.linux.liburing.IOURingParams)"><code>setup</code></a></dd>
<dd><code>to_submit</code> - the number of I/Os to submit from the submission queue</dd>
<dd><code>flags</code> - one or more of:<br><table><tr><td><a href="#IORING_ENTER_GETEVENTS"><code>ENTER_GETEVENTS</code></a></td><td><a href="#IORING_ENTER_SQ_WAKEUP"><code>ENTER_SQ_WAKEUP</code></a></td><td><a href="#IORING_ENTER_SQ_WAIT"><code>ENTER_SQ_WAIT</code></a></td><td><a href="#IORING_ENTER_EXT_ARG"><code>ENTER_EXT_ARG</code></a></td><td><a href="#IORING_ENTER_REGISTERED_RING"><code>ENTER_REGISTERED_RING</code></a></td></tr></table></dd>
<dd><code>sig</code> - a pointer to a signal mask (see <code>sigprocmask(2)</code>); if <code>sig</code> is not <code>NULL</code>, <code>io_uring_enter()</code> first replaces the current signal
                  mask by the one pointed to by sig, then waits for events to become available in the completion queue, and then restores the original signal mask.
                  The following <code>io_uring_enter()</code> call:
                  
                  <pre><code>
                  ret = io_uring_enter(fd, 0, 1, IORING_ENTER_GETEVENTS, &amp;sig);</code></pre>
                  
                  <p>is equivalent to atomically executing the following calls:</p>
                  
                  <pre><code>
                  pthread_sigmask(SIG_SETMASK, &amp;sig, &amp;orig);
                  ret = io_uring_enter(fd, 0, 1, IORING_ENTER_GETEVENTS, NULL);
                  pthread_sigmask(SIG_SETMASK, &amp;orig, NULL);</code></pre>
                  
                  <p>See the description of <code>pselect(2)</code> for an explanation of why the <code>sig</code> parameter is necessary.</p></dd>
<dt>Returns:</dt>
<dd>the number of I/Os successfully consumed.
         
         <p>This can be zero if <code>to_submit</code> was zero or if the submission queue was empty. Note that if the ring was created with <a href="#IORING_SETUP_SQPOLL"><code>SETUP_SQPOLL</code></a> specified,
         then the return value will generally be the same as <code>to_submit</code> as submission happens outside the context of the system call.</p>
         
         <p>The errors related to a submission queue entry will be returned through a completion queue entry, rather than through the system call itself.</p>
         
         <p>Errors that occur not on behalf of a submission queue entry are returned via the system call directly. On such an error, -1 is returned and
         <code>errno</code> is set appropriately.</p></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</div>
</div>
</body>
</html>
