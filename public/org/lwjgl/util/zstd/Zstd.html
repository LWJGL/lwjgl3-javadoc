<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) -->
<title>Zstd (LWJGL 3.3.2-snapshot)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.lwjgl.util.zstd, class: Zstd">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li><a href="#field-summary">Field</a></li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.lwjgl.util.zstd</a></div>
<h1 title="Class Zstd" class="title">Class Zstd</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.lwjgl.util.zstd.Zstd</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">Zstd</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Native bindings to <a target="_blank" href="http://facebook.github.io/zstd/">Zstandard</a> (zstd), a fast lossless compression algorithm, targeting real-time
 compression scenarios at zlib-level and better compression ratios.
 
 <h3>Introduction</h3>
 
 <p>zstd, short for Zstandard, is a fast lossless compression algorithm, targeting real-time compression scenarios at zlib-level and better compression
 ratios. The zstd compression library provides in-memory compression and decompression functions.</p>
 
 <p>The library supports regular compression levels from 1 up to <a href="#ZSTD_maxCLevel()"><code>maxCLevel</code></a>, which is currently 22. Levels &ge; 20, labeled <code>--ultra</code>, should be
 used with caution, as they require more memory. The library also offers negative compression levels, which extend the range of speed vs. ratio
 preferences. The lower the level, the faster the speed (at the cost of compression).</p>
 
 <p>Compression can be done in:</p>
 
 <ul>
 <li>a single step (described as Simple API)</li>
 <li>a single step, reusing a context (described as Explicit context)</li>
 <li>unbounded multiple steps (described as Streaming compression)</li>
 </ul>
 
 <p>The compression ratio achievable on small data can be highly improved using a dictionary. Dictionary compression can be performed in:</p>
 
 <ul>
 <li>a single step (described as Simple dictionary API)</li>
 <li>a single step, reusing a dictionary (described as Bulk-processing dictionary API)</li>
 </ul>
 
 <p>Advanced experimental functions can be accessed using <code>#define ZSTD_STATIC_LINKING_ONLY</code> before including <code>zstd.h</code>. Advanced experimental
 APIs should never be used with a dynamically-linked library. They are not "stable", their definitions or signatures may change in the future. Only
 static linking is allowed.</p>
 
 <h3>Streaming compression - HowTo</h3>
 
 <p>A <code>ZSTD_CStream</code> object is required to track streaming operation.</p>
 
 <p>Use <a href="#ZSTD_createCStream()"><code>createCStream</code></a> and <a href="#ZSTD_freeCStream(long)"><code>freeCStream</code></a> to create/release resources. <code>ZSTD_CStream</code> objects can be reused multiple times on consecutive
 compression operations. It is recommended to re-use <code>ZSTD_CStream</code> since it will play nicer with system's memory, by re-using already allocated
 memory.</p>
 
 <p>For parallel execution, use one separate <code>ZSTD_CStream</code>.</p>
 
 <p>Since v1.3.0, <code>ZSTD_CStream</code> and <code>ZSTD_CCtx</code> are the same thing.</p>
 
 <p>Parameters are sticky: when starting a new compression on the same context, it will re-use the same sticky parameters as previous compression session.
 When in doubt, it's recommended to fully initialize the context before usage. Use <a href="#ZSTD_CCtx_reset(long,int)"><code>CCtx_reset</code></a> to reset the context and <a href="#ZSTD_CCtx_setParameter(long,int,int)"><code>CCtx_setParameter</code></a>,
 <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>, or <a href="#ZSTD_CCtx_loadDictionary(long,java.nio.ByteBuffer)"><code>CCtx_loadDictionary</code></a> and friends to set more specific parameters, the pledged source size, or load a dictionary.</p>
 
 <p>Use <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> with <a href="#ZSTD_e_continue"><code>e_continue</code></a> as many times as necessary to consume input stream. The function will automatically update both <code>pos</code>
 fields within <code>input</code> and <code>output</code>. Note that the function may not consume the entire input, for example, because the output buffer is
 already full, in which case <code>input.pos &lt; input.size</code>. The caller must check if input has been entirely consumed. If not, the caller must make
 some room to receive more compressed data, and then present again remaining input data.</p>
 
 <p>Note: <code>ZSTD_e_continue</code> is guaranteed to make some forward progress when called, but doesn't guarantee maximal forward progress. This is
 especially relevant when compressing with multiple threads. The call won't block if it can consume some input, but if it can't it will wait for some,
 but not all, output to be flushed.</p>
 
 <p>At any moment, it's possible to flush whatever data might remain stuck within internal buffer, using <code>ZSTD_compressStream2()</code> with <a href="#ZSTD_e_flush"><code>e_flush</code></a>.
 <code>output-&gt;pos</code> will be updated. Note that, if <code>output-&gt;size</code> is too small, a single invocation with <code>ZSTD_e_flush</code> might not be enough
 (return code &gt; 0). In which case, make some room to receive more compressed data, and call again <code>ZSTD_compressStream2()</code> with
 <code>ZSTD_e_flush</code>. You must continue calling <code>ZSTD_compressStream2()</code> with <code>ZSTD_e_flush</code> until it returns 0, at which point you can
 change the operation.</p>
 
 <p>Note: <code>ZSTD_e_flush</code> will flush as much output as possible, meaning when compressing with multiple threads, it will block until the flush is
 complete or the output buffer is full.</p>
 
 <p>Calling <code>ZSTD_compressStream2()</code> with <a href="#ZSTD_e_end"><code>e_end</code></a> instructs to finish a frame. It will perform a flush and write frame epilogue. The epilogue is
 required for decoders to consider a frame completed. Flush operation is the same, and follows same rules as calling <code>ZSTD_compressStream2()</code> with
 <code>ZSTD_e_flush</code>. You must continue calling <code>ZSTD_compressStream2()</code> with <code>ZSTD_e_end</code> until it returns 0, at which point you are free
 to start a new frame.</p>
 
 <p>Note: <code>ZSTD_e_end</code> will flush as much output as possible, meaning when compressing with multiple threads, it will block until the flush is
 complete or the output buffer is full.</p>
 
 <h3>Streaming decompression - HowTo</h3>
 
 <p>A <code>ZSTD_DStream</code> object is required to track streaming operations.</p>
 
 <p>Use <a href="#ZSTD_createDStream()"><code>createDStream</code></a> and <a href="#ZSTD_freeDStream(long)"><code>freeDStream</code></a> to create/release resources. <code>ZSTD_DStream</code> objects can be re-used multiple times.</p>
 
 <p>Use <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a> and <a href="#ZSTD_DCtx_refDDict(long,long)"><code>DCtx_refDDict</code></a> to start a new decompression operation. Alternatively, use advanced API to set specific properties.</p>
 
 <p>Use <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a> repetitively to consume your input. The function will update both <code>pos</code> fields. If <code>input.pos &lt; input.size</code>, some
 input has not been consumed. It's up to the caller to present again remaining data. The function tries to flush all data decoded immediately,
 respecting output buffer size. If <code>output.pos &lt; output.size</code>, decoder has flushed everything it could. But if <code>output.pos == output.size</code>,
 there might be some data left within internal buffers. In which case, call <code>ZSTD_decompressStream()</code> again to flush whatever remains in the
 buffer.</p>
 
 <p>Note: with no additional input provided, amount of data flushed is necessarily &le; <a href="#ZSTD_BLOCKSIZE_MAX"><code>BLOCKSIZE_MAX</code></a>.</p></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_BLOCKSIZE_MAX" class="member-name-link">ZSTD_BLOCKSIZE_MAX</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_BLOCKSIZELOG_MAX" class="member-name-link">ZSTD_BLOCKSIZELOG_MAX</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_btlazy2" class="member-name-link">ZSTD_btlazy2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_btopt" class="member-name-link">ZSTD_btopt</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_btultra" class="member-name-link">ZSTD_btultra</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_btultra2" class="member-name-link">ZSTD_btultra2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_chainLog" class="member-name-link">ZSTD_c_chainLog</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_checksumFlag" class="member-name-link">ZSTD_c_checksumFlag</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_compressionLevel" class="member-name-link">ZSTD_c_compressionLevel</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_contentSizeFlag" class="member-name-link">ZSTD_c_contentSizeFlag</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_dictIDFlag" class="member-name-link">ZSTD_c_dictIDFlag</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_enableLongDistanceMatching" class="member-name-link">ZSTD_c_enableLongDistanceMatching</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam1" class="member-name-link">ZSTD_c_experimentalParam1</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_experimentalParam10" class="member-name-link">ZSTD_c_experimentalParam10</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam11" class="member-name-link">ZSTD_c_experimentalParam11</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_experimentalParam12" class="member-name-link">ZSTD_c_experimentalParam12</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam13" class="member-name-link">ZSTD_c_experimentalParam13</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_experimentalParam14" class="member-name-link">ZSTD_c_experimentalParam14</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam15" class="member-name-link">ZSTD_c_experimentalParam15</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_experimentalParam2" class="member-name-link">ZSTD_c_experimentalParam2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam3" class="member-name-link">ZSTD_c_experimentalParam3</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_experimentalParam4" class="member-name-link">ZSTD_c_experimentalParam4</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam5" class="member-name-link">ZSTD_c_experimentalParam5</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_experimentalParam6" class="member-name-link">ZSTD_c_experimentalParam6</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam7" class="member-name-link">ZSTD_c_experimentalParam7</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_experimentalParam8" class="member-name-link">ZSTD_c_experimentalParam8</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_experimentalParam9" class="member-name-link">ZSTD_c_experimentalParam9</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_hashLog" class="member-name-link">ZSTD_c_hashLog</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_jobSize" class="member-name-link">ZSTD_c_jobSize</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_ldmBucketSizeLog" class="member-name-link">ZSTD_c_ldmBucketSizeLog</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_ldmHashLog" class="member-name-link">ZSTD_c_ldmHashLog</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_ldmHashRateLog" class="member-name-link">ZSTD_c_ldmHashRateLog</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_ldmMinMatch" class="member-name-link">ZSTD_c_ldmMinMatch</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_minMatch" class="member-name-link">ZSTD_c_minMatch</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_nbWorkers" class="member-name-link">ZSTD_c_nbWorkers</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_overlapLog" class="member-name-link">ZSTD_c_overlapLog</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_searchLog" class="member-name-link">ZSTD_c_searchLog</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_strategy" class="member-name-link">ZSTD_c_strategy</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_c_targetLength" class="member-name-link">ZSTD_c_targetLength</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_c_windowLog" class="member-name-link">ZSTD_c_windowLog</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression parameters.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_CLEVEL_DEFAULT" class="member-name-link">ZSTD_CLEVEL_DEFAULT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default compression level.</div>
</div>
<div class="col-first odd-row-color"><code>static final long</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_CONTENTSIZE_ERROR" class="member-name-link">ZSTD_CONTENTSIZE_ERROR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Content size.</div>
</div>
<div class="col-first even-row-color"><code>static final long</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_CONTENTSIZE_UNKNOWN" class="member-name-link">ZSTD_CONTENTSIZE_UNKNOWN</a></code></div>
<div class="col-last even-row-color">
<div class="block">Content size.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_d_experimentalParam1" class="member-name-link">ZSTD_d_experimentalParam1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_d_experimentalParam2" class="member-name-link">ZSTD_d_experimentalParam2</a></code></div>
<div class="col-last even-row-color">
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_d_experimentalParam3" class="member-name-link">ZSTD_d_experimentalParam3</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_d_experimentalParam4" class="member-name-link">ZSTD_d_experimentalParam4</a></code></div>
<div class="col-last even-row-color">
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_d_windowLogMax" class="member-name-link">ZSTD_d_windowLogMax</a></code></div>
<div class="col-last odd-row-color">
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_dfast" class="member-name-link">ZSTD_dfast</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_e_continue" class="member-name-link">ZSTD_e_continue</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>ZSTD_EndDirective</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_e_end" class="member-name-link">ZSTD_e_end</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>ZSTD_EndDirective</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_e_flush" class="member-name-link">ZSTD_e_flush</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>ZSTD_EndDirective</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_fast" class="member-name-link">ZSTD_fast</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_greedy" class="member-name-link">ZSTD_greedy</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_lazy" class="member-name-link">ZSTD_lazy</a></code></div>
<div class="col-last even-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_lazy2" class="member-name-link">ZSTD_lazy2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Compression strategies, listed from fastest to strongest.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_MAGIC_DICTIONARY" class="member-name-link">ZSTD_MAGIC_DICTIONARY</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_MAGIC_SKIPPABLE_MASK" class="member-name-link">ZSTD_MAGIC_SKIPPABLE_MASK</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_MAGIC_SKIPPABLE_START" class="member-name-link">ZSTD_MAGIC_SKIPPABLE_START</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_MAGICNUMBER" class="member-name-link">ZSTD_MAGICNUMBER</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_reset_parameters" class="member-name-link">ZSTD_reset_parameters</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>ZSTD_ResetDirective</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_reset_session_and_parameters" class="member-name-link">ZSTD_reset_session_and_parameters</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>ZSTD_ResetDirective</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_reset_session_only" class="member-name-link">ZSTD_reset_session_only</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>ZSTD_ResetDirective</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_VERSION_MAJOR" class="member-name-link">ZSTD_VERSION_MAJOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Version number part.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_VERSION_MINOR" class="member-name-link">ZSTD_VERSION_MINOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Version number part.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_VERSION_NUMBER" class="member-name-link">ZSTD_VERSION_NUMBER</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Version number.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ZSTD_VERSION_RELEASE" class="member-name-link">ZSTD_VERSION_RELEASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Version number part.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#ZSTD_VERSION_STRING" class="member-name-link">ZSTD_VERSION_STRING</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Version string.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_CCtx_loadDictionary(long,long,long)" class="member-name-link">nZSTD_CCtx_loadDictionary</a><wbr>(long&nbsp;cctx,
 long&nbsp;dict,
 long&nbsp;dictSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_loadDictionary(long,java.nio.ByteBuffer)"><code>CCtx_loadDictionary</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_CCtx_refCDict(long,long)" class="member-name-link">nZSTD_CCtx_refCDict</a><wbr>(long&nbsp;cctx,
 long&nbsp;cdict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_CCtx_refPrefix(long,long,long)" class="member-name-link">nZSTD_CCtx_refPrefix</a><wbr>(long&nbsp;cctx,
 long&nbsp;prefix,
 long&nbsp;prefixSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_refPrefix(long,java.nio.ByteBuffer)"><code>CCtx_refPrefix</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_CCtx_reset(long,int)" class="member-name-link">nZSTD_CCtx_reset</a><wbr>(long&nbsp;cctx,
 int&nbsp;reset)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_reset(long,int)"><code>CCtx_reset</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_CCtx_setParameter(long,int,int)" class="member-name-link">nZSTD_CCtx_setParameter</a><wbr>(long&nbsp;cctx,
 int&nbsp;param,
 int&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_setParameter(long,int,int)"><code>CCtx_setParameter</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_CCtx_setPledgedSrcSize(long,long)" class="member-name-link">nZSTD_CCtx_setPledgedSrcSize</a><wbr>(long&nbsp;cctx,
 long&nbsp;pledgedSrcSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_compress(long,long,long,long,int)" class="member-name-link">nZSTD_compress</a><wbr>(long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_compress(java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_compress_usingCDict(long,long,long,long,long,long)" class="member-name-link">nZSTD_compress_usingCDict</a><wbr>(long&nbsp;cctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;cdict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_compress_usingCDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)"><code>compress_usingCDict</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_compress_usingDict(long,long,long,long,long,long,long,int)" class="member-name-link">nZSTD_compress_usingDict</a><wbr>(long&nbsp;ctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;dict,
 long&nbsp;dictSize,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_compress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress_usingDict</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_compress2(long,long,long,long,long)" class="member-name-link">nZSTD_compress2</a><wbr>(long&nbsp;cctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_compressCCtx(long,long,long,long,long,int)" class="member-name-link">nZSTD_compressCCtx</a><wbr>(long&nbsp;ctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_compressCCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compressCCtx</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_compressStream2(long,long,long,int)" class="member-name-link">nZSTD_compressStream2</a><wbr>(long&nbsp;cctx,
 long&nbsp;output,
 long&nbsp;input,
 int&nbsp;endOp)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_cParam_getBounds(int,long)" class="member-name-link">nZSTD_cParam_getBounds</a><wbr>(int&nbsp;cParam,
 long&nbsp;__result)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_cParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)"><code>cParam_getBounds</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_createCDict(long,long,int)" class="member-name-link">nZSTD_createCDict</a><wbr>(long&nbsp;dictBuffer,
 long&nbsp;dictSize,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_createCDict(java.nio.ByteBuffer,int)"><code>createCDict</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_createDDict(long,long)" class="member-name-link">nZSTD_createDDict</a><wbr>(long&nbsp;dictBuffer,
 long&nbsp;dictSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_createDDict(java.nio.ByteBuffer)"><code>createDDict</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_DCtx_loadDictionary(long,long,long)" class="member-name-link">nZSTD_DCtx_loadDictionary</a><wbr>(long&nbsp;dctx,
 long&nbsp;dict,
 long&nbsp;dictSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_loadDictionary(long,java.nio.ByteBuffer)"><code>DCtx_loadDictionary</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_DCtx_refDDict(long,long)" class="member-name-link">nZSTD_DCtx_refDDict</a><wbr>(long&nbsp;dctx,
 long&nbsp;ddict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_refDDict(long,long)"><code>DCtx_refDDict</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_DCtx_refPrefix(long,long,long)" class="member-name-link">nZSTD_DCtx_refPrefix</a><wbr>(long&nbsp;dctx,
 long&nbsp;prefix,
 long&nbsp;prefixSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_refPrefix(long,java.nio.ByteBuffer)"><code>DCtx_refPrefix</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_DCtx_reset(long,int)" class="member-name-link">nZSTD_DCtx_reset</a><wbr>(long&nbsp;dctx,
 int&nbsp;reset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_DCtx_setParameter(long,int,int)" class="member-name-link">nZSTD_DCtx_setParameter</a><wbr>(long&nbsp;dctx,
 int&nbsp;param,
 int&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_setParameter(long,int,int)"><code>DCtx_setParameter</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_decompress(long,long,long,long)" class="member-name-link">nZSTD_decompress</a><wbr>(long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;compressedSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_decompress_usingDDict(long,long,long,long,long,long)" class="member-name-link">nZSTD_decompress_usingDDict</a><wbr>(long&nbsp;dctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;ddict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_decompress_usingDDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)"><code>decompress_usingDDict</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_decompress_usingDict(long,long,long,long,long,long,long)" class="member-name-link">nZSTD_decompress_usingDict</a><wbr>(long&nbsp;dctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;dict,
 long&nbsp;dictSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_decompress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress_usingDict</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_decompressDCtx(long,long,long,long,long)" class="member-name-link">nZSTD_decompressDCtx</a><wbr>(long&nbsp;ctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompressDCtx</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_decompressStream(long,long,long)" class="member-name-link">nZSTD_decompressStream</a><wbr>(long&nbsp;zds,
 long&nbsp;output,
 long&nbsp;input)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_dParam_getBounds(int,long)" class="member-name-link">nZSTD_dParam_getBounds</a><wbr>(int&nbsp;dParam,
 long&nbsp;__result)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_dParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)"><code>dParam_getBounds</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_findFrameCompressedSize(long,long)" class="member-name-link">nZSTD_findFrameCompressedSize</a><wbr>(long&nbsp;src,
 long&nbsp;srcSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_findFrameCompressedSize(java.nio.ByteBuffer)"><code>findFrameCompressedSize</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_getDictID_fromCDict(long)" class="member-name-link">nZSTD_getDictID_fromCDict</a><wbr>(long&nbsp;cdict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromCDict(long)"><code>getDictID_fromCDict</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_getDictID_fromDDict(long)" class="member-name-link">nZSTD_getDictID_fromDDict</a><wbr>(long&nbsp;ddict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromDDict(long)"><code>getDictID_fromDDict</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_getDictID_fromDict(long,long)" class="member-name-link">nZSTD_getDictID_fromDict</a><wbr>(long&nbsp;dict,
 long&nbsp;dictSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromDict(java.nio.ByteBuffer)"><code>getDictID_fromDict</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_getDictID_fromFrame(long,long)" class="member-name-link">nZSTD_getDictID_fromFrame</a><wbr>(long&nbsp;src,
 long&nbsp;srcSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromFrame(java.nio.ByteBuffer)"><code>getDictID_fromFrame</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_getErrorName(long)" class="member-name-link">nZSTD_getErrorName</a><wbr>(long&nbsp;code)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_getErrorName(long)"><code>getErrorName</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_getFrameContentSize(long,long)" class="member-name-link">nZSTD_getFrameContentSize</a><wbr>(long&nbsp;src,
 long&nbsp;srcSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_getFrameContentSize(java.nio.ByteBuffer)"><code>getFrameContentSize</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_isError(long)" class="member-name-link">nZSTD_isError</a><wbr>(long&nbsp;code)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_isError(long)"><code>isError</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_sizeof_CCtx(long)" class="member-name-link">nZSTD_sizeof_CCtx</a><wbr>(long&nbsp;cctx)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_sizeof_CDict(long)" class="member-name-link">nZSTD_sizeof_CDict</a><wbr>(long&nbsp;cdict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_sizeof_CStream(long)" class="member-name-link">nZSTD_sizeof_CStream</a><wbr>(long&nbsp;zcs)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_sizeof_DCtx(long)" class="member-name-link">nZSTD_sizeof_DCtx</a><wbr>(long&nbsp;dctx)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_sizeof_DDict(long)" class="member-name-link">nZSTD_sizeof_DDict</a><wbr>(long&nbsp;ddict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_sizeof_DStream(long)" class="member-name-link">nZSTD_sizeof_DStream</a><wbr>(long&nbsp;zds)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nZSTD_versionString()" class="member-name-link">nZSTD_versionString</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#ZSTD_versionString()"><code>versionString</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CCtx_loadDictionary(long,java.nio.ByteBuffer)" class="member-name-link">ZSTD_CCtx_loadDictionary</a><wbr>(long&nbsp;cctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates an internal <code>CDict</code> from <code>dict</code> buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CCtx_refCDict(long,long)" class="member-name-link">ZSTD_CCtx_refCDict</a><wbr>(long&nbsp;cctx,
 long&nbsp;cdict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">References a prepared dictionary, to be used for all next compressed frames.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CCtx_refPrefix(long,java.nio.ByteBuffer)" class="member-name-link">ZSTD_CCtx_refPrefix</a><wbr>(long&nbsp;cctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;prefix)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">References a prefix (single-usage dictionary) for next compressed frame.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CCtx_reset(long,int)" class="member-name-link">ZSTD_CCtx_reset</a><wbr>(long&nbsp;cctx,
 int&nbsp;reset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">There are 2 different things that can be reset, independently or jointly :
 
 
 The session: will stop compressing current frame, and make <code>CCtx</code> ready to start a new one.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CCtx_setParameter(long,int,int)" class="member-name-link">ZSTD_CCtx_setParameter</a><wbr>(long&nbsp;cctx,
 int&nbsp;param,
 int&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set one compression parameter, selected by enum <code>ZSTD_cParameter</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)" class="member-name-link">ZSTD_CCtx_setPledgedSrcSize</a><wbr>(long&nbsp;cctx,
 long&nbsp;pledgedSrcSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Total input data size to be compressed as a single frame.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_compress(java.nio.ByteBuffer,java.nio.ByteBuffer,int)" class="member-name-link">ZSTD_compress</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Compresses <code>src</code> content as a single zstd compressed frame into already allocated <code>dst</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_compress_usingCDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)" class="member-name-link">ZSTD_compress_usingCDict</a><wbr>(long&nbsp;cctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 long&nbsp;cdict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Compression using a digested Dictionary.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_compress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,int)" class="member-name-link">ZSTD_compress_usingDict</a><wbr>(long&nbsp;ctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Compression at an explicit compression level using a Dictionary.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)" class="member-name-link">ZSTD_compress2</a><wbr>(long&nbsp;cctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves the same as <a href="#ZSTD_compressCCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compressCCtx</code></a>, but compression parameters are set using the advanced API.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_compressBound(long)" class="member-name-link">ZSTD_compressBound</a><wbr>(long&nbsp;srcSize)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the maximum compressed size in worst case single-pass scenario.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_COMPRESSBOUND(long)" class="member-name-link">ZSTD_COMPRESSBOUND</a><wbr>(long&nbsp;srcSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Pure Java version of <a href="#ZSTD_compressBound(long)"><code>ZSTD_compressBound(long)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_compressCCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer,int)" class="member-name-link">ZSTD_compressCCtx</a><wbr>(long&nbsp;ctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Same as <a href="#ZSTD_compress(java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress</code></a>, using an explicit <code>ZSTD_CCtx</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)" class="member-name-link">ZSTD_compressStream2</a><wbr>(long&nbsp;cctx,
 <a href="ZSTDOutBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDOutBuffer</a>&nbsp;output,
 <a href="ZSTDInBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDInBuffer</a>&nbsp;input,
 int&nbsp;endOp)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves about the same as <code>ZSTD_compressStream()</code>, with additional control on end directive.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_cParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)" class="member-name-link">ZSTD_cParam_getBounds</a><wbr>(int&nbsp;cParam,
 <a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a>&nbsp;__result)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_createCCtx()" class="member-name-link">ZSTD_createCCtx</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a compression context.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_createCDict(java.nio.ByteBuffer,int)" class="member-name-link">ZSTD_createCDict</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dictBuffer,
 int&nbsp;compressionLevel)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">When compressing multiple messages or blocks using the same dictionary, it's recommended to digest the dictionary only once, since it's a costly
 operation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_createCStream()" class="member-name-link">ZSTD_createCStream</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A <code>ZSTD_CStream</code> object is required to track streaming operation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_createDCtx()" class="member-name-link">ZSTD_createDCtx</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a decompression context.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_createDDict(java.nio.ByteBuffer)" class="member-name-link">ZSTD_createDDict</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dictBuffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a digested dictionary, ready to start decompression operation without startup delay.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_createDStream()" class="member-name-link">ZSTD_createDStream</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A <code>ZSTD_DStream</code> object is required to track streaming operations.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CStreamInSize()" class="member-name-link">ZSTD_CStreamInSize</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the recommended size for input buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_CStreamOutSize()" class="member-name-link">ZSTD_CStreamOutSize</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the recommended size for output buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_DCtx_loadDictionary(long,java.nio.ByteBuffer)" class="member-name-link">ZSTD_DCtx_loadDictionary</a><wbr>(long&nbsp;dctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create an internal <code>DDict</code> from <code>dict</code> buffer, to be used to decompress next frames.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_DCtx_refDDict(long,long)" class="member-name-link">ZSTD_DCtx_refDDict</a><wbr>(long&nbsp;dctx,
 long&nbsp;ddict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">References a prepared dictionary, to be used to decompress next frames.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_DCtx_refPrefix(long,java.nio.ByteBuffer)" class="member-name-link">ZSTD_DCtx_refPrefix</a><wbr>(long&nbsp;dctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;prefix)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">References a prefix (single-usage dictionary) to decompress next frame.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_DCtx_reset(long,int)" class="member-name-link">ZSTD_DCtx_reset</a><wbr>(long&nbsp;dctx,
 int&nbsp;reset)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a <code>DCtx</code> to clean state.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_DCtx_setParameter(long,int,int)" class="member-name-link">ZSTD_DCtx_setParameter</a><wbr>(long&nbsp;dctx,
 int&nbsp;param,
 int&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set one compression parameter, selected by <code>enum ZSTD_dParameter</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)" class="member-name-link">ZSTD_decompress</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_decompress_usingDDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)" class="member-name-link">ZSTD_decompress_usingDDict</a><wbr>(long&nbsp;dctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 long&nbsp;ddict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decompression using a digested Dictionary.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_decompress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer)" class="member-name-link">ZSTD_decompress_usingDict</a><wbr>(long&nbsp;dctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decompression using a known Dictionary.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)" class="member-name-link">ZSTD_decompressDCtx</a><wbr>(long&nbsp;ctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Same as <a href="#ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress</code></a>, requires an allocated <code>ZSTD_DCtx</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)" class="member-name-link">ZSTD_decompressStream</a><wbr>(long&nbsp;zds,
 <a href="ZSTDOutBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDOutBuffer</a>&nbsp;output,
 <a href="ZSTDInBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDInBuffer</a>&nbsp;input)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Use <code>ZSTD_decompressStream()</code> repetitively to consume your input.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_defaultCLevel()" class="member-name-link">ZSTD_defaultCLevel</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the default compression level, specified by <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_dParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)" class="member-name-link">ZSTD_dParam_getBounds</a><wbr>(int&nbsp;dParam,
 <a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a>&nbsp;__result)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_DStreamInSize()" class="member-name-link">ZSTD_DStreamInSize</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the recommended size for input buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_DStreamOutSize()" class="member-name-link">ZSTD_DStreamOutSize</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the recommended size for output buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_findFrameCompressedSize(java.nio.ByteBuffer)" class="member-name-link">ZSTD_findFrameCompressedSize</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_freeCCtx(long)" class="member-name-link">ZSTD_freeCCtx</a><wbr>(long&nbsp;cctx)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory allocated by <a href="#ZSTD_createCCtx()"><code>createCCtx</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_freeCDict(long)" class="member-name-link">ZSTD_freeCDict</a><wbr>(long&nbsp;CDict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory allocated by <a href="#ZSTD_createCDict(java.nio.ByteBuffer,int)"><code>createCDict</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_freeCStream(long)" class="member-name-link">ZSTD_freeCStream</a><wbr>(long&nbsp;zcs)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory allocated by <a href="#ZSTD_createCStream()"><code>createCStream</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_freeDCtx(long)" class="member-name-link">ZSTD_freeDCtx</a><wbr>(long&nbsp;dctx)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory allocated by <a href="#ZSTD_createDCtx()"><code>createDCtx</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_freeDDict(long)" class="member-name-link">ZSTD_freeDDict</a><wbr>(long&nbsp;ddict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory allocated with <a href="#ZSTD_createDDict(java.nio.ByteBuffer)"><code>createDDict</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_freeDStream(long)" class="member-name-link">ZSTD_freeDStream</a><wbr>(long&nbsp;zds)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory allocated by <a href="#ZSTD_createDStream()"><code>createDStream</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_getDictID_fromCDict(long)" class="member-name-link">ZSTD_getDictID_fromCDict</a><wbr>(long&nbsp;cdict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Provides the <code>dictID</code> of the dictionary loaded into <code>cdict</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_getDictID_fromDDict(long)" class="member-name-link">ZSTD_getDictID_fromDDict</a><wbr>(long&nbsp;ddict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Provides the <code>dictID</code> of the dictionary loaded into <code>ddict</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_getDictID_fromDict(java.nio.ByteBuffer)" class="member-name-link">ZSTD_getDictID_fromDict</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Provides the <code>dictID</code> stored within dictionary.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_getDictID_fromFrame(java.nio.ByteBuffer)" class="member-name-link">ZSTD_getDictID_fromFrame</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Provides the dictID required to decompressed the frame stored within <code>src</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_getErrorName(long)" class="member-name-link">ZSTD_getErrorName</a><wbr>(long&nbsp;code)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Provides readable string from an error code.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_getFrameContentSize(java.nio.ByteBuffer)" class="member-name-link">ZSTD_getFrameContentSize</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Notes:
 
 
 a 0 return value means the frame is valid but "empty"
 decompressed size is an optional field, it may not be present, typically in streaming mode.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_isError(long)" class="member-name-link">ZSTD_isError</a><wbr>(long&nbsp;code)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Tells if a <code>size_t</code> function result is an error code.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_maxCLevel()" class="member-name-link">ZSTD_maxCLevel</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the maximum compression level available.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_minCLevel()" class="member-name-link">ZSTD_minCLevel</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the minimum compression level available.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_sizeof_CCtx(long)" class="member-name-link">ZSTD_sizeof_CCtx</a><wbr>(long&nbsp;cctx)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_sizeof_CDict(long)" class="member-name-link">ZSTD_sizeof_CDict</a><wbr>(long&nbsp;cdict)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_sizeof_CStream(long)" class="member-name-link">ZSTD_sizeof_CStream</a><wbr>(long&nbsp;zcs)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_sizeof_DCtx(long)" class="member-name-link">ZSTD_sizeof_DCtx</a><wbr>(long&nbsp;dctx)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_sizeof_DDict(long)" class="member-name-link">ZSTD_sizeof_DDict</a><wbr>(long&nbsp;ddict)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_sizeof_DStream(long)" class="member-name-link">ZSTD_sizeof_DStream</a><wbr>(long&nbsp;zds)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_versionNumber()" class="member-name-link">ZSTD_versionNumber</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns runtime library version, the value is <code>(MAJOR*100*100 + MINOR*100 + RELEASE)</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#ZSTD_versionString()" class="member-name-link">ZSTD_versionString</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns runtime library version, like "1.4.5".</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="ZSTD_VERSION_MAJOR">
<h3>ZSTD_VERSION_MAJOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_VERSION_MAJOR</span></div>
<div class="block">Version number part.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_VERSION_MAJOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_VERSION_MINOR">
<h3>ZSTD_VERSION_MINOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_VERSION_MINOR</span></div>
<div class="block">Version number part.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_VERSION_MINOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_VERSION_RELEASE">
<h3>ZSTD_VERSION_RELEASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_VERSION_RELEASE</span></div>
<div class="block">Version number part.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_VERSION_RELEASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_VERSION_NUMBER">
<h3>ZSTD_VERSION_NUMBER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_VERSION_NUMBER</span></div>
<div class="block">Version number.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_VERSION_NUMBER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_VERSION_STRING">
<h3>ZSTD_VERSION_STRING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">ZSTD_VERSION_STRING</span></div>
<div class="block">Version string.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_VERSION_STRING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CLEVEL_DEFAULT">
<h3>ZSTD_CLEVEL_DEFAULT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_CLEVEL_DEFAULT</span></div>
<div class="block">Default compression level.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_CLEVEL_DEFAULT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_MAGICNUMBER">
<h3>ZSTD_MAGICNUMBER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_MAGICNUMBER</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_MAGICNUMBER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_MAGIC_DICTIONARY">
<h3>ZSTD_MAGIC_DICTIONARY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_MAGIC_DICTIONARY</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_MAGIC_DICTIONARY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_MAGIC_SKIPPABLE_START">
<h3>ZSTD_MAGIC_SKIPPABLE_START</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_MAGIC_SKIPPABLE_START</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_MAGIC_SKIPPABLE_START">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_MAGIC_SKIPPABLE_MASK">
<h3>ZSTD_MAGIC_SKIPPABLE_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_MAGIC_SKIPPABLE_MASK</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_MAGIC_SKIPPABLE_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_BLOCKSIZELOG_MAX">
<h3>ZSTD_BLOCKSIZELOG_MAX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_BLOCKSIZELOG_MAX</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_BLOCKSIZELOG_MAX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_BLOCKSIZE_MAX">
<h3>ZSTD_BLOCKSIZE_MAX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_BLOCKSIZE_MAX</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_BLOCKSIZE_MAX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CONTENTSIZE_UNKNOWN">
<h3>ZSTD_CONTENTSIZE_UNKNOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CONTENTSIZE_UNKNOWN</span></div>
<div class="block">Content size.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_CONTENTSIZE_UNKNOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CONTENTSIZE_ERROR">
<h3>ZSTD_CONTENTSIZE_ERROR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CONTENTSIZE_ERROR</span></div>
<div class="block">Content size.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_CONTENTSIZE_ERROR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_fast">
<h3>ZSTD_fast</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_fast</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_fast">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_dfast">
<h3>ZSTD_dfast</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_dfast</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_dfast">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_greedy">
<h3>ZSTD_greedy</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_greedy</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_greedy">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_lazy">
<h3>ZSTD_lazy</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_lazy</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_lazy">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_lazy2">
<h3>ZSTD_lazy2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_lazy2</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_lazy2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_btlazy2">
<h3>ZSTD_btlazy2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_btlazy2</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_btlazy2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_btopt">
<h3>ZSTD_btopt</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_btopt</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_btopt">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_btultra">
<h3>ZSTD_btultra</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_btultra</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_btultra">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_btultra2">
<h3>ZSTD_btultra2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_btultra2</span></div>
<div class="block">Compression strategies, listed from fastest to strongest. (<code>ZSTD_strategy</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_fast"><code>fast</code></a></li>
 <li><a href="#ZSTD_dfast"><code>dfast</code></a></li>
 <li><a href="#ZSTD_greedy"><code>greedy</code></a></li>
 <li><a href="#ZSTD_lazy"><code>lazy</code></a></li>
 <li><a href="#ZSTD_lazy2"><code>lazy2</code></a></li>
 <li><a href="#ZSTD_btlazy2"><code>btlazy2</code></a></li>
 <li><a href="#ZSTD_btopt"><code>btopt</code></a></li>
 <li><a href="#ZSTD_btultra"><code>btultra</code></a></li>
 <li><a href="#ZSTD_btultra2"><code>btultra2</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_btultra2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_compressionLevel">
<h3>ZSTD_c_compressionLevel</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_compressionLevel</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_compressionLevel">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_windowLog">
<h3>ZSTD_c_windowLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_windowLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_windowLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_hashLog">
<h3>ZSTD_c_hashLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_hashLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_hashLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_chainLog">
<h3>ZSTD_c_chainLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_chainLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_chainLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_searchLog">
<h3>ZSTD_c_searchLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_searchLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_searchLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_minMatch">
<h3>ZSTD_c_minMatch</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_minMatch</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_minMatch">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_targetLength">
<h3>ZSTD_c_targetLength</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_targetLength</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_targetLength">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_strategy">
<h3>ZSTD_c_strategy</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_strategy</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_strategy">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_enableLongDistanceMatching">
<h3>ZSTD_c_enableLongDistanceMatching</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_enableLongDistanceMatching</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_enableLongDistanceMatching">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_ldmHashLog">
<h3>ZSTD_c_ldmHashLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_ldmHashLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_ldmHashLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_ldmMinMatch">
<h3>ZSTD_c_ldmMinMatch</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_ldmMinMatch</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_ldmMinMatch">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_ldmBucketSizeLog">
<h3>ZSTD_c_ldmBucketSizeLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_ldmBucketSizeLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_ldmBucketSizeLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_ldmHashRateLog">
<h3>ZSTD_c_ldmHashRateLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_ldmHashRateLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_ldmHashRateLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_contentSizeFlag">
<h3>ZSTD_c_contentSizeFlag</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_contentSizeFlag</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_contentSizeFlag">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_checksumFlag">
<h3>ZSTD_c_checksumFlag</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_checksumFlag</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_checksumFlag">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_dictIDFlag">
<h3>ZSTD_c_dictIDFlag</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_dictIDFlag</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_dictIDFlag">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_nbWorkers">
<h3>ZSTD_c_nbWorkers</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_nbWorkers</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_nbWorkers">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_jobSize">
<h3>ZSTD_c_jobSize</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_jobSize</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_jobSize">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_overlapLog">
<h3>ZSTD_c_overlapLog</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_overlapLog</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_overlapLog">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam1">
<h3>ZSTD_c_experimentalParam1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam1</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam1">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam2">
<h3>ZSTD_c_experimentalParam2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam2</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam3">
<h3>ZSTD_c_experimentalParam3</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam3</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam3">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam4">
<h3>ZSTD_c_experimentalParam4</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam4</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam4">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam5">
<h3>ZSTD_c_experimentalParam5</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam5</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam5">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam6">
<h3>ZSTD_c_experimentalParam6</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam6</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam6">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam7">
<h3>ZSTD_c_experimentalParam7</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam7</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam7">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam8">
<h3>ZSTD_c_experimentalParam8</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam8</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam8">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam9">
<h3>ZSTD_c_experimentalParam9</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam9</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam9">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam10">
<h3>ZSTD_c_experimentalParam10</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam10</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam10">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam11">
<h3>ZSTD_c_experimentalParam11</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam11</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam11">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam12">
<h3>ZSTD_c_experimentalParam12</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam12</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam12">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam13">
<h3>ZSTD_c_experimentalParam13</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam13</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam13">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam14">
<h3>ZSTD_c_experimentalParam14</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam14</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam14">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_c_experimentalParam15">
<h3>ZSTD_c_experimentalParam15</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_c_experimentalParam15</span></div>
<div class="block">Compression parameters. (<code>ZSTD_cParameter</code>)
 
 <p>Note: When compressing with a <code>ZSTD_CDict</code> these parameters are superseded by the parameters used to construct the <code>ZSTD_CDict</code>. See
 <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a> for more info.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a> - 
 Set compression parameters according to pre-defined <code>cLevel</code> table.
 
 <p>Note that exact compression parameters are dynamically determined, depending on both compression level and <code>srcSize</code> (when known). Default
 level is <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a><code>==3</code>. Special: value 0 means default, which is controlled by <code>ZSTD_CLEVEL_DEFAULT</code>.</p>
 
 <p>Note 1: it's possible to pass a negative compression level.</p>
 
 <p>Note 2: setting a level does not automatically set all other compression parameters to default. Setting this will however eventually dynamically
 impact the compression parameters which have not been manually set. The manually set ones will 'stick'.</p>
 </li>
 <li><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> - 
 Maximum allowed back-reference distance, expressed as power of 2.
 
 <p>This will set a memory budget for streaming decompression, with larger values requiring more memory and typically compressing more. Must be clamped
 between <a href="ZstdX.html#ZSTD_WINDOWLOG_MIN"><code>WINDOWLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a>. Special: value 0 means "use default <code>windowLog</code>".</p>
 
 <p>Note: Using a <code>windowLog</code> greater than <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a> requires explicitly allowing such size at streaming decompression stage.</p>
 </li>
 <li><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a> - 
 Size of the initial probe table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(hashLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a>. Larger tables improve
 compression ratio of strategies &le; dFast, and improve speed of strategies &gt; dFast. Special: value 0 means "use default <code>hashLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a> - 
 Size of the multi-probe search table, as a power of 2.
 
 <p>Resulting memory usage is (1 &lt;&lt; <code>(chainLog+2)</code>). Must be clamped between <a href="ZstdX.html#ZSTD_CHAINLOG_MIN"><code>CHAINLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_CHAINLOG_MAX"><code>CHAINLOG_MAX</code></a>. Larger tables result in
 better and slower compression. This parameter is useless for "fast" strategy. It's still useful when using "dfast" strategy, in which case it
 defines a secondary probe table. Special: value 0 means "use default <code>chainLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a> - 
 Number of search attempts, as a power of 2.
 
 <p>More attempts result in better and slower compression. This parameter is useless for "fast" and "dFast" strategies. Special: value 0 means "use
 default <code>searchLog</code>".</p>
 </li>
 <li><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a> - 
 Minimum size of searched matches. Note that Zstandard can still find matches of smaller size, it just tweaks its search algorithm to look for this
 size and larger. Larger values increase compression and decompression speed, but decrease ratio. Must be clamped between <a href="ZstdX.html#ZSTD_MINMATCH_MIN"><code>MINMATCH_MIN</code></a> and
 <a href="ZstdX.html#ZSTD_MINMATCH_MAX"><code>MINMATCH_MAX</code></a>. Note that currently, for all strategies &lt;btopt, effective minimum is 4. , for all strategies &gt; fast, effective maximum is 6.
 Special: value 0 means "use default <code>minMatchLength</code>".
 </li>
 <li><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a> - 
 Impact of this field depends on strategy. For strategies btopt, btultra &amp; btultra2: Length of Match considered "good enough" to stop search.
 Larger values make compression stronger, and slower. For strategy fast: Distance between match sampling. Larger values make compression faster, and
 weaker. Special: value 0 means "use default targetLength".
 </li>
 <li><a href="#ZSTD_c_strategy"><code>c_strategy</code></a> - 
 See <code>ZSTD_strategy</code> enum definition. The higher the value of selected strategy, the more complex it is, resulting in stronger and slower
 compression. Special: value 0 means "use default strategy".
 </li>
 <li><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a> - 
 Enable long distance matching. This parameter is designed to improve compression ratio for large inputs, by finding large matches at long distance.
 It increases memory usage and window size. Note: enabling this parameter increases default <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a> to 128 MB except when expressly set to a
 different value. Note: will be enabled by default if <code>ZSTD_c_windowLog &amp;ge; 128 MB</code> and compression strategy
 <code>&amp;ge; ZSTD_btopt (== compression level 16+)</code>.
 </li>
 <li><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a> - 
 Size of the table for long distance matching, as a power of 2. Larger values increase memory usage and compression ratio, but decrease compression
 speed. Must be clamped between <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a> and <a href="ZstdX.html#ZSTD_HASHLOG_MAX"><code>HASHLOG_MAX</code></a> default: windowlog - 7. Special: value 0 means "automatically determine hashlog".
 </li>
 <li><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a> - 
 Minimum match size for long distance matcher. Larger/too small values usually decrease compression ratio. Must be clamped between <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MIN"><code>LDM_MINMATCH_MIN</code></a>
 and <a href="ZstdX.html#ZSTD_LDM_MINMATCH_MAX"><code>LDM_MINMATCH_MAX</code></a>. Special: value 0 means "use default value" (default: 64).
 </li>
 <li><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a> - 
 Log size of each bucket in the LDM hash table for collision resolution. Larger values improve collision resolution but decrease compression speed.
 The maximum value is <a href="ZstdX.html#ZSTD_LDM_BUCKETSIZELOG_MAX"><code>LDM_BUCKETSIZELOG_MAX</code></a>. Special: value 0 means "use default value" (default: 3).
 </li>
 <li><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a> - 
 Frequency of inserting/looking up entries into the LDM hash table. Must be clamped between 0 and (<a href="ZstdX.html#ZSTD_WINDOWLOG_MAX"><code>WINDOWLOG_MAX</code></a> - <a href="ZstdX.html#ZSTD_HASHLOG_MIN"><code>HASHLOG_MIN</code></a>). Default
 is <code>MAX(0, (windowLog - ldmHashLog))</code>, optimizing hash table usage. Larger values improve compression speed. Deviating far from default value
 will likely result in a compression ratio decrease. Special: value 0 means "automatically determine <code>hashRateLog</code>".
 </li>
 <li><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a> - 
 Content size will be written into frame header _whenever known_ (default:1) Content size must be known at the beginning of compression. This is
 automatically the case when using <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, For streaming scenarios, content size must be provided with <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a>.
 </li>
 <li><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a> - A 32-bits checksum of content is written at end of frame (default:0)</li>
 <li><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a> - When applicable, dictionary's ID is written into frame header (default:1)</li>
 <li><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a> - 
 Select how many threads will be spawned to compress in parallel.
 
 <p>When <code>nbWorkers &amp;ge; 1</code>, triggers asynchronous mode when invoking <code>ZSTD_compressStream*()</code>: <code>ZSTD_compressStream*()</code> consumes
 input and flush output if possible, but immediately gives back control to caller, while compression work is performed in parallel, within worker
 thread(s). (note: a strong exception to this rule is when first invocation of <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a> sets <a href="#ZSTD_e_end"><code>e_end</code></a>: in which case,
 <code>ZSTD_compressStream2()</code> delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, which is always a blocking call). More workers improve speed, but also increase memory
 usage.</p>
 
 <p>Default value is <code>0</code>, aka "single-threaded mode": no worker is spawned, compression is performed inside Caller's thread, and all invocations
 are blocking.</p>
 </li>
 <li><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a> - 
 Size of a compression job. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>. Each compression job is completed in parallel, so this value
 can indirectly impact the nb of active threads. 0 means default, which is dynamically determined based on compression parameters. Job size must be
 a minimum of overlap size, or <code>ZSTDMT_JOBSIZE_MIN</code> (= 512 KB), whichever is largest. The minimum size is automatically and transparently
 enforced.
 </li>
 <li><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a> - 
 Control the overlap size, as a fraction of window size. The overlap size is an amount of data reloaded from previous job at the beginning of a new
 job. It helps preserve compression ratio, while each job is compressed in parallel. This value is enforced only when <code>nbWorkers &amp;ge; 1</code>.
 Larger values increase compression ratio, but decrease speed. Possible values range from 0 to 9:
 
 <ul>
 <li>0 means "default" : value will be determined by the library, depending on strategy</li>
 <li>1 means "no overlap"</li>
 <li>9 means "full overlap", using a full window size. Each intermediate rank increases/decreases load size by a factor 2: 9: full window; 8: w/2;
 7: w/4; 6: w/8; 5:w/16; 4: w/32; 3:w/64; 2:w/128; 1:no overlap; 0:default default value varies between 6 and 9, depending on strategy</li>
 </ul>
 </li>
 <li><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></li>
 <li><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_c_experimentalParam15">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_reset_session_only">
<h3>ZSTD_reset_session_only</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_reset_session_only</span></div>
<div class="block"><code>ZSTD_ResetDirective</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_reset_session_only"><code>reset_session_only</code></a></li>
 <li><a href="#ZSTD_reset_parameters"><code>reset_parameters</code></a></li>
 <li><a href="#ZSTD_reset_session_and_parameters"><code>reset_session_and_parameters</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_reset_session_only">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_reset_parameters">
<h3>ZSTD_reset_parameters</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_reset_parameters</span></div>
<div class="block"><code>ZSTD_ResetDirective</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_reset_session_only"><code>reset_session_only</code></a></li>
 <li><a href="#ZSTD_reset_parameters"><code>reset_parameters</code></a></li>
 <li><a href="#ZSTD_reset_session_and_parameters"><code>reset_session_and_parameters</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_reset_parameters">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_reset_session_and_parameters">
<h3>ZSTD_reset_session_and_parameters</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_reset_session_and_parameters</span></div>
<div class="block"><code>ZSTD_ResetDirective</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_reset_session_only"><code>reset_session_only</code></a></li>
 <li><a href="#ZSTD_reset_parameters"><code>reset_parameters</code></a></li>
 <li><a href="#ZSTD_reset_session_and_parameters"><code>reset_session_and_parameters</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_reset_session_and_parameters">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_d_windowLogMax">
<h3>ZSTD_d_windowLogMax</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_d_windowLogMax</span></div>
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context. Parameters are sticky, and remain valid for all following frames
 using the same <code>DCtx</code> context. It's possible to reset parameters to default values using <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a>.
 
 <p>Note: This API is compatible with existing <a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompressDCtx</code></a> and <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a>. Therefore, no new decompression function is necessary.</p>
 
 <p>(<code>ZSTD_dParameter</code>)</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_d_windowLogMax"><code>d_windowLogMax</code></a> - 
 Select a size limit (in power of 2) beyond which the streaming API will refuse to allocate memory buffer in order to protect the host from
 unreasonable memory requirements.
 
 <p>This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode. By default, a decompression context
 accepts window sizes &le; (1 &lt;&lt; <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a>)</p>
 
 <p>Special: value 0 means "use default maximum windowLog".</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam1"><code>d_experimentalParam1</code></a> - 
 Note: additional experimental parameters are also available within the experimental section of the API. At the time of this writing, they include:
 
 <ul>
 <li><a href="ZstdX.html#ZSTD_d_format"><code>d_format</code></a></li>
 <li><a href="ZstdX.html#ZSTD_d_stableOutBuffer"><code>d_stableOutBuffer</code></a></li>
 </ul>
 
 <p>Note: never ever use <code>experimentalParam</code>? names directly</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam2"><code>d_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam3"><code>d_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam4"><code>d_experimentalParam4</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_d_windowLogMax">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_d_experimentalParam1">
<h3>ZSTD_d_experimentalParam1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_d_experimentalParam1</span></div>
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context. Parameters are sticky, and remain valid for all following frames
 using the same <code>DCtx</code> context. It's possible to reset parameters to default values using <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a>.
 
 <p>Note: This API is compatible with existing <a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompressDCtx</code></a> and <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a>. Therefore, no new decompression function is necessary.</p>
 
 <p>(<code>ZSTD_dParameter</code>)</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_d_windowLogMax"><code>d_windowLogMax</code></a> - 
 Select a size limit (in power of 2) beyond which the streaming API will refuse to allocate memory buffer in order to protect the host from
 unreasonable memory requirements.
 
 <p>This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode. By default, a decompression context
 accepts window sizes &le; (1 &lt;&lt; <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a>)</p>
 
 <p>Special: value 0 means "use default maximum windowLog".</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam1"><code>d_experimentalParam1</code></a> - 
 Note: additional experimental parameters are also available within the experimental section of the API. At the time of this writing, they include:
 
 <ul>
 <li><a href="ZstdX.html#ZSTD_d_format"><code>d_format</code></a></li>
 <li><a href="ZstdX.html#ZSTD_d_stableOutBuffer"><code>d_stableOutBuffer</code></a></li>
 </ul>
 
 <p>Note: never ever use <code>experimentalParam</code>? names directly</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam2"><code>d_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam3"><code>d_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam4"><code>d_experimentalParam4</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_d_experimentalParam1">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_d_experimentalParam2">
<h3>ZSTD_d_experimentalParam2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_d_experimentalParam2</span></div>
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context. Parameters are sticky, and remain valid for all following frames
 using the same <code>DCtx</code> context. It's possible to reset parameters to default values using <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a>.
 
 <p>Note: This API is compatible with existing <a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompressDCtx</code></a> and <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a>. Therefore, no new decompression function is necessary.</p>
 
 <p>(<code>ZSTD_dParameter</code>)</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_d_windowLogMax"><code>d_windowLogMax</code></a> - 
 Select a size limit (in power of 2) beyond which the streaming API will refuse to allocate memory buffer in order to protect the host from
 unreasonable memory requirements.
 
 <p>This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode. By default, a decompression context
 accepts window sizes &le; (1 &lt;&lt; <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a>)</p>
 
 <p>Special: value 0 means "use default maximum windowLog".</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam1"><code>d_experimentalParam1</code></a> - 
 Note: additional experimental parameters are also available within the experimental section of the API. At the time of this writing, they include:
 
 <ul>
 <li><a href="ZstdX.html#ZSTD_d_format"><code>d_format</code></a></li>
 <li><a href="ZstdX.html#ZSTD_d_stableOutBuffer"><code>d_stableOutBuffer</code></a></li>
 </ul>
 
 <p>Note: never ever use <code>experimentalParam</code>? names directly</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam2"><code>d_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam3"><code>d_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam4"><code>d_experimentalParam4</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_d_experimentalParam2">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_d_experimentalParam3">
<h3>ZSTD_d_experimentalParam3</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_d_experimentalParam3</span></div>
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context. Parameters are sticky, and remain valid for all following frames
 using the same <code>DCtx</code> context. It's possible to reset parameters to default values using <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a>.
 
 <p>Note: This API is compatible with existing <a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompressDCtx</code></a> and <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a>. Therefore, no new decompression function is necessary.</p>
 
 <p>(<code>ZSTD_dParameter</code>)</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_d_windowLogMax"><code>d_windowLogMax</code></a> - 
 Select a size limit (in power of 2) beyond which the streaming API will refuse to allocate memory buffer in order to protect the host from
 unreasonable memory requirements.
 
 <p>This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode. By default, a decompression context
 accepts window sizes &le; (1 &lt;&lt; <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a>)</p>
 
 <p>Special: value 0 means "use default maximum windowLog".</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam1"><code>d_experimentalParam1</code></a> - 
 Note: additional experimental parameters are also available within the experimental section of the API. At the time of this writing, they include:
 
 <ul>
 <li><a href="ZstdX.html#ZSTD_d_format"><code>d_format</code></a></li>
 <li><a href="ZstdX.html#ZSTD_d_stableOutBuffer"><code>d_stableOutBuffer</code></a></li>
 </ul>
 
 <p>Note: never ever use <code>experimentalParam</code>? names directly</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam2"><code>d_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam3"><code>d_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam4"><code>d_experimentalParam4</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_d_experimentalParam3">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_d_experimentalParam4">
<h3>ZSTD_d_experimentalParam4</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_d_experimentalParam4</span></div>
<div class="block">The advanced API pushes parameters one by one into an existing <code>DCtx</code> context. Parameters are sticky, and remain valid for all following frames
 using the same <code>DCtx</code> context. It's possible to reset parameters to default values using <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a>.
 
 <p>Note: This API is compatible with existing <a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompressDCtx</code></a> and <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a>. Therefore, no new decompression function is necessary.</p>
 
 <p>(<code>ZSTD_dParameter</code>)</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_d_windowLogMax"><code>d_windowLogMax</code></a> - 
 Select a size limit (in power of 2) beyond which the streaming API will refuse to allocate memory buffer in order to protect the host from
 unreasonable memory requirements.
 
 <p>This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode. By default, a decompression context
 accepts window sizes &le; (1 &lt;&lt; <a href="ZstdX.html#ZSTD_WINDOWLOG_LIMIT_DEFAULT"><code>WINDOWLOG_LIMIT_DEFAULT</code></a>)</p>
 
 <p>Special: value 0 means "use default maximum windowLog".</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam1"><code>d_experimentalParam1</code></a> - 
 Note: additional experimental parameters are also available within the experimental section of the API. At the time of this writing, they include:
 
 <ul>
 <li><a href="ZstdX.html#ZSTD_d_format"><code>d_format</code></a></li>
 <li><a href="ZstdX.html#ZSTD_d_stableOutBuffer"><code>d_stableOutBuffer</code></a></li>
 </ul>
 
 <p>Note: never ever use <code>experimentalParam</code>? names directly</p>
 </li>
 <li><a href="#ZSTD_d_experimentalParam2"><code>d_experimentalParam2</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam3"><code>d_experimentalParam3</code></a></li>
 <li><a href="#ZSTD_d_experimentalParam4"><code>d_experimentalParam4</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_d_experimentalParam4">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_e_continue">
<h3>ZSTD_e_continue</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_e_continue</span></div>
<div class="block"><code>ZSTD_EndDirective</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_e_continue"><code>e_continue</code></a> - collect more data, encoder decides when to output compressed result, for optimal compression ratio</li>
 <li><a href="#ZSTD_e_flush"><code>e_flush</code></a> - 
 flush any data provided so far, it creates (at least) one new block, that can be decoded immediately on reception; frame will continue: any future
 data can still reference previously compressed data, improving compression.
 </li>
 <li><a href="#ZSTD_e_end"><code>e_end</code></a> - 
 flush any remaining data <em>and</em> close current frame. note that frame is only closed after compressed data is fully flushed (return
 <code>value == 0</code>). After that point, any additional data starts a new frame.
 
 <p>Note: each frame is independent (does not reference any content from previous frame).</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_e_continue">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_e_flush">
<h3>ZSTD_e_flush</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_e_flush</span></div>
<div class="block"><code>ZSTD_EndDirective</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_e_continue"><code>e_continue</code></a> - collect more data, encoder decides when to output compressed result, for optimal compression ratio</li>
 <li><a href="#ZSTD_e_flush"><code>e_flush</code></a> - 
 flush any data provided so far, it creates (at least) one new block, that can be decoded immediately on reception; frame will continue: any future
 data can still reference previously compressed data, improving compression.
 </li>
 <li><a href="#ZSTD_e_end"><code>e_end</code></a> - 
 flush any remaining data <em>and</em> close current frame. note that frame is only closed after compressed data is fully flushed (return
 <code>value == 0</code>). After that point, any additional data starts a new frame.
 
 <p>Note: each frame is independent (does not reference any content from previous frame).</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_e_flush">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_e_end">
<h3>ZSTD_e_end</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_e_end</span></div>
<div class="block"><code>ZSTD_EndDirective</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#ZSTD_e_continue"><code>e_continue</code></a> - collect more data, encoder decides when to output compressed result, for optimal compression ratio</li>
 <li><a href="#ZSTD_e_flush"><code>e_flush</code></a> - 
 flush any data provided so far, it creates (at least) one new block, that can be decoded immediately on reception; frame will continue: any future
 data can still reference previously compressed data, improving compression.
 </li>
 <li><a href="#ZSTD_e_end"><code>e_end</code></a> - 
 flush any remaining data <em>and</em> close current frame. note that frame is only closed after compressed data is fully flushed (return
 <code>value == 0</code>). After that point, any additional data starts a new frame.
 
 <p>Note: each frame is independent (does not reference any content from previous frame).</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.zstd.Zstd.ZSTD_e_end">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="ZSTD_versionNumber()">
<h3>ZSTD_versionNumber</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_versionNumber</span>()</div>
<div class="block">Returns runtime library version, the value is <code>(MAJOR*100*100 + MINOR*100 + RELEASE)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_versionString()">
<h3>nZSTD_versionString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_versionString</span>()</div>
<div class="block">Unsafe version of: <a href="#ZSTD_versionString()"><code>versionString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_versionString()">
<h3>ZSTD_versionString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">ZSTD_versionString</span>()</div>
<div class="block">Returns runtime library version, like "1.4.5".</div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_compress(long,long,long,long,int)">
<h3>nZSTD_compress</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_compress</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 int&nbsp;compressionLevel)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_compress(java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_compress(java.nio.ByteBuffer,java.nio.ByteBuffer,int)">
<h3>ZSTD_compress</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_compress</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 int&nbsp;compressionLevel)</span></div>
<div class="block">Compresses <code>src</code> content as a single zstd compressed frame into already allocated <code>dst</code>.
 
 <p>Hint: compression runs faster if <code>dstCapacity</code> &ge; <a href="#ZSTD_compressBound(long)"><code>compressBound</code></a><code>(srcSize)</code></p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>compressed size written into <code>dst</code> (&le; <code>dstCapacity</code>), or an error code if it fails (which can be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a>).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_decompress(long,long,long,long)">
<h3>nZSTD_decompress</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_decompress</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;compressedSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dstCapacity</code> - is an upper bound of <code>originalSize</code> to regenerate. If user cannot imply a maximum upper bound, it's better to use streaming mode to
                       decompress data.</dd>
<dd><code>compressedSize</code> - must be the <b>exact</b> size of some number of compressed and/or skippable frames</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)">
<h3>ZSTD_decompress</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_decompress</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</span></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the number of bytes decompressed into <code>dst</code> (&le; <code>dstCapacity</code>), or an <code>errorCode</code> if it fails (which can be tested using
         <a href="#ZSTD_isError(long)"><code>isError</code></a>).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_getFrameContentSize(long,long)">
<h3>nZSTD_getFrameContentSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_getFrameContentSize</span><wbr><span class="parameters">(long&nbsp;src,
 long&nbsp;srcSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_getFrameContentSize(java.nio.ByteBuffer)"><code>getFrameContentSize</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>srcSize</code> - must be at least as large as the frame header. Hint: any size &ge; <a href="ZstdX.html#ZSTD_FRAMEHEADERSIZE_MAX"><code>FRAMEHEADERSIZE_MAX</code></a> is large enough.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_getFrameContentSize(java.nio.ByteBuffer)">
<h3>ZSTD_getFrameContentSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_getFrameContentSize</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</span></div>
<div class="block">Notes:
 
 <ol>
 <li>a 0 return value means the frame is valid but "empty"</li>
 <li>decompressed size is an optional field, it may not be present, typically in streaming mode. When <code>return==ZSTD_CONTENTSIZE_UNKNOWN</code>, data to
 decompress could be any size. In which case, it's necessary to use streaming mode to decompress data. Optionally, application can rely on some
 implicit limit, as <a href="#ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress</code></a> only needs an upper bound of decompressed size. (For example, data could be necessarily cut into blocks &le; 16
 KB).</li>
 <li>decompressed size is always present when compression is completed using single-pass functions, such as <a href="#ZSTD_compress(java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress</code></a>, <a href="#ZSTD_compressCCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compressCCtx</code></a>,
 <a href="#ZSTD_compress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress_usingDict</code></a> or <a href="#ZSTD_compress_usingCDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)"><code>compress_usingCDict</code></a>.</li>
 <li>decompressed size can be very large (64-bits value), potentially larger than what local system can handle as a single memory segment. In which
 case, it's necessary to use streaming mode to decompress data.</li>
 <li>If source is untrusted, decompressed size could be wrong or intentionally modified. Always ensure return value fits within application's authorized
 limits. Each application can set its own limits.</li>
 </ol></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>src</code> - should point to the start of a ZSTD encoded frame</dd>
<dt>Returns:</dt>
<dd>decompressed size of <code>src</code> frame content, if known
         
         <ul>
         <li><a href="#ZSTD_CONTENTSIZE_UNKNOWN"><code>CONTENTSIZE_UNKNOWN</code></a> if the size cannot be determined</li>
         <li><a href="#ZSTD_CONTENTSIZE_ERROR"><code>CONTENTSIZE_ERROR</code></a> if an error occurred (e.g. invalid magic number, <code>srcSize</code> too small)</li>
         </ul></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_findFrameCompressedSize(long,long)">
<h3>nZSTD_findFrameCompressedSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_findFrameCompressedSize</span><wbr><span class="parameters">(long&nbsp;src,
 long&nbsp;srcSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_findFrameCompressedSize(java.nio.ByteBuffer)"><code>findFrameCompressedSize</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>srcSize</code> - must be &ge; first frame size</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_findFrameCompressedSize(java.nio.ByteBuffer)">
<h3>ZSTD_findFrameCompressedSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_findFrameCompressedSize</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</span></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>src</code> - should point to the start of a ZSTD frame or skippable frame</dd>
<dt>Returns:</dt>
<dd>the compressed size of the first frame starting at <code>src</code>, suitable to pass as <code>srcSize</code> to <a href="#ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress</code></a> or similar, or an error code if
         input is invalid</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_compressBound(long)">
<h3>ZSTD_compressBound</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_compressBound</span><wbr><span class="parameters">(long&nbsp;srcSize)</span></div>
<div class="block">Returns the maximum compressed size in worst case single-pass scenario.</div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_isError(long)">
<h3>nZSTD_isError</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nZSTD_isError</span><wbr><span class="parameters">(long&nbsp;code)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_isError(long)"><code>isError</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_isError(long)">
<h3>ZSTD_isError</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">ZSTD_isError</span><wbr><span class="parameters">(long&nbsp;code)</span></div>
<div class="block">Tells if a <code>size_t</code> function result is an error code.</div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_getErrorName(long)">
<h3>nZSTD_getErrorName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_getErrorName</span><wbr><span class="parameters">(long&nbsp;code)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_getErrorName(long)"><code>getErrorName</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_getErrorName(long)">
<h3>ZSTD_getErrorName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">ZSTD_getErrorName</span><wbr><span class="parameters">(long&nbsp;code)</span></div>
<div class="block">Provides readable string from an error code.</div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_minCLevel()">
<h3>ZSTD_minCLevel</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_minCLevel</span>()</div>
<div class="block">Returns the minimum compression level available.</div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_maxCLevel()">
<h3>ZSTD_maxCLevel</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_maxCLevel</span>()</div>
<div class="block">Returns the maximum compression level available.</div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_defaultCLevel()">
<h3>ZSTD_defaultCLevel</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_defaultCLevel</span>()</div>
<div class="block">Returns the default compression level, specified by <a href="#ZSTD_CLEVEL_DEFAULT"><code>CLEVEL_DEFAULT</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_createCCtx()">
<h3>ZSTD_createCCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_createCCtx</span>()</div>
<div class="block">Creates a compression context.
 
 <p>When compressing many times, it is recommended to allocate a context just once, and re-use it for each successive compression operation. This will make
 workload friendlier for system's memory. Use one context per thread for parallel execution in multi-threaded environments.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_freeCCtx(long)">
<h3>ZSTD_freeCCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_freeCCtx</span><wbr><span class="parameters">(long&nbsp;cctx)</span></div>
<div class="block">Frees memory allocated by <a href="#ZSTD_createCCtx()"><code>createCCtx</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cctx</code> - accepts <code>NULL</code> pointer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_compressCCtx(long,long,long,long,long,int)">
<h3>nZSTD_compressCCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_compressCCtx</span><wbr><span class="parameters">(long&nbsp;ctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 int&nbsp;compressionLevel)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_compressCCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compressCCtx</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_compressCCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer,int)">
<h3>ZSTD_compressCCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_compressCCtx</span><wbr><span class="parameters">(long&nbsp;ctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 int&nbsp;compressionLevel)</span></div>
<div class="block">Same as <a href="#ZSTD_compress(java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress</code></a>, using an explicit <code>ZSTD_CCtx</code>.
 
 <p>Important: in order to behave similarly to <code>ZSTD_compress()</code>, this function compresses at requested compression level, <b>ignoring any other
 parameter</b>. If any advanced parameter was set using the advanced API, they will all be reset. Only <code>compressionLevel</code> remains.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_createDCtx()">
<h3>ZSTD_createDCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_createDCtx</span>()</div>
<div class="block">Creates a decompression context.
 
 <p>When decompressing many times, it is recommended to allocate a context only once, and re-use it for each successive compression operation. This will
 make workload friendlier for system's memory. Use one context per thread for parallel execution.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_freeDCtx(long)">
<h3>ZSTD_freeDCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_freeDCtx</span><wbr><span class="parameters">(long&nbsp;dctx)</span></div>
<div class="block">Frees memory allocated by <a href="#ZSTD_createDCtx()"><code>createDCtx</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dctx</code> - accepts <code>NULL</code> pointer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_decompressDCtx(long,long,long,long,long)">
<h3>nZSTD_decompressDCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_decompressDCtx</span><wbr><span class="parameters">(long&nbsp;ctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompressDCtx</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_decompressDCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer)">
<h3>ZSTD_decompressDCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_decompressDCtx</span><wbr><span class="parameters">(long&nbsp;ctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</span></div>
<div class="block">Same as <a href="#ZSTD_decompress(java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress</code></a>, requires an allocated <code>ZSTD_DCtx</code>. Compatible with sticky parameters.</div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_cParam_getBounds(int,long)">
<h3>nZSTD_cParam_getBounds</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nZSTD_cParam_getBounds</span><wbr><span class="parameters">(int&nbsp;cParam,
 long&nbsp;__result)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_cParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)"><code>cParam_getBounds</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_cParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)">
<h3>ZSTD_cParam_getBounds</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a></span>&nbsp;<span class="element-name">ZSTD_cParam_getBounds</span><wbr><span class="parameters">(int&nbsp;cParam,
 <a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a>&nbsp;__result)</span></div>
<div class="block">All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cParam</code> - one of:<br><table><tr><td><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a></td><td><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a></td><td><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a></td><td><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a></td></tr><tr><td><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a></td><td><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a></td><td><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a></td><td><a href="#ZSTD_c_strategy"><code>c_strategy</code></a></td></tr><tr><td><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a></td><td><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a></td><td><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a></td><td><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a></td></tr><tr><td><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a></td><td><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a></td><td><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a></td><td><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a></td></tr><tr><td><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a></td><td><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a></td><td><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a></td><td><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></td><td><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></td><td><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></td><td><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></td><td><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></td><td><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></td><td><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></td><td><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></td><td><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></td><td><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></td><td><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></td></tr></table></dd>
<dd><code>__result</code> - a structure, <code>ZSTD_bounds</code>, which contains
                 
                 <ul>
                 <li>an error status field, which must be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a></li>
                 <li>lower and upper bounds, both inclusive</li>
                 </ul></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_CCtx_setParameter(long,int,int)">
<h3>nZSTD_CCtx_setParameter</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_CCtx_setParameter</span><wbr><span class="parameters">(long&nbsp;cctx,
 int&nbsp;param,
 int&nbsp;value)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_setParameter(long,int,int)"><code>CCtx_setParameter</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CCtx_setParameter(long,int,int)">
<h3>ZSTD_CCtx_setParameter</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CCtx_setParameter</span><wbr><span class="parameters">(long&nbsp;cctx,
 int&nbsp;param,
 int&nbsp;value)</span></div>
<div class="block">Set one compression parameter, selected by enum <code>ZSTD_cParameter</code>.
 
 <p>All parameters have valid bounds. Bounds can be queried using <a href="#ZSTD_cParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)"><code>cParam_getBounds</code></a>. Providing a value beyond bound will either clamp it, or trigger an
 error (depending on parameter). Setting a parameter is generally only possible during frame initialization (before starting compression). Exception:
 when using multi-threading mode (nbWorkers &ge; 1), the following parameters can be updated <b>during</b> compression (within same frame): =&lt;
 compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy. new parameters will be active for next job only (after a
 <code>flush()</code>).</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>param</code> - one of:<br><table><tr><td><a href="#ZSTD_c_compressionLevel"><code>c_compressionLevel</code></a></td><td><a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a></td><td><a href="#ZSTD_c_hashLog"><code>c_hashLog</code></a></td><td><a href="#ZSTD_c_chainLog"><code>c_chainLog</code></a></td></tr><tr><td><a href="#ZSTD_c_searchLog"><code>c_searchLog</code></a></td><td><a href="#ZSTD_c_minMatch"><code>c_minMatch</code></a></td><td><a href="#ZSTD_c_targetLength"><code>c_targetLength</code></a></td><td><a href="#ZSTD_c_strategy"><code>c_strategy</code></a></td></tr><tr><td><a href="#ZSTD_c_enableLongDistanceMatching"><code>c_enableLongDistanceMatching</code></a></td><td><a href="#ZSTD_c_ldmHashLog"><code>c_ldmHashLog</code></a></td><td><a href="#ZSTD_c_ldmMinMatch"><code>c_ldmMinMatch</code></a></td><td><a href="#ZSTD_c_ldmBucketSizeLog"><code>c_ldmBucketSizeLog</code></a></td></tr><tr><td><a href="#ZSTD_c_ldmHashRateLog"><code>c_ldmHashRateLog</code></a></td><td><a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a></td><td><a href="#ZSTD_c_checksumFlag"><code>c_checksumFlag</code></a></td><td><a href="#ZSTD_c_dictIDFlag"><code>c_dictIDFlag</code></a></td></tr><tr><td><a href="#ZSTD_c_nbWorkers"><code>c_nbWorkers</code></a></td><td><a href="#ZSTD_c_jobSize"><code>c_jobSize</code></a></td><td><a href="#ZSTD_c_overlapLog"><code>c_overlapLog</code></a></td><td><a href="#ZSTD_c_experimentalParam1"><code>c_experimentalParam1</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam2"><code>c_experimentalParam2</code></a></td><td><a href="#ZSTD_c_experimentalParam3"><code>c_experimentalParam3</code></a></td><td><a href="#ZSTD_c_experimentalParam4"><code>c_experimentalParam4</code></a></td><td><a href="#ZSTD_c_experimentalParam5"><code>c_experimentalParam5</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam6"><code>c_experimentalParam6</code></a></td><td><a href="#ZSTD_c_experimentalParam7"><code>c_experimentalParam7</code></a></td><td><a href="#ZSTD_c_experimentalParam8"><code>c_experimentalParam8</code></a></td><td><a href="#ZSTD_c_experimentalParam9"><code>c_experimentalParam9</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam10"><code>c_experimentalParam10</code></a></td><td><a href="#ZSTD_c_experimentalParam11"><code>c_experimentalParam11</code></a></td><td><a href="#ZSTD_c_experimentalParam12"><code>c_experimentalParam12</code></a></td><td><a href="#ZSTD_c_experimentalParam13"><code>c_experimentalParam13</code></a></td></tr><tr><td><a href="#ZSTD_c_experimentalParam14"><code>c_experimentalParam14</code></a></td><td><a href="#ZSTD_c_experimentalParam15"><code>c_experimentalParam15</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>an error code (which can be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a>)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_CCtx_setPledgedSrcSize(long,long)">
<h3>nZSTD_CCtx_setPledgedSrcSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_CCtx_setPledgedSrcSize</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;pledgedSrcSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_setPledgedSrcSize(long,long)"><code>CCtx_setPledgedSrcSize</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CCtx_setPledgedSrcSize(long,long)">
<h3>ZSTD_CCtx_setPledgedSrcSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CCtx_setPledgedSrcSize</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;pledgedSrcSize)</span></div>
<div class="block">Total input data size to be compressed as a single frame.
 
 <p>Value will be written in frame header, unless if explicitly forbidden using <a href="#ZSTD_c_contentSizeFlag"><code>c_contentSizeFlag</code></a>. This value will also be controlled at end of frame, and
 trigger an error if not respected.</p>
 
 <p>Note 1: <code>pledgedSrcSize==0</code> actually means zero, aka an empty frame. In order to mean "unknown content size", pass constant <a href="#ZSTD_CONTENTSIZE_UNKNOWN"><code>CONTENTSIZE_UNKNOWN</code></a>.
 <code>ZSTD_CONTENTSIZE_UNKNOWN</code> is default value for any new frame.</p>
 
 <p>Note 2: <code>pledgedSrcSize</code> is only valid once, for the next frame. It's discarded at the end of the frame, and replaced by
 <code>ZSTD_CONTENTSIZE_UNKNOWN</code>.</p>
 
 <p>Note 3 : Whenever all input data is provided and consumed in a single round, for example with <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a>, or invoking immediately
 <code>ZSTD_compressStream2(,,,ZSTD_e_end)</code>, this value is automatically overridden by <code>srcSize</code> instead.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested with <a href="#ZSTD_isError(long)"><code>isError</code></a>).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_CCtx_reset(long,int)">
<h3>nZSTD_CCtx_reset</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_CCtx_reset</span><wbr><span class="parameters">(long&nbsp;cctx,
 int&nbsp;reset)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_reset(long,int)"><code>CCtx_reset</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CCtx_reset(long,int)">
<h3>ZSTD_CCtx_reset</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CCtx_reset</span><wbr><span class="parameters">(long&nbsp;cctx,
 int&nbsp;reset)</span></div>
<div class="block">There are 2 different things that can be reset, independently or jointly :
 
 <ul>
 <li>The session: will stop compressing current frame, and make <code>CCtx</code> ready to start a new one. Useful after an error, or to interrupt any
 ongoing compression. Any internal data not yet flushed is cancelled. Compression parameters and dictionary remain unchanged. They will be used to
 compress next frame. Resetting session never fails.</li>
 <li>The parameters: changes all parameters back to "default". This removes any reference to any dictionary too. Parameters can only be changed between
 2 sessions (i.e. no compression is currently ongoing) otherwise the reset fails, and function returns an error value (which can be tested using
 <a href="#ZSTD_isError(long)"><code>isError</code></a>)</li>
 <li>Both: similar to resetting the session, followed by resetting parameters.</li>
 </ul></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>reset</code> - one of:<br><table><tr><td><a href="#ZSTD_reset_session_only"><code>reset_session_only</code></a></td><td><a href="#ZSTD_reset_parameters"><code>reset_parameters</code></a></td><td><a href="#ZSTD_reset_session_and_parameters"><code>reset_session_and_parameters</code></a></td></tr></table></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_compress2(long,long,long,long,long)">
<h3>nZSTD_compress2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_compress2</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)">
<h3>ZSTD_compress2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_compress2</span><wbr><span class="parameters">(long&nbsp;cctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</span></div>
<div class="block">Behaves the same as <a href="#ZSTD_compressCCtx(long,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compressCCtx</code></a>, but compression parameters are set using the advanced API.
 
 <p><code>ZSTD_compress2()</code> always starts a new frame. Should cctx hold data from a previously unfinished frame, everything about it is forgotten.</p>
 
 <p>- Compression parameters are pushed into <code>CCtx</code> before starting compression, using <code>ZSTD_CCtx_set*()</code>
 - The function is always blocking, returns when compression is completed. Hint: compression runs faster if <code>dstCapacity</code> &ge;
 <code>ZSTD_compressBound(srcSize)</code>.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>compressed size written into <code>dst</code> (&le; <code>dstCapacity</code>), or an error code if it fails (which can be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a>)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_dParam_getBounds(int,long)">
<h3>nZSTD_dParam_getBounds</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nZSTD_dParam_getBounds</span><wbr><span class="parameters">(int&nbsp;dParam,
 long&nbsp;__result)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_dParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)"><code>dParam_getBounds</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_dParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)">
<h3>ZSTD_dParam_getBounds</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a></span>&nbsp;<span class="element-name">ZSTD_dParam_getBounds</span><wbr><span class="parameters">(int&nbsp;dParam,
 <a href="ZSTDBounds.html" title="class in org.lwjgl.util.zstd">ZSTDBounds</a>&nbsp;__result)</span></div>
<div class="block">All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>__result</code> - returns a structure, <code>ZSTD_bounds</code>, which contains - an error status field, which must be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a> - both lower and upper bounds,
                 inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_DCtx_setParameter(long,int,int)">
<h3>nZSTD_DCtx_setParameter</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_DCtx_setParameter</span><wbr><span class="parameters">(long&nbsp;dctx,
 int&nbsp;param,
 int&nbsp;value)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_setParameter(long,int,int)"><code>DCtx_setParameter</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_DCtx_setParameter(long,int,int)">
<h3>ZSTD_DCtx_setParameter</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_DCtx_setParameter</span><wbr><span class="parameters">(long&nbsp;dctx,
 int&nbsp;param,
 int&nbsp;value)</span></div>
<div class="block">Set one compression parameter, selected by <code>enum ZSTD_dParameter</code>.
 
 <p>All parameters have valid bounds. Bounds can be queried using <a href="#ZSTD_dParam_getBounds(int,org.lwjgl.util.zstd.ZSTDBounds)"><code>dParam_getBounds</code></a>. Providing a value beyond bound will either clamp it, or trigger an
 error (depending on parameter). Setting a parameter is only possible during frame initialization (before starting decompression).</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>param</code> - one of:<br><table><tr><td><a href="#ZSTD_d_windowLogMax"><code>d_windowLogMax</code></a></td><td><a href="#ZSTD_d_experimentalParam1"><code>d_experimentalParam1</code></a></td><td><a href="#ZSTD_d_experimentalParam2"><code>d_experimentalParam2</code></a></td><td><a href="#ZSTD_d_experimentalParam3"><code>d_experimentalParam3</code></a></td></tr><tr><td><a href="#ZSTD_d_experimentalParam4"><code>d_experimentalParam4</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a>)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_DCtx_reset(long,int)">
<h3>nZSTD_DCtx_reset</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_DCtx_reset</span><wbr><span class="parameters">(long&nbsp;dctx,
 int&nbsp;reset)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_reset(long,int)"><code>DCtx_reset</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_DCtx_reset(long,int)">
<h3>ZSTD_DCtx_reset</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_DCtx_reset</span><wbr><span class="parameters">(long&nbsp;dctx,
 int&nbsp;reset)</span></div>
<div class="block">Returns a <code>DCtx</code> to clean state.
 
 <p>Session and parameters can be reset jointly or separately. Parameters can only be reset when no active frame is being decompressed.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>reset</code> - one of:<br><table><tr><td><a href="#ZSTD_reset_session_only"><code>reset_session_only</code></a></td><td><a href="#ZSTD_reset_parameters"><code>reset_parameters</code></a></td><td><a href="#ZSTD_reset_session_and_parameters"><code>reset_session_and_parameters</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>0, or an error code, which can be tested with <a href="#ZSTD_isError(long)"><code>isError</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_createCStream()">
<h3>ZSTD_createCStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_createCStream</span>()</div>
<div class="block">A <code>ZSTD_CStream</code> object is required to track streaming operation.
 
 <p>Use <code>ZSTD_createCStream()</code> and <a href="#ZSTD_freeCStream(long)"><code>freeCStream</code></a> to create/release resources.</p>
 
 <p><code>ZSTD_CStream</code> objects can be reused multiple times on consecutive compression operations. It is recommended to re-use <code>ZSTD_CStream</code> in
 situations where many streaming operations will be achieved consecutively, since it will play nicer with system's memory, by re-using already allocated
 memory. Use one separate <code>ZSTD_CStream</code> per thread for parallel execution.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_freeCStream(long)">
<h3>ZSTD_freeCStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_freeCStream</span><wbr><span class="parameters">(long&nbsp;zcs)</span></div>
<div class="block">Frees memory allocated by <a href="#ZSTD_createCStream()"><code>createCStream</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>zcs</code> - accepts <code>NULL</code> pointer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_compressStream2(long,long,long,int)">
<h3>nZSTD_compressStream2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_compressStream2</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;output,
 long&nbsp;input,
 int&nbsp;endOp)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)"><code>compressStream2</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_compressStream2(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer,int)">
<h3>ZSTD_compressStream2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_compressStream2</span><wbr><span class="parameters">(long&nbsp;cctx,
 <a href="ZSTDOutBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDOutBuffer</a>&nbsp;output,
 <a href="ZSTDInBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDInBuffer</a>&nbsp;input,
 int&nbsp;endOp)</span></div>
<div class="block">Behaves about the same as <code>ZSTD_compressStream()</code>, with additional control on end directive.
 
 <ul>
 <li>Compression parameters are pushed into <code>CCtx</code> before starting compression, using <code>ZSTD_CCtx_set*()</code>.</li>
 <li>Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode).</li>
 <li><code>outpot-&gt;pos</code> must be &le; <code>dstCapacity</code>, <code>input-&gt;pos</code> must be &le; <code>srcSize</code>.</li>
 <li><code>outpot-&gt;pos</code> and <code>input-&gt;pos</code> will be updated. They are guaranteed to remain below their respective limit.</li>
 <li><code>endOp</code> must be a valid directive.</li>
 <li>When <code>nbWorkers==0</code> (default), function is blocking: it completes its job before returning to caller.</li>
 <li>When <code>nbWorkers&amp;ge;1</code>, function is non-blocking: it copies a portion of input, distributes jobs to internal worker threads, flush to output
 whatever is available, and then immediately returns, just indicating that there is some data remaining to be flushed. The function nonetheless
 guarantees forward progress: it will return only after it reads or write at least 1+ byte.</li>
 <li>Exception: if the first call requests a <a href="#ZSTD_e_end"><code>e_end</code></a> directive and provides enough <code>dstCapacity</code>, the function delegates to <a href="#ZSTD_compress2(long,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>compress2</code></a> which is
 always blocking.</li>
 </ul></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>endOp</code> - one of:<br><table><tr><td><a href="#ZSTD_e_continue"><code>e_continue</code></a></td><td><a href="#ZSTD_e_flush"><code>e_flush</code></a></td><td><a href="#ZSTD_e_end"><code>e_end</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>provides a minimum amount of data remaining to be flushed from internal buffers or an error code, which can be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a>.
         
         <p>If <code>!= 0</code>, flush is not fully completed, there is still some data left within internal buffers. This is useful for <a href="#ZSTD_e_flush"><code>e_flush</code></a>, since in this case
         more flushes are necessary to empty all buffers. For <a href="#ZSTD_e_end"><code>e_end</code></a>, <code>== 0</code> when internal buffers are fully flushed and frame is completed.</p>
         
         <p>- after a <code>ZSTD_e_end</code> directive, if internal buffer is not fully flushed (<code>!= 0</code>), only <code>ZSTD_e_end</code> or <code>ZSTD_e_flush</code>
         operations are allowed. Before starting a new compression job, or changing compression parameters, it is required to fully flush internal buffers.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CStreamInSize()">
<h3>ZSTD_CStreamInSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CStreamInSize</span>()</div>
<div class="block">Returns the recommended size for input buffer.
 
 <p>These buffer sizes are softly recommended. They are not required: <code>ZSTD_compressStream*()</code> happily accepts any buffer size, for both input and
 output. Respecting the recommended size just makes it a bit easier for <code>ZSTD_compressStream*()</code>, reducing the amount of memory shuffling and
 buffering, resulting in minor performance savings.</p>
 
 <p>However, note that these recommendations are from the perspective of a C caller program. If the streaming interface is invoked from some other
 language, especially managed ones such as Java or Go, through a foreign function interface such as jni or cgo, a major performance rule is to reduce
 crossing such interface to an absolute minimum. It's not rare that performance ends being spent more into the interface, rather than compression
 itself. In which cases, prefer using large buffers, as large as practical, for both input and output, to reduce the nb of roundtrips.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CStreamOutSize()">
<h3>ZSTD_CStreamOutSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CStreamOutSize</span>()</div>
<div class="block">Returns the recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block.</div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_createDStream()">
<h3>ZSTD_createDStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_createDStream</span>()</div>
<div class="block">A <code>ZSTD_DStream</code> object is required to track streaming operations.
 
 <p>Use <code>ZSTD_createDStream()</code> and <a href="#ZSTD_freeDStream(long)"><code>freeDStream</code></a> to create/release resources. <code>ZSTD_DStream</code> objects can be re-used multiple times.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_freeDStream(long)">
<h3>ZSTD_freeDStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_freeDStream</span><wbr><span class="parameters">(long&nbsp;zds)</span></div>
<div class="block">Frees memory allocated by <a href="#ZSTD_createDStream()"><code>createDStream</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>zds</code> - accepts <code>NULL</code> pointer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_decompressStream(long,long,long)">
<h3>nZSTD_decompressStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_decompressStream</span><wbr><span class="parameters">(long&nbsp;zds,
 long&nbsp;output,
 long&nbsp;input)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)">
<h3>ZSTD_decompressStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_decompressStream</span><wbr><span class="parameters">(long&nbsp;zds,
 <a href="ZSTDOutBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDOutBuffer</a>&nbsp;output,
 <a href="ZSTDInBuffer.html" title="class in org.lwjgl.util.zstd">ZSTDInBuffer</a>&nbsp;input)</span></div>
<div class="block">Use <code>ZSTD_decompressStream()</code> repetitively to consume your input.
 
 <p>The function will update both <code>pos</code> fields. If <code>input.pos &lt; input.size</code>, some input has not been consumed. It's up to the caller to present
 again remaining data. The function tries to flush all data decoded immediately, respecting output buffer size. If <code>output.pos &lt; output.size</code>,
 decoder has flushed everything it could. But if <code>output.pos == output.size</code>, there might be some data left within internal buffers. In which
 case, call <code>ZSTD_decompressStream()</code> again to flush whatever remains in the buffer. With no additional input provided, amount of data flushed is
 necessarily &le; <a href="#ZSTD_BLOCKSIZE_MAX"><code>BLOCKSIZE_MAX</code></a>.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0 when a frame is completely decoded and fully flushed, an error code, which can be tested using <a href="#ZSTD_isError(long)"><code>isError</code></a>, any other value &gt; 0, which means there
         is still some decoding to do to complete current frame. The return value is a suggested next input size (just a hint to improve latency) that will
         never request more than the remaining frame size.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ZSTD_DStreamInSize()">
<h3>ZSTD_DStreamInSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_DStreamInSize</span>()</div>
<div class="block">Returns the recommended size for input buffer.</div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_DStreamOutSize()">
<h3>ZSTD_DStreamOutSize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_DStreamOutSize</span>()</div>
<div class="block">Returns the recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block in all circumstances.</div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_compress_usingDict(long,long,long,long,long,long,long,int)">
<h3>nZSTD_compress_usingDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_compress_usingDict</span><wbr><span class="parameters">(long&nbsp;ctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;dict,
 long&nbsp;dictSize,
 int&nbsp;compressionLevel)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_compress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>compress_usingDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_compress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer,int)">
<h3>ZSTD_compress_usingDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_compress_usingDict</span><wbr><span class="parameters">(long&nbsp;ctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict,
 int&nbsp;compressionLevel)</span></div>
<div class="block">Compression at an explicit compression level using a Dictionary.
 
 <p>A dictionary can be any arbitrary data segment (also called a prefix), or a buffer with specified information (see <code>zdict.h</code>).</p>
 
 <p>This function loads the dictionary, resulting in significant startup delay. It's intended for a dictionary used only once.</p>
 
 <p>When <code>dict == NULL || dictSize &lt; 8</code> no dictionary is used.</p></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_decompress_usingDict(long,long,long,long,long,long,long)">
<h3>nZSTD_decompress_usingDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_decompress_usingDict</span><wbr><span class="parameters">(long&nbsp;dctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;dict,
 long&nbsp;dictSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_decompress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer)"><code>decompress_usingDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_decompress_usingDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,java.nio.ByteBuffer)">
<h3>ZSTD_decompress_usingDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_decompress_usingDict</span><wbr><span class="parameters">(long&nbsp;dctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</span></div>
<div class="block">Decompression using a known Dictionary. Dictionary must be identical to the one used during compression.
 
 <p>This function loads the dictionary, resulting in significant startup delay. It's intended for a dictionary used only once.</p>
 
 <p>When <code>dict == NULL || dictSize &lt; 8</code> no dictionary is used.</p></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_createCDict(long,long,int)">
<h3>nZSTD_createCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_createCDict</span><wbr><span class="parameters">(long&nbsp;dictBuffer,
 long&nbsp;dictSize,
 int&nbsp;compressionLevel)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_createCDict(java.nio.ByteBuffer,int)"><code>createCDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_createCDict(java.nio.ByteBuffer,int)">
<h3>ZSTD_createCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_createCDict</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dictBuffer,
 int&nbsp;compressionLevel)</span></div>
<div class="block">When compressing multiple messages or blocks using the same dictionary, it's recommended to digest the dictionary only once, since it's a costly
 operation. <code>ZSTD_createCDict()</code> will create a state from digesting a dictionary.
 
 <p>The resulting state can be used for future compression operations with very limited startup cost. <code>ZSTD_CDict</code> can be created once and shared by
 multiple threads concurrently, since its usage is read-only.</p>
 
 <p><code>dictBuffer</code> can be released after <code>ZSTD_CDict</code> creation, because its content is copied within CDict. Consider experimental function
 <a href="ZstdX.html#ZSTD_createCDict_byReference(java.nio.ByteBuffer,int)"><code>createCDict_byReference</code></a> if you prefer to not duplicate <code>dictBuffer</code> content.</p>
 
 <p>Note 1: Consider experimental function <a href="ZstdX.html#ZSTD_createCDict_byReference(java.nio.ByteBuffer,int)"><code>createCDict_byReference</code></a> if you prefer to not duplicate <code>dictBuffer</code> content.</p>
 
 <p>Note 2: A <code>ZSTD_CDict</code> can be created from an empty <code>dictBuffer</code>, in which case the only thing that it transports is the
 <code>compressionLevel</code>. This can be useful in a pipeline featuring <a href="#ZSTD_compress_usingCDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)"><code>compress_usingCDict</code></a> exclusively, expecting a <code>ZSTD_CDict</code> parameter with
 any data, including those without a known dictionary.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_freeCDict(long)">
<h3>ZSTD_freeCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_freeCDict</span><wbr><span class="parameters">(long&nbsp;CDict)</span></div>
<div class="block">Frees memory allocated by <a href="#ZSTD_createCDict(java.nio.ByteBuffer,int)"><code>createCDict</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>CDict</code> - accepts <code>NULL</code> pointer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_compress_usingCDict(long,long,long,long,long,long)">
<h3>nZSTD_compress_usingCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_compress_usingCDict</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;cdict)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_compress_usingCDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)"><code>compress_usingCDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_compress_usingCDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)">
<h3>ZSTD_compress_usingCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_compress_usingCDict</span><wbr><span class="parameters">(long&nbsp;cctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 long&nbsp;cdict)</span></div>
<div class="block">Compression using a digested Dictionary. Recommended when same dictionary is used multiple times.
 
 <p>Compression level is <b>decided at dictionary creation time</b>, and frame parameters are hardcoded (<code>dictID=yes, contentSize=yes, checksum=no</code>)</p></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_createDDict(long,long)">
<h3>nZSTD_createDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_createDDict</span><wbr><span class="parameters">(long&nbsp;dictBuffer,
 long&nbsp;dictSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_createDDict(java.nio.ByteBuffer)"><code>createDDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_createDDict(java.nio.ByteBuffer)">
<h3>ZSTD_createDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_createDDict</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dictBuffer)</span></div>
<div class="block">Creates a digested dictionary, ready to start decompression operation without startup delay.
 
 <p><code>dictBuffer</code> can be released after <code>DDict</code> creation, as its content is copied inside <code>DDict</code>.</p></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_freeDDict(long)">
<h3>ZSTD_freeDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_freeDDict</span><wbr><span class="parameters">(long&nbsp;ddict)</span></div>
<div class="block">Frees memory allocated with <a href="#ZSTD_createDDict(java.nio.ByteBuffer)"><code>createDDict</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>ddict</code> - accepts <code>NULL</code> pointer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_decompress_usingDDict(long,long,long,long,long,long)">
<h3>nZSTD_decompress_usingDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_decompress_usingDDict</span><wbr><span class="parameters">(long&nbsp;dctx,
 long&nbsp;dst,
 long&nbsp;dstCapacity,
 long&nbsp;src,
 long&nbsp;srcSize,
 long&nbsp;ddict)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_decompress_usingDDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)"><code>decompress_usingDDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_decompress_usingDDict(long,java.nio.ByteBuffer,java.nio.ByteBuffer,long)">
<h3>ZSTD_decompress_usingDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_decompress_usingDDict</span><wbr><span class="parameters">(long&nbsp;dctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dst,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src,
 long&nbsp;ddict)</span></div>
<div class="block">Decompression using a digested Dictionary.
 
 <p>Recommended when same dictionary is used multiple times.</p></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_getDictID_fromDict(long,long)">
<h3>nZSTD_getDictID_fromDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nZSTD_getDictID_fromDict</span><wbr><span class="parameters">(long&nbsp;dict,
 long&nbsp;dictSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromDict(java.nio.ByteBuffer)"><code>getDictID_fromDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_getDictID_fromDict(java.nio.ByteBuffer)">
<h3>ZSTD_getDictID_fromDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_getDictID_fromDict</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</span></div>
<div class="block">Provides the <code>dictID</code> stored within dictionary.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>if <code>== 0</code>, the dictionary is not conformant with Zstandard specification. It can still be loaded, but as a content-only dictionary.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_getDictID_fromCDict(long)">
<h3>nZSTD_getDictID_fromCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nZSTD_getDictID_fromCDict</span><wbr><span class="parameters">(long&nbsp;cdict)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromCDict(long)"><code>getDictID_fromCDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_getDictID_fromCDict(long)">
<h3>ZSTD_getDictID_fromCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_getDictID_fromCDict</span><wbr><span class="parameters">(long&nbsp;cdict)</span></div>
<div class="block">Provides the <code>dictID</code> of the dictionary loaded into <code>cdict</code>.
 
 <p>If <code>@return == 0</code>, the dictionary is not conformant to Zstandard specification, or empty. Non-conformant dictionaries can still be loaded, but as
 content-only dictionaries.</p></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_getDictID_fromDDict(long)">
<h3>nZSTD_getDictID_fromDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nZSTD_getDictID_fromDDict</span><wbr><span class="parameters">(long&nbsp;ddict)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromDDict(long)"><code>getDictID_fromDDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_getDictID_fromDDict(long)">
<h3>ZSTD_getDictID_fromDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_getDictID_fromDDict</span><wbr><span class="parameters">(long&nbsp;ddict)</span></div>
<div class="block">Provides the <code>dictID</code> of the dictionary loaded into <code>ddict</code>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>if <code>== 0</code>, the dictionary is not conformant to Zstandard specification, or empty.
         
         <p>Non-conformant dictionaries can still be loaded, but as content-only dictionaries.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_getDictID_fromFrame(long,long)">
<h3>nZSTD_getDictID_fromFrame</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nZSTD_getDictID_fromFrame</span><wbr><span class="parameters">(long&nbsp;src,
 long&nbsp;srcSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_getDictID_fromFrame(java.nio.ByteBuffer)"><code>getDictID_fromFrame</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_getDictID_fromFrame(java.nio.ByteBuffer)">
<h3>ZSTD_getDictID_fromFrame</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ZSTD_getDictID_fromFrame</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;src)</span></div>
<div class="block">Provides the dictID required to decompressed the frame stored within <code>src</code>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>if <code>== 0</code>, the <code>dictID</code> could not be decoded. This could for one of the following reasons :
         
         <ul>
         <li>The frame does not require a dictionary to be decoded (most common case).</li>
         <li>The frame was built with <code>dictID</code> intentionally removed. Whatever dictionary is necessary is a hidden information.
         
         <p>Note: this use case also happens when using a non-conformant dictionary.</p></li>
         <li><code>srcSize</code> is too small, and as a result, the frame header could not be decoded (only possible if <code>srcSize</code> &lt; <a href="ZstdX.html#ZSTD_FRAMEHEADERSIZE_MAX"><code>FRAMEHEADERSIZE_MAX</code></a>).</li>
         <li>This is not a Zstandard frame. When identifying the exact failure cause, it's possible to use <a href="ZstdX.html#ZSTD_getFrameHeader(org.lwjgl.util.zstd.ZSTDFrameHeader,java.nio.ByteBuffer)"><code>getFrameHeader</code></a>, which will provide a more precise
         error code.</li>
         </ul></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_CCtx_loadDictionary(long,long,long)">
<h3>nZSTD_CCtx_loadDictionary</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_CCtx_loadDictionary</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;dict,
 long&nbsp;dictSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_loadDictionary(long,java.nio.ByteBuffer)"><code>CCtx_loadDictionary</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CCtx_loadDictionary(long,java.nio.ByteBuffer)">
<h3>ZSTD_CCtx_loadDictionary</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CCtx_loadDictionary</span><wbr><span class="parameters">(long&nbsp;cctx,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</span></div>
<div class="block">Creates an internal <code>CDict</code> from <code>dict</code> buffer. Decompression will have to use same dictionary.
 
 <p>Special: Loading a <code>NULL</code> (or 0-size) dictionary invalidates previous dictionary, meaning "return to no-dictionary mode".</p>
 
 <p>Note 1: Dictionary is sticky, it will be used for all future compressed frames. To return to "no-dictionary" situation, load a <code>NULL</code> dictionary (or
 reset parameters).</p>
 
 <p>Note 2: Loading a dictionary involves building tables. It's also a CPU consuming operation, with non-negligible impact on latency. Tables are dependent
 on compression parameters, and for this reason, compression parameters can no longer be changed after loading a dictionary.</p>
 
 <p>Note 3: <code>dict</code> content will be copied internally. Use experimental <a href="ZstdX.html#ZSTD_CCtx_loadDictionary_byReference(long,java.nio.ByteBuffer)"><code>CCtx_loadDictionary_byReference</code></a> to reference content instead. In such a
 case, dictionary buffer must outlive its users.</p>
 
 <p>Note 4: Use <a href="ZstdX.html#ZSTD_CCtx_loadDictionary_advanced(long,java.nio.ByteBuffer,int,int)"><code>CCtx_loadDictionary_advanced</code></a> to precisely select how dictionary content must be interpreted.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested with <a href="#ZSTD_isError(long)"><code>isError</code></a>).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_CCtx_refCDict(long,long)">
<h3>nZSTD_CCtx_refCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_CCtx_refCDict</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;cdict)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_refCDict(long,long)"><code>CCtx_refCDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CCtx_refCDict(long,long)">
<h3>ZSTD_CCtx_refCDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CCtx_refCDict</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;cdict)</span></div>
<div class="block">References a prepared dictionary, to be used for all next compressed frames.
 
 <p>Note that compression parameters are enforced from within <code>CDict</code>, and supercede any compression parameter previously set within <code>CCtx</code>.
 The parameters ignored are labelled as "superseded-by-cdict" in the <code>ZSTD_cParameter</code> enum docs. The ignored parameters will be used again if the
 <code>CCtx</code> is returned to no-dictionary mode. The dictionary will remain valid for future compressed frames using same <code>CCtx</code>.</p>
 
 <p>Special: Referencing a <code>NULL</code> <code>CDict</code> means "return to no-dictionary mode".</p>
 
 <p>Note 1: Currently, only one dictionary can be managed. Referencing a new dictionary effectively "discards" any previous one.</p>
 
 <p>Note 2: <code>CDict</code> is just referenced, its lifetime must outlive its usage within <code>CCtx</code>.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested with <a href="#ZSTD_isError(long)"><code>isError</code></a>).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_CCtx_refPrefix(long,long,long)">
<h3>nZSTD_CCtx_refPrefix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_CCtx_refPrefix</span><wbr><span class="parameters">(long&nbsp;cctx,
 long&nbsp;prefix,
 long&nbsp;prefixSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_CCtx_refPrefix(long,java.nio.ByteBuffer)"><code>CCtx_refPrefix</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_CCtx_refPrefix(long,java.nio.ByteBuffer)">
<h3>ZSTD_CCtx_refPrefix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_CCtx_refPrefix</span><wbr><span class="parameters">(long&nbsp;cctx,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;prefix)</span></div>
<div class="block">References a prefix (single-usage dictionary) for next compressed frame.
 
 <p>A prefix is <b>only used once</b>. Tables are discarded at end of frame (<a href="#ZSTD_e_end"><code>e_end</code></a>). Decompression will need same prefix to properly regenerate data.
 Compressing with a prefix is similar in outcome as performing a diff and compressing it, but performs much faster, especially during decompression
 (compression speed is tunable with compression level).</p>
 
 <p>Special: Adding any prefix (including <code>NULL</code>) invalidates any previous prefix or dictionary</p>
 
 <p>Note 1: Prefix buffer is referenced. It <b>must</b> outlive compression. Its content must remain unmodified during compression.</p>
 
 <p>Note 2: If the intention is to diff some large <code>src</code> data blob with some prior version of itself, ensure that the window size is large enough to
 contain the entire source. See <a href="#ZSTD_c_windowLog"><code>c_windowLog</code></a>.</p>
 
 <p>Note 3: Referencing a prefix involves building tables, which are dependent on compression parameters. It's a CPU consuming operation, with
 non-negligible impact on latency. If there is a need to use the same prefix multiple times, consider <code>loadDictionary</code> instead.</p>
 
 <p>Note 4: By default, the prefix is interpreted as raw content (<a href="ZstdX.html#ZSTD_dct_rawContent"><code>dct_rawContent</code></a>). Use experimental <a href="ZstdX.html#ZSTD_CCtx_refPrefix_advanced(long,java.nio.ByteBuffer,int)"><code>CCtx_refPrefix_advanced</code></a> to alter dictionary
 interpretation.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested with <a href="#ZSTD_isError(long)"><code>isError</code></a>).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_DCtx_loadDictionary(long,long,long)">
<h3>nZSTD_DCtx_loadDictionary</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_DCtx_loadDictionary</span><wbr><span class="parameters">(long&nbsp;dctx,
 long&nbsp;dict,
 long&nbsp;dictSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_loadDictionary(long,java.nio.ByteBuffer)"><code>DCtx_loadDictionary</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_DCtx_loadDictionary(long,java.nio.ByteBuffer)">
<h3>ZSTD_DCtx_loadDictionary</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_DCtx_loadDictionary</span><wbr><span class="parameters">(long&nbsp;dctx,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;dict)</span></div>
<div class="block">Create an internal <code>DDict</code> from <code>dict</code> buffer, to be used to decompress next frames. The dictionary remains valid for all future frames,
 until explicitly invalidated.
 
 <p>Special: Adding a <code>NULL</code> (or 0-size) dictionary invalidates any previous dictionary, meaning "return to no-dictionary mode".</p>
 
 <p>Note 1: Loading a dictionary involves building tables, which has a non-negligible impact on CPU usage and latency. It's recommended to "load once, use
 many times", to amortize the cost.</p>
 
 <p>Note 2: <code>dict</code> content will be copied internally, so <code>dict</code> can be released after loading. Use <a href="ZstdX.html#ZSTD_DCtx_loadDictionary_byReference(long,java.nio.ByteBuffer)"><code>DCtx_loadDictionary_byReference</code></a> to
 reference dictionary content instead.</p>
 
 <p>Note 3: Use <a href="ZstdX.html#ZSTD_DCtx_loadDictionary_advanced(long,java.nio.ByteBuffer,int,int)"><code>DCtx_loadDictionary_advanced</code></a> to take control of how dictionary content is loaded and interpreted.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested with ZSTD_isError())</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_DCtx_refDDict(long,long)">
<h3>nZSTD_DCtx_refDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_DCtx_refDDict</span><wbr><span class="parameters">(long&nbsp;dctx,
 long&nbsp;ddict)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_refDDict(long,long)"><code>DCtx_refDDict</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_DCtx_refDDict(long,long)">
<h3>ZSTD_DCtx_refDDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_DCtx_refDDict</span><wbr><span class="parameters">(long&nbsp;dctx,
 long&nbsp;ddict)</span></div>
<div class="block">References a prepared dictionary, to be used to decompress next frames. The dictionary remains active for decompression of future frames using same
 <code>DCtx</code>.
 
 <p>If called with <code>ZSTD_d_refMultipleDDicts</code> enabled, repeated calls of this function  will store the <code>DDict</code> references in a table, and the
 <code>DDict</code> used for decompression will be determined at decompression time, as per the <code>dict ID</code> in the frame. The memory for the table is
 allocated on the first call to <code>refDDict</code>, and can be freed with <a href="#ZSTD_freeDCtx(long)"><code>freeDCtx</code></a>.</p>
 
 <p>Note 1: Currently, only one dictionary can be managed. Referencing a new dictionary effectively "discards" any previous one. Special: referencing a
 <code>NULL</code> <code>DDict</code> means "return to no-dictionary mode".</p>
 
 <p>Note 2: <code>DDict</code> is just referenced, its lifetime must outlive its usage from <code>DCtx</code>.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested with <a href="#ZSTD_isError(long)"><code>isError</code></a>)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_DCtx_refPrefix(long,long,long)">
<h3>nZSTD_DCtx_refPrefix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_DCtx_refPrefix</span><wbr><span class="parameters">(long&nbsp;dctx,
 long&nbsp;prefix,
 long&nbsp;prefixSize)</span></div>
<div class="block">Unsafe version of: <a href="#ZSTD_DCtx_refPrefix(long,java.nio.ByteBuffer)"><code>DCtx_refPrefix</code></a></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_DCtx_refPrefix(long,java.nio.ByteBuffer)">
<h3>ZSTD_DCtx_refPrefix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_DCtx_refPrefix</span><wbr><span class="parameters">(long&nbsp;dctx,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;prefix)</span></div>
<div class="block">References a prefix (single-usage dictionary) to decompress next frame.
 
 <p>This is the reverse operation of <a href="#ZSTD_CCtx_refPrefix(long,java.nio.ByteBuffer)"><code>CCtx_refPrefix</code></a>, and must use the same prefix as the one used during compression. Prefix is <b>only used once</b>.
 Reference is discarded at end of frame. End of frame is reached when <a href="#ZSTD_decompressStream(long,org.lwjgl.util.zstd.ZSTDOutBuffer,org.lwjgl.util.zstd.ZSTDInBuffer)"><code>decompressStream</code></a> returns 0.</p>
 
 <p>Note 1: Adding any prefix (including <code>NULL</code>) invalidates any previously set prefix or dictionary.</p>
 
 <p>Note 2: Prefix buffer is referenced. It <b>must</b> outlive decompression. Prefix buffer must remain unmodified up to the end of frame, reached when
 <code>ZSTD_decompressStream()</code> returns 0.</p>
 
 <p>Note 3: By default, the prefix is treated as raw content (<a href="ZstdX.html#ZSTD_dct_rawContent"><code>dct_rawContent</code></a>). Use <a href="ZstdX.html#ZSTD_CCtx_refPrefix_advanced(long,java.nio.ByteBuffer,int)"><code>CCtx_refPrefix_advanced</code></a> to alter <code>dictMode</code>.</p>
 
 <p>Note 4: Referencing a raw content prefix has almost no cpu nor memory cost. A full dictionary is more costly, as it requires building tables.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0, or an error code (which can be tested with <a href="#ZSTD_isError(long)"><code>isError</code></a>)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nZSTD_sizeof_CCtx(long)">
<h3>nZSTD_sizeof_CCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_sizeof_CCtx</span><wbr><span class="parameters">(long&nbsp;cctx)</span></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_sizeof_CCtx(long)">
<h3>ZSTD_sizeof_CCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_sizeof_CCtx</span><wbr><span class="parameters">(long&nbsp;cctx)</span></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_sizeof_DCtx(long)">
<h3>nZSTD_sizeof_DCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_sizeof_DCtx</span><wbr><span class="parameters">(long&nbsp;dctx)</span></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_sizeof_DCtx(long)">
<h3>ZSTD_sizeof_DCtx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_sizeof_DCtx</span><wbr><span class="parameters">(long&nbsp;dctx)</span></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_sizeof_CStream(long)">
<h3>nZSTD_sizeof_CStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_sizeof_CStream</span><wbr><span class="parameters">(long&nbsp;zcs)</span></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_sizeof_CStream(long)">
<h3>ZSTD_sizeof_CStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_sizeof_CStream</span><wbr><span class="parameters">(long&nbsp;zcs)</span></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_sizeof_DStream(long)">
<h3>nZSTD_sizeof_DStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_sizeof_DStream</span><wbr><span class="parameters">(long&nbsp;zds)</span></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_sizeof_DStream(long)">
<h3>ZSTD_sizeof_DStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_sizeof_DStream</span><wbr><span class="parameters">(long&nbsp;zds)</span></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_sizeof_CDict(long)">
<h3>nZSTD_sizeof_CDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_sizeof_CDict</span><wbr><span class="parameters">(long&nbsp;cdict)</span></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_sizeof_CDict(long)">
<h3>ZSTD_sizeof_CDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_sizeof_CDict</span><wbr><span class="parameters">(long&nbsp;cdict)</span></div>
</section>
</li>
<li>
<section class="detail" id="nZSTD_sizeof_DDict(long)">
<h3>nZSTD_sizeof_DDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">nZSTD_sizeof_DDict</span><wbr><span class="parameters">(long&nbsp;ddict)</span></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_sizeof_DDict(long)">
<h3>ZSTD_sizeof_DDict</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_sizeof_DDict</span><wbr><span class="parameters">(long&nbsp;ddict)</span></div>
</section>
</li>
<li>
<section class="detail" id="ZSTD_COMPRESSBOUND(long)">
<h3>ZSTD_COMPRESSBOUND</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">ZSTD_COMPRESSBOUND</span><wbr><span class="parameters">(long&nbsp;srcSize)</span></div>
<div class="block">Pure Java version of <a href="#ZSTD_compressBound(long)"><code>ZSTD_compressBound(long)</code></a>.</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</div>
</div>
</body>
</html>
