<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Vma (LWJGL 3.2.3 SNAPSHOT)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Vma (LWJGL 3.2.3 SNAPSHOT)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../org/lwjgl/util/vma/VmaAllocateDeviceMemoryFunction.html" title="class in org.lwjgl.util.vma"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/lwjgl/util/vma/Vma.html" target="_top">Frames</a></li>
<li><a href="Vma.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="../../../../org/lwjgl/util/vma/package-summary.html">org.lwjgl.util.vma</a></div>
<h2 title="Class Vma" class="title">Class Vma</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.lwjgl.util.vma.Vma</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">Vma</span>
extends java.lang.Object</pre>
<div class="block">The Vulkan Memory Allocator.
 
 <h3>Quick start</h3>
 
 <h4>Initialization</h4>
 
 <p>At program startup:</p>
 
 <ol>
 <li>Initialize Vulkan to have <code>VkPhysicalDevice</code> and <code>VkDevice</code> object.</li>
 <li>Fill VmaAllocatorCreateInfo structure and create `VmaAllocator` object by calling vmaCreateAllocator().</li>
 </ol>
 
 <pre><code>
 VmaAllocatorCreateInfo allocatorInfo = {};
 allocatorInfo.physicalDevice = physicalDevice;
 allocatorInfo.device = device;
 
 VmaAllocator allocator;
 vmaCreateAllocator(&amp;allocatorInfo, &amp;allocator);</code></pre>
 
 <h4>Resource allocation</h4>
 
 <p>When you want to create a buffer or image:</p>
 
 <ol>
 <li>Fill <code>VkBufferCreateInfo</code> / <code>VkImageCreateInfo</code> structure.</li>
 <li>Fill <code>VmaAllocationCreateInfo</code> structure.</li>
 <li>Call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> / <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a> to get <code>VkBuffer</code>/<code>VkImage</code> with memory already allocated and bound to it.</li>
 </ol>
 
 <pre><code>
 VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufferInfo.size = 65536;
 bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <p>Don't forget to destroy your objects when no longer needed:</p>
 
 <pre><code>
 vmaDestroyBuffer(allocator, buffer, allocation);
 vmaDestroyAllocator(allocator);</code></pre>
 
 <h3>Choosing memory type</h3>
 
 <p>Physical devices in Vulkan support various combinations of memory heaps and types. Help with choosing correct and optimal memory type for your specific
 resource is one of the key features of this library. You can use it by filling appropriate members of VmaAllocationCreateInfo structure, as described
 below. You can also combine multiple methods.</p>
 
 <ol>
 <li>If you just want to find memory type index that meets your requirements, you can use function: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a>,
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a>.</li>
 <li>If you want to allocate a region of device memory without association with any specific image or buffer, you can use function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>.
 Usage of this function is not recommended and usually not needed. <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a> function is also provided for creating multiple
 allocations at once, which may be useful for sparse binding.</li>
 <li>If you already have a buffer or an image created, you want to allocate memory for it and then you will bind it yourself, you can use function
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>. For binding you should use functions: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a> or their
 extended versions: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</li>
 <li>If you want to create a buffer or an image, allocate memory for it and bind them together, all in one call, you can use function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. This is the easiest and recommended way to use this library.</li>
 </ol>
 
 <p>When using 3. or 4., the library internally queries Vulkan for memory types supported for that buffer or image (function
 <code>vkGetBufferMemoryRequirements()</code>) and uses only one of these types.</p>
 
 <p>If no memory type can be found that meets all the requirements, these functions return <code>VK_ERROR_FEATURE_NOT_PRESENT</code>.</p>
 
 <p>You can leave <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> structure completely filled with zeros. It means no requirements are specified for memory type. It is valid,
 although not very useful.</p>
 
 <h4>Usage</h4>
 
 <p>The easiest way to specify memory requirements is to fill member <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::usage</code> using one of the values of enum
 <code>VmaMemoryUsage</code>. It defines high level, common usage types. For more details, see description of this enum.</p>
 
 <p>For example, if you want to create a uniform buffer that will be filled using transfer only once or infrequently and used for rendering every frame,
 you can do it using following code:</p>
 
 <pre><code>
 VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufferInfo.size = 65536;
 bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <h4>Required and preferred flags</h4>
 
 <p>You can specify more detailed requirements by filling members <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::requiredFlags</code> and
 <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::preferredFlags</code> with a combination of bits from enum <code>VkMemoryPropertyFlags</code>. For example, if you want to
 create a buffer that will be persistently mapped on host (so it must be <code>HOST_VISIBLE</code>) and preferably will also be <code>HOST_COHERENT</code> and
 <code>HOST_CACHED</code>, use following code:</p>
 
 <pre><code>
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
 allocInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
 allocInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <p>A memory type is chosen that has all the required flags and as many preferred flags set as possible.</p>
 
 <p>If you use <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::usage</code>, it is just internally converted to a set of required and preferred flags.</p>
 
 <h4>Explicit memory types</h4>
 
 <p>If you inspected memory types available on the physical device and you have a preference for memory types that you want to use, you can fill member
 <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::memoryTypeBits</code>. It is a bit mask, where each bit set means that a memory type with that index is allowed to be used
 for the allocation. Special value 0, just like <code>UINT32_MAX</code>, means there are no restrictions to memory type index.</p>
 
 <p>Please note that this member is NOT just a memory type index. Still you can use it to choose just one, specific memory type. For example, if you
 already determined that your buffer should be created in memory type 2, use following code:</p>
 
 <pre><code>
 uint32_t memoryTypeIndex = 2;
 
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.memoryTypeBits = 1u &lt;&lt; memoryTypeIndex;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <h4>Custom memory pools</h4>
 
 <p>If you allocate from custom memory pool, all the ways of specifying memory requirements described above are not applicable and the aforementioned
 members of <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> structure are ignored. Memory type is selected explicitly when creating the pool and then used to make all the
 allocations from that pool. For further details, see Custom Memory Pools below.</p>
 
 <h4>Dedicated allocations</h4>
 
 <p>Memory for allocations is reserved out of larger block of <code>VkDeviceMemory</code> allocated from Vulkan internally. That's the main feature of this
 whole library. You can still request a separate memory block to be created for an allocation, just like you would do in a trivial solution without
 using any allocator. In that case, a buffer or image is always bound to that memory at offset 0. This is called a "dedicated allocation". You can
 explicitly request it by using flag <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>. The library can also internally decide to use dedicated allocation in some
 cases, e.g.:</p>
 
 <ul>
 <li>When the size of the allocation is large.</li>
 <li>When <code>VK_KHR_dedicated_allocation</code> extension is enabled and it reports that dedicated allocation is required or recommended for the resource.</li>
 <li>When allocation of next big memory block fails due to not enough device memory, but allocation with the exact requested size succeeds.</li>
 </ul>
 
 <h3>Memory mapping</h3>
 
 <p>To "map memory" in Vulkan means to obtain a CPU pointer to <code>VkDeviceMemory</code>, to be able to read from it or write to it in CPU code. Mapping is
 possible only of memory allocated from a memory type that has <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> flag. Functions <code>vkMapMemory()</code>,
 <code>vkUnmapMemory()</code> are designed for this purpose. You can use them directly with memory allocated by this library, but it is not recommended
 because of following issue: Mapping the same <code>VkDeviceMemory</code> block multiple times is illegal - only one mapping at a time is allowed. This
 includes mapping disjoint regions. Mapping is not reference-counted internally by Vulkan. Because of this, Vulkan Memory Allocator provides following
 facilities:</p>
 
 <h4>Mapping functions</h4>
 
 <p>The library provides following functions for mapping of a specific <code>VmaAllocation</code>: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a>. They are safer and more
 convenient to use than standard Vulkan functions. You can map an allocation multiple times simultaneously - mapping is reference-counted internally.
 You can also map different allocations simultaneously regardless of whether they use the same <code>VkDeviceMemory</code> block. The way it's implemented is
 that the library always maps entire memory block, not just region of the allocation. For further details, see description of <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> function.
 Example:</p>
 
 <pre><code>
 // Having these objects initialized:
 
 struct ConstantBuffer
 {
     ...
 };
 ConstantBuffer constantBufferData;
 
 VmaAllocator allocator;
 VkBuffer constantBuffer;
 VmaAllocation constantBufferAllocation;
 
 // You can map and fill your buffer using following code:
 
 void* mappedData;
 vmaMapMemory(allocator, constantBufferAllocation, &amp;mappedData);
 memcpy(mappedData, &amp;constantBufferData, sizeof(constantBufferData));
 vmaUnmapMemory(allocator, constantBufferAllocation);</code></pre>
 
 <p>When mapping, you may see a warning from Vulkan validation layer similar to this one:</p>
 
 <p><i>Mapping an image with layout <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> can result in undefined behavior if this memory is used by the
 device. Only <code>GENERAL</code> or <code>PREINITIALIZED</code> should be used.</i></p>
 
 <p>It happens because the library maps entire <code>VkDeviceMemory</code> block, where different types of images and buffers may end up together, especially on
 GPUs with unified memory like Intel. You can safely ignore it if you are sure you access only memory of the intended object that you wanted to map.</p>
 
 <h4>Persistently mapped memory</h4>
 
 <p>Kepping your memory persistently mapped is generally OK in Vulkan. You don't need to unmap it before using its data on the GPU. The library provides a
 special feature designed for that: Allocations made with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag set in <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code> stay mapped
 all the time, so you can just access CPU pointer to it any time without a need to call any "map" or "unmap" function. Example:</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = sizeof(ConstantBuffer);
 bufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_CPU_ONLY;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 // Buffer is already mapped. You can access its memory.
 memcpy(allocInfo.pMappedData, &amp;constantBufferData, sizeof(constantBufferData));</code></pre>
 
 <p>There are some exceptions though, when you should consider mapping memory only for a short period of time:</p>
 
 <ul>
 <li>When operating system is Windows 7 or 8.x (Windows 10 is not affected because it uses WDDM2), device is discrete AMD GPU, and memory type is the
 special 256 MiB pool of <code>DEVICE_LOCAL + HOST_VISIBLE</code> memory (selected when you use <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a>), then whenever a memory block
 allocated from this memory type stays mapped for the time of any call to <code>vkQueueSubmit()</code> or <code>vkQueuePresentKHR()</code>, this block is
 migrated by WDDM to system RAM, which degrades performance. It doesn't matter if that particular memory block is actually used by the command
 buffer being submitted.</li>
 <li>On Mac/MoltenVK there is a known bug - <a href="https://github.com/KhronosGroup/MoltenVK/issues/175">Issue #175</a> which requires unmapping
 before GPU can see updated texture.</li>
 <li>Keeping many large memory blocks mapped may impact performance or stability of some debugging tools.</li>
 </ul>
 
 <h4>Cache control</h4>
 
 <p>Memory in Vulkan doesn't need to be unmapped before using it on GPU, but unless a memory types has <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> flag
 set, you need to manually invalidate cache before reading of mapped pointer using function <code>vkInvalidateMappedMemoryRanges()</code> and flush cache
 after writing to mapped pointer. Vulkan provides following functions for this purpose <code>vkFlushMappedMemoryRangs()</code>,
 <code>vkInvalidateMappedMemoryRanges()</code>, but this library provides more convenient functions that refer to given allocation object:
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a>.</p>
 
 <p>Regions of memory specified for flush/invalidate must be aligned to <code>VkPhysicalDeviceLimits::nonCoherentAtomSize</code>. This is automatically ensured
 by the library. In any memory type that is <code>HOST_VISIBLE</code> but not <code>HOST_COHERENT</code>, all allocations within blocks are aligned to this value,
 so their offsets are always multiply of <code>nonCoherentAtomSize</code> and two different allocations never share same "line" of this size.</p>
 
 <p>Please note that memory allocated with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> is guaranteed to be <code>HOST_COHERENT</code>.</p>
 
 <p>Also, Windows drivers from all 3 PC GPU vendors (AMD, Intel, NVIDIA) currently provide <code>HOST_COHERENT</code> flag on all memory types that are
 <code>HOST_VISIBLE</code>, so on this platform you may not need to bother.</p>
 
 <h4>Finding out if memory is mappable</h4>
 
 <p>It may happen that your allocation ends up in memory that is <code>HOST_VISIBLE</code> (available for mapping) despite it wasn't explicitly requested. For
 example, application may work on integrated graphics with unified memory (like Intel) or allocation from video memory might have failed, so the library
 chose system memory as fallback.</p>
 
 <p>You can detect this case and map such allocation to access its memory on CPU directly, instead of launching a transfer operation. In order to do that:
 inspect <code>allocInfo.memoryType</code>, call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)"><code>GetMemoryTypeProperties</code></a>, and look for <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> flag in properties of
 that memory type.</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = sizeof(ConstantBuffer);
 bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 allocCreateInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 VkMemoryPropertyFlags memFlags;
 vmaGetMemoryTypeProperties(allocator, allocInfo.memoryType, &amp;memFlags);
 if((memFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
 {
     // Allocation ended up in mappable memory. You can map it and access it directly.
     void* mappedData;
     vmaMapMemory(allocator, alloc, &amp;mappedData);
     memcpy(mappedData, &amp;constantBufferData, sizeof(constantBufferData));
     vmaUnmapMemory(allocator, alloc);
 }
 else
 {
     // Allocation ended up in non-mappable memory.
     // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
 }</code></pre>
 
 <p>You can even use <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag while creating allocations that are not necessarily <code>HOST_VISIBLE</code> (e.g. using
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a>). If the allocation ends up in memory type that is <code>HOST_VISIBL</code>E, it will be persistently mapped and you can use it
 directly. If not, the flag is just ignored. Example:</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = sizeof(ConstantBuffer);
 bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 if(allocInfo.pUserData != nullptr)
 {
     // Allocation ended up in mappable memory.
     // It's persistently mapped. You can access it directly.
     memcpy(allocInfo.pMappedData, &amp;constantBufferData, sizeof(constantBufferData));
 }
 else
 {
     // Allocation ended up in non-mappable memory.
     // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
 }</code></pre>
 
 <h3>Custom memory pools</h3>
 
 <p>A memory pool contains a number of <code>VkDeviceMemory</code> blocks. The library automatically creates and manages default pool for each memory type
 available on the device. Default memory pool automatically grows in size. Size of allocated blocks is also variable and managed automatically.</p>
 
 <p>You can create custom pool and allocate memory out of it. It can be useful if you want to:</p>
 
 <ul>
 <li>Keep certain kind of allocations separate from others.</li>
 <li>Enforce particular, fixed size of Vulkan memory blocks.</li>
 <li>Limit maximum amount of Vulkan memory allocated for that pool.</li>
 <li>Reserve minimum or fixed amount of Vulkan memory always preallocated for that pool.</li>
 </ul>
 
 <p>To use custom memory pools:</p>
 
 <ol>
 <li>Fill <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a> structure.</li>
 <li>Call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)"><code>CreatePool</code></a> to obtain <code>VmaPool</code> handle.</li>
 <li>When making an allocation, set <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pool</code> to this handle. You don't need to specify any other parameters of this
 structure, like <code>usage</code>.</li>
 </ol>
 
 <p>Example:</p>
 
 <pre><code>
 // Create a pool that can have at most 2 blocks, 128 MiB each.
 VmaPoolCreateInfo poolCreateInfo = {};
 poolCreateInfo.memoryTypeIndex = ...
 poolCreateInfo.blockSize = 128ull * 1024 * 1024;
 poolCreateInfo.maxBlockCount = 2;
 
 VmaPool pool;
 vmaCreatePool(allocator, &amp;poolCreateInfo, &amp;pool);
 
 // Allocate a buffer out of it.
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = 1024;
 bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.pool = pool;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);</code></pre>
 
 <p>You have to free all allocations made from this pool before destroying it.</p>
 
 <pre><code>
 vmaDestroyBuffer(allocator, buf, alloc);
 vmaDestroyPool(allocator, pool);</code></pre>
 
 <h4>Choosing memory type index</h4>
 
 <p>When creating a pool, you must explicitly specify memory type index. To find the one suitable for your buffers or images, you can use helper functions
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a>. You need to provide structures with example parameters of buffers or images
 that you are going to create in that pool.</p>
 
 <pre><code>
 VkBufferCreateInfo exampleBufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 exampleBufCreateInfo.size = 1024; // Whatever.
 exampleBufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT; // Change if needed.
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY; // Change if needed.
 
 uint32_t memTypeIndex;
 vmaFindMemoryTypeIndexForBufferInfo(allocator, &amp;exampleBufCreateInfo, &amp;allocCreateInfo, &amp;memTypeIndex);
 
 VmaPoolCreateInfo poolCreateInfo = {};
 poolCreateInfo.memoryTypeIndex = memTypeIndex;
 // ...</code></pre>
 
 <p>When creating buffers/images allocated in that pool, provide following parameters:</p>
 
 <ul>
 <li><code>VkBufferCreateInfo</code>: Prefer to pass same parameters as above. Otherwise you risk creating resources in a memory type that is not suitable
 for them, which may result in undefined behavior. Using different <code>VK_BUFFER_USAGE_</code> flags may work, but you shouldn't create images in a
 pool intended for buffers or the other way around.</li>
 <li><a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>: You don't need to pass same parameters. Fill only <code>pool</code> member. Other members are ignored anyway.</li>
 </ul>
 
 <h4>Linear allocation algorithm</h4>
 
 <p>Each Vulkan memory block managed by this library has accompanying metadata that keeps track of used and unused regions. By default, the metadata
 structure and algorithm tries to find best place for new allocations among free regions to optimize memory usage. This way you can allocate and free
 objects in any order.</p>
 
 <p>Sometimes there is a need to use simpler, linear allocation algorithm. You can create custom pool that uses such algorithm by adding flag
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> to <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code> while creating <code>VmaPool</code> object. Then an alternative metadata management
 is used. It always creates new allocations after last one and doesn't reuse free regions after allocations freed in the middle. It results in better
 allocation performance and less memory consumed by metadata.</p>
 
 <p>With this one flag, you can create a custom pool that can be used in many ways: free-at-once, stack, double stack, and ring buffer. See below for
 details.</p>
 
 <h5>Free-at-once</h5>
 
 <p>In a pool that uses linear algorithm, you still need to free all the allocations individually, e.g. by using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> or <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>. You can
 free them in any order. New allocations are always made after last one - free space in the middle is not reused. However, when you release all the
 allocation and the pool becomes empty, allocation starts from the beginning again. This way you can use linear algorithm to speed up creation of
 allocations that you are going to release all at once.</p>
 
 <p>This mode is also available for pools created with <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> value that allows multiple memory blocks.</p>
 
 <h5>Stack</h5>
 
 <p>When you free an allocation that was created last, its space can be reused. Thanks to this, if you always release allocations in the order opposite to
 their creation (LIFO - Last In First Out), you can achieve behavior of a stack.</p>
 
 <p>This mode is also available for pools created with <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> value that allows multiple memory blocks.</p>
 
 <h5>Double stack</h5>
 
 <p>The space reserved by a custom pool with linear algorithm may be used by two stacks:</p>
 
 <ul>
 <li>First, default one, growing up from offset 0.</li>
 <li>Second, "upper" one, growing down from the end towards lower offsets.</li>
 </ul>
 
 <p>To make allocation from upper stack, add flag <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> to <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>Double stack is available only in pools with one memory block - <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> must be 1. Otherwise behavior is undefined.</p>
 
 <p>When the two stacks' ends meet so there is not enough space between them for a new allocation, such allocation fails with usual
 <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <h5>Ring buffer</h5>
 
 <p>When you free some allocations from the beginning and there is not enough free space for a new one at the end of a pool, allocator's "cursor" wraps
 around to the beginning and starts allocation there. Thanks to this, if you always release allocations in the same order as you created them (FIFO -
 First In First Out), you can achieve behavior of a ring buffer / queue.</p>
 
 <p>Pools with linear algorithm support lost allocations when used as ring buffer. If there is not enough free space for a new allocation, but existing
 allocations from the front of the queue can become lost, they become lost and the allocation succeeds.</p>
 
 <p>Ring buffer is available only in pools with one memory block - <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> must be 1. Otherwise behavior is undefined.</p>
 
 <h4>Buddy allocation algorithm</h4>
 
 <p>There is another allocation algorithm that can be used with custom pools, called "buddy". Its internal data structure is based on a tree of blocks,
 each having size that is a power of two and a half of its parent's size. When you want to allocate memory of certain size, a free node in the tree is
 located. If it's too large, it is recursively split into two halves (called "buddies"). However, if requested allocation size is not a power of two,
 the size of a tree node is aligned up to the nearest power of two and the remaining space is wasted. When two buddy nodes become free, they are merged
 back into one larger node.</p>
 
 <p>The advantage of buddy allocation algorithm over default algorithm is faster allocation and deallocation, as well as smaller external fragmentation.
 The disadvantage is more wasted space (internal fragmentation).</p>
 
 <p>For more information, please read <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">"Buddy memory allocation" on Wikipedia</a> or other
 sources that describe this concept in general.</p>
 
 <p>To use buddy allocation algorithm with a custom pool, add flag <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT"><code>POOL_CREATE_BUDDY_ALGORITHM_BIT</code></a> to <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code> while creating
 <code>VmaPool</code> object.</p>
 
 <p>Several limitations apply to pools that use buddy algorithm:</p>
 
 <ul>
 <li>It is recommended to use <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::blockSize</code> that is a power of two. Otherwise, only largest power of two smaller than the size
 is used for allocations. The remaining space always stays unused.</li>
 <li>Margins and corruption detection don't work in such pools.</li>
 <li>Lost allocations don't work in such pools. You can use them, but they never become lost. Support may be added in the future.</li>
 <li>Defragmentation doesn't work with allocations made from such pool.</li>
 </ul>
 
 <h3>Defragmentation</h3>
 
 <p>Interleaved allocations and deallocations of many objects of varying size cause fragmentation over time, which can lead to a situation where the
 library is unable to find a continuous range of free memory for a new allocation despite there is enough free space, just scattered across many small
 free ranges between existing allocations.</p>
 
 <p>To mitigate this problem, you can use defragmentation feature: <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationInfo2.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo2</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)"><code>DefragmentationBegin</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a>. Given set of
 allocations, this function can move them to compact used memory, ensure more continuous free space and possibly also free some <code>VkDeviceMemory</code>
 blocks.</p>
 
 <p>What the defragmentation does is:</p>
 
 <ul>
 <li>Updates <code>VmaAllocation</code> objects to point to new <code>VkDeviceMemory</code> and offset. After allocation has been moved, its
 <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::deviceMemory</code> and/or <code>VmaAllocationInfo::offset</code> changes. You must query them again using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> if
 you need them.</li>
 <li>Moves actual data in memory.</li>
 </ul>
 
 <p>What it doesn't do, so you need to do it yourself:</p>
 
 <ul>
 <li>Recreate buffers and images that were bound to allocations that were defragmented and bind them with their new places in memory. You must use
 <code>vkDestroyBuffer()</code>, <code>vkDestroyImage()</code>, <code>vkCreateBuffer()</code>, <code>vkCreateImage()</code>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a> for
 that purpose and NOT <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyImage(long,long,long)"><code>DestroyImage</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, because you don't need to destroy or create allocation
 objects!</li>
 <li>Recreate views and update descriptors that point to these buffers and images.</li>
 </ul>
 
 <h4>Defragmenting CPU memory</h4>
 
 <p>Following example demonstrates how you can run defragmentation on CPU. Only allocations created in memory types that are <code>HOST_VISIBLE</code> can be
 defragmented. Others are ignored.</p>
 
 <p>The way it works is:</p>
 
 <ul>
 <li>It temporarily maps entire memory blocks when necessary.</li>
 <li>It moves data using <code>memmove()</code> function.</li>
 </ul>
 
 <pre><code>
 // Given following variables already initialized:
 VkDevice device;
 VmaAllocator allocator;
 std::vector&lt;VkBuffer&gt; buffers;
 std::vector&lt;VmaAllocation&gt; allocations;
 
 
 const uint32_t allocCount = (uint32_t)allocations.size();
 std::vector&lt;VkBool32&gt; allocationsChanged(allocCount);
 
 VmaDefragmentationInfo2 defragInfo = {};
 defragInfo.allocationCount = allocCount;
 defragInfo.pAllocations = allocations.data();
 defragInfo.pAllocationsChanged = allocationsChanged.data();
 defragInfo.maxCpuBytesToMove = VK_WHOLE_SIZE; // No limit.
 defragInfo.maxCpuAllocationsToMove = UINT32_MAX; // No limit.
 
 VmaDefragmentationContext defragCtx;
 vmaDefragmentationBegin(allocator, &amp;defragInfo, nullptr, &amp;defragCtx);
 vmaDefragmentationEnd(allocator, defragCtx);
 
 for(uint32_t i = 0; i &lt; allocCount; ++i)
 {
     if(allocationsChanged[i])
     {
         // Destroy buffer that is immutably bound to memory region which is no longer valid.
         vkDestroyBuffer(device, buffers[i], nullptr);
 
         // Create new buffer with same parameters.
         VkBufferCreateInfo bufferInfo = ...;
         vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;buffers[i]);
 
         // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.
 
         // Bind new buffer to new memory region. Data contained in it is already moved.
         VmaAllocationInfo allocInfo;
         vmaGetAllocationInfo(allocator, allocations[i], &amp;allocInfo);
         vmaBindBufferMemory(allocator, allocations[i], buffers[i]);
     }
 }</code></pre>
 
 <p>Setting <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationInfo2.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo2</code></a><code>::pAllocationsChanged</code> is optional. This output array tells whether particular allocation in
 <code>VmaDefragmentationInfo2::pAllocations</code> at the same index has been modified during defragmentation. You can pass null, but you then need to query
 every allocation passed to defragmentation for new parameters using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> if you might need to recreate and rebind a buffer or image
 associated with it.</p>
 
 <p>If you use <code>Custom memory pools</code>, you can fill <code>VmaDefragmentationInfo2::poolCount</code> and <code>VmaDefragmentationInfo2::pPools</code> instead of
 <code>VmaDefragmentationInfo2::allocationCount</code> and <code>VmaDefragmentationInfo2::pAllocations</code> to defragment all allocations in given pools. You
 cannot use <code>VmaDefragmentationInfo2::pAllocationsChanged</code> in that case. You can also combine both methods.</p>
 
 <h4>Defragmenting GPU memory</h4>
 
 <p>It is also possible to defragment allocations created in memory types that are not <code>HOST_VISIBLE</code>. To do that, you need to pass a command buffer
 that meets requirements as described in <code>VmaDefragmentationInfo2::commandBuffer</code>. The way it works is:</p>
 
 <ul>
 <li>It creates temporary buffers and binds them to entire memory blocks when necessary.</li>
 <li>It issues <code>vkCmdCopyBuffer()</code> to passed command buffer.</li>
 </ul>
 
 <p>Example:</p>
 
 <pre><code>
 // Given following variables already initialized:
 VkDevice device;
 VmaAllocator allocator;
 VkCommandBuffer commandBuffer;
 std::vector&lt;VkBuffer&gt; buffers;
 std::vector&lt;VmaAllocation&gt; allocations;
 
 
 const uint32_t allocCount = (uint32_t)allocations.size();
 std::vector&lt;VkBool32&gt; allocationsChanged(allocCount);
 
 VkCommandBufferBeginInfo cmdBufBeginInfo = ...;
 vkBeginCommandBuffer(commandBuffer, &amp;cmdBufBeginInfo);
 
 VmaDefragmentationInfo2 defragInfo = {};
 defragInfo.allocationCount = allocCount;
 defragInfo.pAllocations = allocations.data();
 defragInfo.pAllocationsChanged = allocationsChanged.data();
 defragInfo.maxGpuBytesToMove = VK_WHOLE_SIZE; // Notice it's "GPU" this time.
 defragInfo.maxGpuAllocationsToMove = UINT32_MAX; // Notice it's "GPU" this time.
 defragInfo.commandBuffer = commandBuffer;
 
 VmaDefragmentationContext defragCtx;
 vmaDefragmentationBegin(allocator, &amp;defragInfo, nullptr, &amp;defragCtx);
 
 vkEndCommandBuffer(commandBuffer);
 
 // Submit commandBuffer.
 // Wait for a fence that ensures commandBuffer execution finished.
 
 vmaDefragmentationEnd(allocator, defragCtx);
 
 for(uint32_t i = 0; i &lt; allocCount; ++i)
 {
     if(allocationsChanged[i])
     {
         // Destroy buffer that is immutably bound to memory region which is no longer valid.
         vkDestroyBuffer(device, buffers[i], nullptr);
 
         // Create new buffer with same parameters.
         VkBufferCreateInfo bufferInfo = ...;
         vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;buffers[i]);
 
         // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.
 
         // Bind new buffer to new memory region. Data contained in it is already moved.
         VmaAllocationInfo allocInfo;
         vmaGetAllocationInfo(allocator, allocations[i], &amp;allocInfo);
         vmaBindBufferMemory(allocator, allocations[i], buffers[i]);
     }
 }</code></pre>
 
 <p>You can combine these two methods by specifying non-zero <code>maxGpu*</code> as well as <code>maxCpu*</code> parameters. The library automatically chooses best
 method to defragment each memory pool.</p>
 
 <p>You may try not to block your entire program to wait until defragmentation finishes, but do it in the background, as long as you carefully fullfill
 requirements described in function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)"><code>DefragmentationBegin</code></a>.</p>
 
 <h4>Additional notes</h4>
 
 <p>It is only legal to defragment allocations bound to:</p>
 
 <ul>
 <li>buffers</li>
 <li>images created with <code>VK_IMAGE_CREATE_ALIAS_BIT</code>, <code>VK_IMAGE_TILING_LINEAR</code>, and being currently in <code>VK_IMAGE_LAYOUT_GENERAL</code> or
 <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code>.</li>
 </ul>
 
 <p>Defragmentation of images created with <code>VK_IMAGE_TILING_OPTIMAL</code> or in any other layout may give undefined results.</p>
 
 <p>If you defragment allocations bound to images, new images to be bound to new memory region after defragmentation should be created with
 <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> and then transitioned to their original layout from before defragmentation if needed using an image memory
 barrier.</p>
 
 <p>While using defragmentation, you may experience validation layer warnings, which you just need to ignore.</p>
 
 <p>Please don't expect memory to be fully compacted after defragmentation. Algorithms inside are based on some heuristics that try to maximize number of
 Vulkan memory blocks to make totally empty to release them, as well as to maximize continuous empty space inside remaining blocks, while minimizing the
 number and size of allocations that need to be moved. Some fragmentation may still remain - this is normal.</p>
 
 <h4>Writing custom defragmentation algorithm</h4>
 
 <p>If you want to implement your own, custom defragmentation algorithm, there is infrastructure prepared for that, but it is not exposed through the
 library API - you need to hack its source code.</p>
 
 <p>Here are steps needed to do this:</p>
 
 <ul>
 <li>Main thing you need to do is to define your own class derived from base abstract class <code>VmaDefragmentationAlgorithm</code> and implement your
 version of its pure virtual methods. See definition and comments of this class for details.</li>
 <li>Your code needs to interact with device memory block metadata. If you need more access to its data than it's provided by its public interface,
 declare your new class as a friend class e.g. in class <code>VmaBlockMetadata_Generic</code>.</li>
 <li>If you want to create a flag that would enable your algorithm or pass some additional flags to configure it, add them to
 <code>VmaDefragmentationFlagBits</code> and use them in <code>VmaDefragmentationInfo2::flags</code>.</li>
 <li>Modify function <code>VmaBlockVectorDefragmentationContext::Begin</code> to create object of your new class whenever needed.</li>
 </ul>
 
 <h3>Lost allocations</h3>
 
 <p>If your game oversubscribes video memory, it may work OK in previous-generation graphics APIs (DirectX 9, 10, 11, OpenGL) because resources are
 automatically paged to system RAM. In Vulkan you can't do it because when you run out of memory, an allocation just fails. If you have more data (e.g.
 textures) than can fit into VRAM and you don't need it all at once, you may want to upload them to GPU on demand and "push out" ones that are not used
 for a long time to make room for the new ones, effectively using VRAM (or a cartain memory pool) as a form of cache. Vulkan Memory Allocator can help
 you with that by supporting a concept of "lost allocations".</p>
 
 <p>To create an allocation that can become lost, include <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> flag in <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. Before
 using a buffer or image bound to such allocation in every new frame, you need to query it if it's not lost. To check it, call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a>. If
 the allocation is lost, you should not use it or buffer/image bound to it. You mustn't forget to destroy this allocation and this buffer/image.
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> can also be used for checking status of the allocation. Allocation is lost when returned <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::deviceMemory</code>
 == <code>VK_NULL_HANDLE</code>.</p>
 
 <p>To create an allocation that can make some other allocations lost to make room for it, use <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT"><code>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</code></a> flag. You will
 usually use both flags <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT"><code>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</code></a> and <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> at the same time.</p>
 
 <p>Warning! Current implementation uses quite naive, brute force algorithm, which can make allocation calls that use
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT"><code>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</code></a> flag quite slow. A new, more optimal algorithm and data structure to speed this up is planned for the
 future.</p>
 
 <p><b>Q: When interleaving creation of new allocations with usage of existing ones, how do you make sure that an allocation won't become lost while it's used
 in the current frame?</b></p>
 
 <p>It is ensured because <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a> / <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> not only returns allocation status/parameters and checks whether it's not lost, but
 when it's not, it also atomically marks it as used in the current frame, which makes it impossible to become lost in that frame. It uses lockless
 algorithm, so it works fast and doesn't involve locking any internal mutex.</p>
 
 <p><b>Q: What if my allocation may still be in use by the GPU when it's rendering a previous frame while I already submit new frame on the CPU?</b></p>
 
 <p>You can make sure that allocations "touched" by <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a> / <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> will not become lost for a number of additional frames back
 from the current one by specifying this number as <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::frameInUseCount</code> (for default memory pool) and
 <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::frameInUseCount</code> (for custom pool).</p>
 
 <p><b>Q: How do you inform the library when new frame starts?</b></p>
 
 <p>You need to call function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetCurrentFrameIndex(long,int)"><code>SetCurrentFrameIndex</code></a>.</p>
 
 <p>Example code:</p>
 
 <pre><code>
 struct MyBuffer
 {
     VkBuffer m_Buf = nullptr;
     VmaAllocation m_Alloc = nullptr;
 
     // Called when the buffer is really needed in the current frame.
     void EnsureBuffer();
 };
 
 void MyBuffer::EnsureBuffer()
 {
     // Buffer has been created.
     if(m_Buf != VK_NULL_HANDLE)
     {
         // Check if its allocation is not lost + mark it as used in current frame.
         if(vmaTouchAllocation(allocator, m_Alloc))
         {
             // It's all OK - safe to use m_Buf.
             return;
         }
     }
 
     // Buffer not yet exists or lost - destroy and recreate it.
 
     vmaDestroyBuffer(allocator, m_Buf, m_Alloc);
 
     VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
     bufCreateInfo.size = 1024;
     bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
     VmaAllocationCreateInfo allocCreateInfo = {};
     allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
     allocCreateInfo.flags = VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT |
         VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT;
 
     vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;m_Buf, &amp;m_Alloc, nullptr);
 }</code></pre>
 
 <p>When using lost allocations, you may see some Vulkan validation layer warnings about overlapping regions of memory bound to different kinds of buffers
 and images. This is still valid as long as you implement proper handling of lost allocations (like in the example above) and don't use them.</p>
 
 <p>You can create an allocation that is already in lost state from the beginning using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateLostAllocation(long,org.lwjgl.PointerBuffer)"><code>CreateLostAllocation</code></a>. It may be useful if you need a
 "dummy" allocation that is not null.</p>
 
 <p>You can call function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMakePoolAllocationsLost(long,long,org.lwjgl.PointerBuffer)"><code>MakePoolAllocationsLost</code></a> to set all eligible allocations in a specified custom pool to lost state. Allocations that have been
 "touched" in current frame or <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::frameInUseCount</code> frames back cannot become lost.</p>
 
 <p><b>Q: Can I touch allocation that cannot become lost?</b></p>
 
 <p>Yes, although it has no visible effect. Calls to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> and <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a> update last use frame index also for allocations that
 cannot become lost, but the only way to observe it is to dump internal allocator state using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>. You can use this feature for
 debugging purposes to explicitly mark allocations that you use in current frame and then analyze JSON dump to see for how long each allocation stays
 unused.</p>
 
 <h3>Statistics</h3>
 
 <p>This library contains functions that return information about its internal state, especially the amount of memory allocated from Vulkan. Please keep in
 mind that these functions need to traverse all internal data structures to gather these information, so they may be quite time-consuming. Don't call
 them too often.</p>
 
 <h4>Numeric statistics</h4>
 
 <p>You can query for overall statistics of the allocator using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCalculateStats(long,org.lwjgl.util.vma.VmaStats)"><code>CalculateStats</code></a>. Information are returned using structure <a href="../../../../org/lwjgl/util/vma/VmaStats.html" title="class in org.lwjgl.util.vma"><code>VmaStats</code></a>. It
 contains <a href="../../../../org/lwjgl/util/vma/VmaStatInfo.html" title="class in org.lwjgl.util.vma"><code>VmaStatInfo</code></a> - number of allocated blocks, number of allocations (occupied ranges in these blocks), number of unused (free) ranges in these
 blocks, number of bytes used and unused (but still allocated from Vulkan) and other information. They are summed across memory heaps, memory types and
 total for whole allocator.</p>
 
 <p>You can query for statistics of a custom pool using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetPoolStats(long,long,org.lwjgl.util.vma.VmaPoolStats)"><code>GetPoolStats</code></a>. Information are returned using structure <a href="../../../../org/lwjgl/util/vma/VmaPoolStats.html" title="class in org.lwjgl.util.vma"><code>VmaPoolStats</code></a>.</p>
 
 <p>You can query for information about specific allocation using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>. It fill structure <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a>.</p>
 
 <h3>JSON dump</h3>
 
 <p>You can dump internal state of the allocator to a string in JSON format using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>. The result is guaranteed to be correct
 JSON. It uses ANSI encoding. Any strings provided by user are copied as-is and properly escaped for JSON, so if they use UTF-8, ISO-8859-2 or any other
 encoding, this JSON string can be treated as using this encoding. It must be freed using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeStatsString(long,java.nio.ByteBuffer)"><code>FreeStatsString</code></a>.</p>
 
 <p>The format of this JSON string is not part of official documentation of the library, but it will not change in backward-incompatible way without
 increasing library major version number and appropriate mention in changelog.</p>
 
 <p>The JSON string contains all the data that can be obtained using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCalculateStats(long,org.lwjgl.util.vma.VmaStats)"><code>CalculateStats</code></a>. It can also contain detailed map of allocated memory blocks and
 their regions - free and occupied by allocations. This allows e.g. to visualize the memory or assess fragmentation.</p>
 
 <h3>Allocation names and user data</h3>
 
 <h4>Allocation user data</h4>
 
 <p>You can annotate allocations with your own information, e.g. for debugging purposes. To do that, fill <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code>
 field when creating an allocation. It's an opaque <code>void*</code> pointer. You can use it e.g. as a pointer, some handle, index, key, ordinal number or
 any other value that would associate the allocation with your custom metadata.</p>
 
 <pre><code>
 VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 // Fill bufferInfo...
 
 MyBufferMetadata* pMetadata = CreateBufferMetadata();
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 allocCreateInfo.pUserData = pMetadata;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocCreateInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <p>The pointer may be later retrieved as <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pUserData</code>:</p>
 
 <pre><code>
 VmaAllocationInfo allocInfo;
 vmaGetAllocationInfo(allocator, allocation, &amp;allocInfo);
 MyBufferMetadata* pMetadata = (MyBufferMetadata*)allocInfo.pUserData;</code></pre>
 
 <p>It can also be changed using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetAllocationUserData(long,long,long)"><code>SetAllocationUserData</code></a>.</p>
 
 <p>Values of (non-zero) allocations' <code>pUserData</code> are printed in JSON report created by <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>, in hexadecimal form.</p>
 
 <h4>Allocation names</h4>
 
 <p>There is alternative mode available where <code>pUserData</code> pointer is used to point to a null-terminated string, giving a name to the allocation. To
 use this mode, set <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> flag in <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. Then <code>pUserData</code> passed as
 <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> or argument to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetAllocationUserData(long,long,long)"><code>SetAllocationUserData</code></a> must be either null or pointer to a null-terminated string. The
 library creates internal copy of the string, so the pointer you pass doesn't need to be valid for whole lifetime of the allocation. You can free it
 after the call.</p>
 
 <pre><code>
 VkImageCreateInfo imageInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
 // Fill imageInfo...
 
 std::string imageName = "Texture: ";
 imageName += fileName;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT;
 allocCreateInfo.pUserData = imageName.c_str();
 
 VkImage image;
 VmaAllocation allocation;
 vmaCreateImage(allocator, &amp;imageInfo, &amp;allocCreateInfo, &amp;image, &amp;allocation, nullptr);</code></pre>
 
 <p>The value of <code>pUserData</code> pointer of the allocation will be different than the one you passed when setting allocation's name - pointing to a
 buffer managed internally that holds copy of the string.</p>
 
 <pre><code>
 VmaAllocationInfo allocInfo;
 vmaGetAllocationInfo(allocator, allocation, &amp;allocInfo);
 const char* imageName = (const char*)allocInfo.pUserData;
 printf("Image name: %s\n", imageName);</code></pre>
 
 <p>That string is also printed in JSON report created by <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 
 <h3>Debugging incorrect memory usage</h3>
 
 <p>If you suspect a bug with memory usage, like usage of uninitialized memory or memory being overwritten out of bounds of an allocation, you can use
 debug features of this library to verify this.</p>
 
 <h4>Memory initialization</h4>
 
 <p>If you experience a bug with incorrect and nondeterministic data in your program and you suspect uninitialized memory to be used, you can enable
 automatic memory initialization to verify this. To do it, define macro <code>VMA_DEBUG_INITIALIZE_ALLOCATIONS</code> to 1.</p>
 
 <p>It makes memory of all new allocations initialized to bit pattern <code>0xDCDCDCDC</code>. Before an allocation is destroyed, its memory is filled with bit
 pattern <code>0xEFEFEFEF</code>. Memory is automatically mapped and unmapped if necessary.</p>
 
 <p>If you find these values while debugging your program, good chances are that you incorrectly read Vulkan memory that is allocated but not initialized,
 or already freed, respectively.</p>
 
 <p>Memory initialization works only with memory types that are <code>HOST_VISIBLE</code>. It works also with dedicated allocations. It doesn't work with
 allocations created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> flag, as they cannot be mapped.</p>
 
 <h4>Margins</h4>
 
 <p>By default, allocations are laid out in memory blocks next to each other if possible (considering required alignment, <code>bufferImageGranularity</code>,
 and <code>nonCoherentAtomSize</code>).</p>
 
 <p>Define macro <code>VMA_DEBUG_MARGIN</code> to some non-zero value (e.g. 16) to enforce specified number of bytes as a margin before and after every
 allocation.</p>
 
 <p>If your bug goes away after enabling margins, it means it may be caused by memory being overwritten outside of allocation boundaries. It is not 100%
 certain though. Change in application behavior may also be caused by different order and distribution of allocations across memory blocks after margins
 are applied.</p>
 
 <p>The margin is applied also before first and after last allocation in a block. It may occur only once between two adjacent allocations.</p>
 
 <p>Margins work with all types of memory.</p>
 
 <p>Margin is applied only to allocations made out of memory blocks and not to dedicated allocations, which have their own memory block of specific size.
 It is thus not applied to allocations made using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag or those automatically decided to put into dedicated
 allocations, e.g. due to its large size or recommended by <code>VK_KHR_dedicated_allocation</code> extension. Margins are also not active in custom pools
 created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT"><code>POOL_CREATE_BUDDY_ALGORITHM_BIT</code></a> flag.</p>
 
 <p>Margins appear in JSON dump as part of free space.</p>
 
 <p>Note that enabling margins increases memory usage and fragmentation.</p>
 
 <h4>Corruption detection</h4>
 
 <p>You can additionally define macro <code>VMA_DEBUG_DETECT_CORRUPTION</code> to 1 to enable validation of contents of the margins.</p>
 
 <p>When this feature is enabled, number of bytes specified as <code>VMA_DEBUG_MARGIN</code> (it must be multiple of 4) before and after every allocation is
 filled with a magic number. This idea is also know as "canary". Memory is automatically mapped and unmapped if necessary.</p>
 
 <p>This number is validated automatically when the allocation is destroyed. If it's not equal to the expected value, <code>VMA_ASSERT()</code> is executed. It
 clearly means that either CPU or GPU overwritten the memory outside of boundaries of the allocation, which indicates a serious bug.</p>
 
 <p>You can also explicitly request checking margins of all allocations in all memory blocks that belong to specified memory types by using function
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckCorruption(long,int)"><code>CheckCorruption</code></a>, or in memory blocks that belong to specified custom pool, by using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckPoolCorruption(long,long)"><code>CheckPoolCorruption</code></a>.</p>
 
 <p>Margin validation (corruption detection) works only for memory types that are <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>.</p>
 
 <h3>Record and replay</h3>
 
 <h4>Introduction</h4>
 
 <p>While using the library, sequence of calls to its functions together with their parameters can be recorded to a file and later replayed using
 standalone player application. It can be useful to:</p>
 
 <ul>
 <li>Test correctness - check if same sequence of calls will not cause crash or failures on a target platform.</li>
 <li>Gather statistics - see number of allocations, peak memory usage, number of calls etc.</li>
 <li>Benchmark performance - see how much time it takes to replay the whole sequence.</li>
 </ul>
 
 <h4>Usage</h4>
 
 <p>Recording functionality is disabled by default. To enable it, define following macro before every include of this library:</p>
 
 <pre><code>
 #define VMA_RECORDING_ENABLED 1</code></pre>
 
 <p><b>To record sequence of calls to a file:</b> Fill in <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pRecordSettings</code> member while creating <code>VmaAllocator</code>
 object. File is opened and written during whole lifetime of the allocator.</p>
 
 <p><b>To replay file:</b> Use <code>VmaReplay</code> - standalone command-line program. Precompiled binary can be found in "bin" directory. Its source can be
 found in "src/VmaReplay" directory. Its project is generated by Premake. Command line syntax is printed when the program is launched without parameters.
 Basic usage:</p>
 
 <pre><code>
 VmaReplay.exe MyRecording.csv</code></pre>
 
 <p><b>Documentation of file format</b> can be found in file: "docs/Recording file format.md". It's a human-readable, text file in CSV format (Comma
 Separated Values).</p>
 
 <h4>Additional considerations</h4>
 
 <ul>
 <li>Replaying file that was recorded on a different GPU (with different parameters like <code>bufferImageGranularity</code>, <code>nonCoherentAtomSize</code>,
 and especially different set of memory heaps and types) may give different performance and memory usage results, as well as issue some warnings and
 errors.</li>
 <li>Current implementation of recording in VMA, as well as <code>VmaReplay</code> application, is coded and tested only on Windows. Inclusion of recording
 code is driven by <code>VMA_RECORDING_ENABLED</code> macro. Support for other platforms should be easy to add. Contributions are welcomed.</li>
 </ul>
 
 <h3>Recommended usage patterns</h3>
 
 <p>See also slides from talk: <a href="https://www.gdcvault.com/play/1025458/Advanced-Graphics-Techniques-Tutorial-New">Sawicki, Adam. Advanced Graphics
 Techniques Tutorial: Memory management in Vulkan and DX12. Game Developers Conference, 2018</a></p>
 
 <h4>Common mistakes</h4>
 
 <p><b>Use of <code>CPU_TO_GPU</code> instead of <code>CPU_ONLY</code> memory</b></p>
 
 <p><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> is recommended only for resources that will be mapped and written by the CPU, as well as read directly by the GPU - like some
 buffers or textures updated every frame (dynamic). If you create a staging copy of a resource to be written by CPU and then used as a source of
 transfer to another resource placed in the GPU memory, that staging resource should be created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a>. Please read the
 descriptions of these enums carefully for details.</p>
 
 <p><b>Unnecessary use of custom pools</b></p>
 
 <p>Custom memory pools may be useful for special purposes - when you want to keep certain type of resources separate e.g. to reserve minimum amount of
 memory for them, limit maximum amount of memory they can occupy, or make some of them push out the other through the mechanism of lost allocations. For
 most resources this is not needed and so it is not recommended to create <code>VmaPool</code> objects and allocations out of them. Allocating from the
 default pool is sufficient.</p>
 
 <h4>Simple patterns</h4>
 
 <h5>Render targets</h5>
 
 <p><b>When:</b> Any resources that you frequently write and read on GPU, e.g. images used as color attachments (aka "render targets"), depth-stencil
 attachments, images/buffers used as storage image/buffer (aka "Unordered Access View (UAV)").</p>
 
 <p><b>What to do:</b> Create them in video memory that is fastest to access from GPU using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a>.</p>
 
 <p>Consider using <code>VK_KHR_dedicated_allocation</code> extension and/or manually creating them as dedicated allocations using
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>, especially if they are large or if you plan to destroy and recreate them e.g. when display resolution changes.
 Prefer to create such resources first and all other GPU resources (like textures and vertex buffers) later.</p>
 
 <h5>Immutable resources</h5>
 
 <p><b>When:</b> Any resources that you fill on CPU only once (aka "immutable") or infrequently and then read frequently on GPU, e.g. textures, vertex and
 index buffers, constant buffers that don't change often.</p>
 
 <p><b>What to do:</b> Create them in video memory that is fastest to access from GPU using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a>.</p>
 
 <p>To initialize content of such resource, create a CPU-side (aka "staging") copy of it in system memory - <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a>, map it, fill it, and
 submit a transfer from it to the GPU resource. You can keep the staging copy if you need it for another upload transfer in the future. If you don't,
 you can destroy it or reuse this buffer for uploading different resource after the transfer finishes.</p>
 
 <p>Prefer to create just buffers in system memory rather than images, even for uploading textures. Use <code>vkCmdCopyBufferToImage()</code>. Dont use images
 with <code>VK_IMAGE_TILING_LINEA</code>R.</p>
 
 <h5>Dynamic resources</h5>
 
 <p><b>When:</b> Any resources that change frequently (aka "dynamic"), e.g. every frame or every draw call, written on CPU, read on GPU.</p>
 
 <p><b>What to do:</b> Create them using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a>. You can map it and write to it directly on CPU, as well as read from it on GPU.</p>
 
 <p>This is a more complex situation. Different solutions are possible, and the best one depends on specific GPU type, but you can use this simple approach
 for the start. Prefer to write to such resource sequentially (e.g. using <code>memcpy</code>). Don't perform random access or any reads from it on CPU, as
 it may be very slow.</p>
 
 <h5>Readback</h5>
 
 <p><b>When:</b> Resources that contain data written by GPU that you want to read back on CPU, e.g. results of some computations.</p>
 
 <p><b>What to do:</b> Create them using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a>. You can write to them directly on GPU, as well as map and read them on CPU.</p>
 
 <h4>Advanced patterns</h4>
 
 <h5>Detecting integrated graphics</h5>
 
 <p>You can support integrated graphics (like Intel HD Graphics, AMD APU) better by detecting it in Vulkan. To do it, call
 <code>vkGetPhysicalDeviceProperties()</code>, inspect <code>VkPhysicalDeviceProperties::deviceType</code> and look for
 <code>VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU</code>. When you find it, you can assume that memory is unified and all memory types are comparably fast to
 access from GPU, regardless of <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 
 <p>You can then sum up sizes of all available memory heaps and treat them as useful for your GPU resources, instead of only <code>DEVICE_LOCAL</code> ones. You
 can also prefer to create your resources in memory types that are <code>HOST_VISIBLE</code> to map them directly instead of submitting explicit transfer
 (see below).</p>
 
 <h5>Direct access versus transfer</h5>
 
 <p>For resources that you frequently write on CPU and read on GPU, many solutions are possible:</p>
 
 <ol>
 <li>Create one copy in video memory using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a>, second copy in system memory using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> and submit explicit tranfer
 each time.</li>
 <li>Create just single copy using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a>, map it and fill it on CPU, read it directly on GPU.</li>
 <li>Create just single copy using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a>, map it and fill it on CPU, read it directly on GPU.</li>
 </ol>
 
 <p>Which solution is the most efficient depends on your resource and especially on the GPU. It is best to measure it and then make the decision. Some
 general recommendations:</p>
 
 <ul>
 <li>On integrated graphics use (2) or (3) to avoid unnecesary time and memory overhead related to using a second copy and making transfer.</li>
 <li>For small resources (e.g. constant buffers) use (2). Discrete AMD cards have special 256 MiB pool of video memory that is directly mappable. Even
 if the resource ends up in system memory, its data may be cached on GPU after first fetch over PCIe bus.</li>
 <li>For larger resources (e.g. textures), decide between (1) and (2). You may want to differentiate NVIDIA and AMD, e.g. by looking for memory type
 that is both <code>DEVICE_LOCAL</code> and <code>HOST_VISIBLE</code>. When you find it, use (2), otherwise use (1).</li>
 </ul>
 
 <p>Similarly, for resources that you frequently write on GPU and read on CPU, multiple solutions are possible:</p>
 
 <ol>
 <li>Create one copy in video memory using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a>, second copy in system memory using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> and submit explicit
 transfer each time.</li>
 <li>Create just single copy using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a>, write to it directly on GPU, map it and read it on CPU.</li>
 </ol>
 
 <p>You should take some measurements to decide which option is faster in case of your specific resource.</p>
 
 <p>If you don't want to specialize your code for specific types of GPUs, you can still make an simple optimization for cases when your resource ends up in
 mappable memory to use it directly in this case instead of creating CPU-side staging copy. For details see <em>Finding out if memory is mappable</em>.</p>
 
 <h3>Configuration</h3>
 
 <h4>Custom host memory allocator</h4>
 
 <p>If you use custom allocator for CPU memory rather than default operator <code>new</code> and <code>delete</code> from C++, you can make this library using your
 allocator as well by filling optional member <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pAllocationCallbacks</code>. These functions will be passed to Vulkan, as well
 as used by the library itself to make any CPU-side allocations.</p>
 
 <h4>Device memory allocation callbacks</h4>
 
 <p>The library makes calls to <code>vkAllocateMemory()</code> and <code>vkFreeMemory()</code> internally. You can setup callbacks to be informed about these calls,
 e.g. for the purpose of gathering some statistics. To do it, fill optional member <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pDeviceMemoryCallbacks</code>.</p>
 
 <h4>Device heap memory limit</h4>
 
 <p>When device memory of certain heap runs out of free space, new allocations may fail (returning error code) or they may succeed, silently pushing some
 existing memory blocks from GPU VRAM to system RAM (which degrades performance). This behavior is implementation-dependant - it depends on GPU vendor
 and graphics driver.</p>
 
 <p>On AMD cards it can be controlled while creating Vulkan device object by using <code>VK_AMD_memory_overallocation_behavior</code> extension, if available.</p>
 
 <p>Alternatively, if you want to test how your program behaves with limited amount of Vulkan devicememory available without switching your graphics card
 to one that really has smaller VRAM, you can use a feature of this library intended for this purpose. To do it, fill optional member
 <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pHeapSizeLimit</code>.</p>
 
 <h3>VK_KHR_dedicated_allocation</h3>
 
 <p><code>VK_KHR_dedicated_allocation</code> is a Vulkan extension which can be used to improve performance on some GPUs. It augments Vulkan API with
 possibility to query driver whether it prefers particular buffer or image to have its own, dedicated allocation (separate <code>VkDeviceMemory</code> block)
 for better efficiency - to be able to do some internal optimizations.</p>
 
 <p>The extension is supported by this library. It will be used automatically when enabled. To enable it:</p>
 
 <p>1 . When creating Vulkan device, check if following 2 device extensions are supported (call <code>vkEnumerateDeviceExtensionProperties()</code>). If yes,
 enable them (fill <a href="../../../../org/lwjgl/vulkan/VkDeviceCreateInfo.html" title="class in org.lwjgl.vulkan"><code>VkDeviceCreateInfo</code></a><code>::ppEnabledExtensionNames</code>).</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code></li>
 <li><code>VK_KHR_dedicated_allocation</code></li>
 </ul>
 
 <p>If you enabled these extensions:</p>
 
 <p>2 . Use <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> flag when creating your <code>VmaAllocator</code> to inform the library that you enabled required
 extensions and you want the library to use them.</p>
 
 <pre><code>
 allocatorInfo.flags |= VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;
 
 vmaCreateAllocator(&amp;allocatorInfo, &amp;allocator);</code></pre>
 
 <p>That's all. The extension will be automatically used whenever you create a buffer using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> or image using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>.</p>
 
 <p>When using the extension together with Vulkan Validation Layer, you will receive warnings like this:</p>
 
 <pre><code>
 vkBindBufferMemory(): Binding memory to buffer 0x33 but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 
 <p>It is OK, you should just ignore it. It happens because you use function <code>vkGetBufferMemoryRequirements2KHR()</code> instead of standard
 <code>vkGetBufferMemoryRequirements()</code>, while the validation layer seems to be unaware of it.</p>
 
 <p>To learn more about this extension, see:</p>
 
 <ul>
 <li><a href="https://www.khronos.org/registry/vulkan/specs/1.0-extensions/html/vkspec.html#VK_KHR_dedicated_allocation">VK_KHR_dedicated_allocation in Vulkan specification</a></li>
 <li><a href="http://asawicki.info/articles/VK_KHR_dedicated_allocation.php5">VK_KHR_dedicated_allocation unofficial manual</a></li>
 </ul>
 
 <h3>General considerations</h3>
 
 <h4>Thread safety</h4>
 
 <ul>
 <li>The library has no global state, so separate <code>VmaAllocator</code> objects can be used independently. There should be no need to create multiple
 such objects though - one per <code>VkDevice</code> is enough.</li>
 <li>By default, all calls to functions that take <code>VmaAllocator</code> as first parameter are safe to call from multiple threads simultaneously because
 they are synchronized internally when needed.</li>
 <li>When the allocator is created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> flag, calls to functions that take such <code>VmaAllocator</code>
 object must be synchronized externally.</li>
 <li>Access to a <code>VmaAllocation</code> object must be externally synchronized. For example, you must not call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> and <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> from
 different threads at the same time if you pass the same <code>VmaAllocation</code> object to these functions.</li>
 </ul>
 
 <h4>Validation layer warnings</h4>
 
 <p>When using this library, you can meet following types of warnings issued by Vulkan validation layer. They don't necessarily indicate a bug, so you may
 need to just ignore them.</p>
 
 <ul>
 <li><i><code>vkBindBufferMemory()</code>: Binding memory to buffer <code>0xeb8e4</code> but <code>vkGetBufferMemoryRequirements()</code> has not been called on that
 buffer.</i>
 
 <p>It happens when <code>VK_KHR_dedicated_allocation</code> extension is enabled. <code>vkGetBufferMemoryRequirements2KHR</code> function is used instead, while
 validation layer seems to be unaware of it.</p></li>
 <li><i>Mapping an image with layout <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> can result in undefined behavior if this memory is used by
 the device. Only <code>GENERAL</code> or <code>PREINITIALIZED</code> should be used.</i>
 
 <p>It happens when you map a buffer or image, because the library maps entire <code>VkDeviceMemory</code> block, where different types of images and
 buffers may end up together, especially on GPUs with unified memory like Intel.</p></li>
 <li><i>Non-linear image <code>0xebc91</code> is aliased with linear buffer <code>0xeb8e4</code> which may indicate a bug.</i>
 
 <p>It happens when you use lost allocations, and a new image or buffer is created in place of an existing object that became lost. It may happen also
 when you use defragmentation.</p></li>
 </ul>
 
 <h4>Allocation algorithm</h4>
 
 <p>The library uses following algorithm for allocation, in order:</p>
 
 <ol>
 <li>Try to find free range of memory in existing blocks.</li>
 <li>If failed, try to create a new block of <code>VkDeviceMemor</code>y, with preferred block size.</li>
 <li>If failed, try to create such block with size/2, size/4, size/8.</li>
 <li>If failed and <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT"><code>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</code></a> flag was specified, try to find space in existing blocks, possilby making some other
 allocations lost.</li>
 <li>If failed, try to allocate separate <code>VkDeviceMemory</code> for this allocation, just like when you use <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</li>
 <li>If failed, choose other memory type that meets the requirements specified in <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> and go to point 1.</li>
 <li>If failed, return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</li>
 </ol>
 
 <h4>Features not supported</h4>
 
 <p>Features deliberately excluded from the scope of this library:</p>
 
 <ul>
 <li>Data transfer. Uploading (streaming) and downloading data of buffers and images between CPU and GPU memory and related synchronization is
 responsibility of the user.</li>
 <li>Defining some "texture" object that would automatically stream its data from a staging copy in CPU memory to GPU memory would rather be a feature
 of another, higher-level library implemented on top of VMA.</li>
 <li>Allocations for imported/exported external memory. They tend to require explicit memory type index and dedicated allocation anyway, so they don't
 interact with main features of this library. Such special purpose allocations should be made manually, using <code>vkCreateBuffer()</code> and
 <code>vkAllocateMemory()</code>.</li>
 <li>Recreation of buffers and images. Although the library has functions for buffer and image creation (<a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>), you need to
 recreate these objects yourself after defragmentation. That's because the big structures <code>VkBufferCreateInfo</code>, <code>VkImageCreateInfo</code> are
 not stored in <code>VmaAllocation</code> object.</li>
 <li>Handling CPU memory allocation failures. When dynamically creating small C++ objects in CPU memory (not Vulkan memory), allocation failures are not
 checked and handled gracefully, because that would complicate code significantly and is usually not needed in desktop PC applications anyway.</li>
 <li>Code free of any compiler warnings. Maintaining the library to compile and work correctly on so many different platforms is hard enough. Being free
 of any warnings, on any version of any compiler, is simply not feasible.</li>
 <li>This is a C++ library with C interface. Bindings or ports to any other programming languages are welcomed as external projects and are not going to
 be included into this repository.</li>
 </ul></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT">VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DONT_BIND_BIT">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT">VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MASK">VMA_ALLOCATION_CREATE_STRATEGY_MASK</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT">VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT">VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</a></span></code></th>
<td class="colLast">
<div class="block">Flags to be passed as <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT">VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</a></span></code></th>
<td class="colLast">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY">VMA_MEMORY_USAGE_CPU_ONLY</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU">VMA_MEMORY_USAGE_CPU_TO_GPU</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY">VMA_MEMORY_USAGE_GPU_ONLY</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU">VMA_MEMORY_USAGE_GPU_TO_CPU</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_UNKNOWN">VMA_MEMORY_USAGE_UNKNOWN</a></span></code></th>
<td class="colLast">
<div class="block"><code>VmaMemoryUsage</code></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_ALGORITHM_MASK">VMA_POOL_CREATE_ALGORITHM_MASK</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT">VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</a>
<br><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a></span></code></th>
<td class="colLast">
<div class="block">Flags to be passed as <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_RECORD_FLUSH_AFTER_CALL_BIT">VMA_RECORD_FLUSH_AFTER_CALL_BIT</a></span></code></th>
<td class="colLast">
<div class="block">Flags to be used in <a href="../../../../org/lwjgl/util/vma/VmaRecordSettings.html" title="class in org.lwjgl.util.vma"><code>VmaRecordSettings</code></a><code>::flags</code>.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaAllocateMemory(long,long,long,long,long)">nvmaAllocateMemory</a></span>&#8203;(long&nbsp;allocator,
                  long&nbsp;pVkMemoryRequirements,
                  long&nbsp;pCreateInfo,
                  long&nbsp;pAllocation,
                  long&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a></div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaAllocateMemoryForBuffer(long,long,long,long,long)">nvmaAllocateMemoryForBuffer</a></span>&#8203;(long&nbsp;allocator,
                           long&nbsp;buffer,
                           long&nbsp;pCreateInfo,
                           long&nbsp;pAllocation,
                           long&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a></div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaAllocateMemoryForImage(long,long,long,long,long)">nvmaAllocateMemoryForImage</a></span>&#8203;(long&nbsp;allocator,
                          long&nbsp;image,
                          long&nbsp;pCreateInfo,
                          long&nbsp;pAllocation,
                          long&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a></div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaAllocateMemoryPages(long,long,long,long,long,long)">nvmaAllocateMemoryPages</a></span>&#8203;(long&nbsp;allocator,
                       long&nbsp;pVkMemoryRequirements,
                       long&nbsp;pCreateInfo,
                       long&nbsp;allocationCount,
                       long&nbsp;pAllocations,
                       long&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a></div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaBindBufferMemory(long,long,long)">nvmaBindBufferMemory</a></span>&#8203;(long&nbsp;allocator,
                    long&nbsp;allocation,
                    long&nbsp;buffer)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a></div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaBindBufferMemory2(long,long,long,long,long)">nvmaBindBufferMemory2</a></span>&#8203;(long&nbsp;allocator,
                     long&nbsp;allocation,
                     long&nbsp;allocationLocalOffset,
                     long&nbsp;buffer,
                     long&nbsp;pNext)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a></div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaBindImageMemory(long,long,long)">nvmaBindImageMemory</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;allocation,
                   long&nbsp;image)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a></div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaBindImageMemory2(long,long,long,long,long)">nvmaBindImageMemory2</a></span>&#8203;(long&nbsp;allocator,
                    long&nbsp;allocation,
                    long&nbsp;allocationLocalOffset,
                    long&nbsp;image,
                    long&nbsp;pNext)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a></div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaBuildStatsString(long,long,int)">nvmaBuildStatsString</a></span>&#8203;(long&nbsp;allocator,
                    long&nbsp;ppStatsString,
                    int&nbsp;detailedMap)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a></div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCalculateStats(long,long)">nvmaCalculateStats</a></span>&#8203;(long&nbsp;allocator,
                  long&nbsp;pStats)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCalculateStats(long,org.lwjgl.util.vma.VmaStats)"><code>CalculateStats</code></a></div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCheckCorruption(long,int)">nvmaCheckCorruption</a></span>&#8203;(long&nbsp;allocator,
                   int&nbsp;memoryTypeBits)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckCorruption(long,int)"><code>CheckCorruption</code></a></div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCheckPoolCorruption(long,long)">nvmaCheckPoolCorruption</a></span>&#8203;(long&nbsp;allocator,
                       long&nbsp;pool)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckPoolCorruption(long,long)"><code>CheckPoolCorruption</code></a></div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCreateAllocator(long,long)">nvmaCreateAllocator</a></span>&#8203;(long&nbsp;pCreateInfo,
                   long&nbsp;pAllocator)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a></div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCreateBuffer(long,long,long,long,long,long)">nvmaCreateBuffer</a></span>&#8203;(long&nbsp;allocator,
                long&nbsp;pBufferCreateInfo,
                long&nbsp;pAllocationCreateInfo,
                long&nbsp;pBuffer,
                long&nbsp;pAllocation,
                long&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a></div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCreateImage(long,long,long,long,long,long)">nvmaCreateImage</a></span>&#8203;(long&nbsp;allocator,
               long&nbsp;pImageCreateInfo,
               long&nbsp;pAllocationCreateInfo,
               long&nbsp;pImage,
               long&nbsp;pAllocation,
               long&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a></div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCreateLostAllocation(long,long)">nvmaCreateLostAllocation</a></span>&#8203;(long&nbsp;allocator,
                        long&nbsp;pAllocation)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateLostAllocation(long,org.lwjgl.PointerBuffer)"><code>CreateLostAllocation</code></a></div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaCreatePool(long,long,long)">nvmaCreatePool</a></span>&#8203;(long&nbsp;allocator,
              long&nbsp;pCreateInfo,
              long&nbsp;pPool)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)"><code>CreatePool</code></a></div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaDefragment(long,long,long,long,long,long)">nvmaDefragment</a></span>&#8203;(long&nbsp;allocator,
              long&nbsp;pAllocations,
              long&nbsp;allocationCount,
              long&nbsp;pAllocationsChanged,
              long&nbsp;pDefragmentationInfo,
              long&nbsp;pDefragmentationStats)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragment(long,org.lwjgl.PointerBuffer,java.nio.IntBuffer,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.util.vma.VmaDefragmentationStats)"><code>Defragment</code></a></div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaDefragmentationBegin(long,long,long,long)">nvmaDefragmentationBegin</a></span>&#8203;(long&nbsp;allocator,
                        long&nbsp;pInfo,
                        long&nbsp;pStats,
                        long&nbsp;pContext)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)"><code>DefragmentationBegin</code></a></div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaDefragmentationEnd(long,long)">nvmaDefragmentationEnd</a></span>&#8203;(long&nbsp;allocator,
                      long&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a></div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaDestroyAllocator(long)">nvmaDestroyAllocator</a></span>&#8203;(long&nbsp;allocator)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyAllocator(long)"><code>DestroyAllocator</code></a></div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaDestroyBuffer(long,long,long)">nvmaDestroyBuffer</a></span>&#8203;(long&nbsp;allocator,
                 long&nbsp;buffer,
                 long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a></div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaDestroyImage(long,long,long)">nvmaDestroyImage</a></span>&#8203;(long&nbsp;allocator,
                long&nbsp;image,
                long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyImage(long,long,long)"><code>DestroyImage</code></a></div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaDestroyPool(long,long)">nvmaDestroyPool</a></span>&#8203;(long&nbsp;allocator,
               long&nbsp;pool)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyPool(long,long)"><code>DestroyPool</code></a></div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaFindMemoryTypeIndex(long,int,long,long)">nvmaFindMemoryTypeIndex</a></span>&#8203;(long&nbsp;allocator,
                       int&nbsp;memoryTypeBits,
                       long&nbsp;pAllocationCreateInfo,
                       long&nbsp;pMemoryTypeIndex)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a></div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaFindMemoryTypeIndexForBufferInfo(long,long,long,long)">nvmaFindMemoryTypeIndexForBufferInfo</a></span>&#8203;(long&nbsp;allocator,
                                    long&nbsp;pBufferCreateInfo,
                                    long&nbsp;pAllocationCreateInfo,
                                    long&nbsp;pMemoryTypeIndex)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a></div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaFindMemoryTypeIndexForImageInfo(long,long,long,long)">nvmaFindMemoryTypeIndexForImageInfo</a></span>&#8203;(long&nbsp;allocator,
                                   long&nbsp;pImageCreateInfo,
                                   long&nbsp;pAllocationCreateInfo,
                                   long&nbsp;pMemoryTypeIndex)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a></div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaFlushAllocation(long,long,long,long)">nvmaFlushAllocation</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;allocation,
                   long&nbsp;offset,
                   long&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a></div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaFreeMemory(long,long)">nvmaFreeMemory</a></span>&#8203;(long&nbsp;allocator,
              long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a></div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaFreeMemoryPages(long,long,long)">nvmaFreeMemoryPages</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;allocationCount,
                   long&nbsp;pAllocations)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a></div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaFreeStatsString(long,long)">nvmaFreeStatsString</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;pStatsString)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaGetAllocationInfo(long,long,long)">nvmaGetAllocationInfo</a></span>&#8203;(long&nbsp;allocator,
                     long&nbsp;allocation,
                     long&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a></div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaGetMemoryProperties(long,long)">nvmaGetMemoryProperties</a></span>&#8203;(long&nbsp;allocator,
                       long&nbsp;ppPhysicalDeviceMemoryProperties)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)"><code>GetMemoryProperties</code></a></div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaGetMemoryTypeProperties(long,int,long)">nvmaGetMemoryTypeProperties</a></span>&#8203;(long&nbsp;allocator,
                           int&nbsp;memoryTypeIndex,
                           long&nbsp;pFlags)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)"><code>GetMemoryTypeProperties</code></a></div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaGetPhysicalDeviceProperties(long,long)">nvmaGetPhysicalDeviceProperties</a></span>&#8203;(long&nbsp;allocator,
                               long&nbsp;ppPhysicalDeviceProperties)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)"><code>GetPhysicalDeviceProperties</code></a></div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaGetPoolStats(long,long,long)">nvmaGetPoolStats</a></span>&#8203;(long&nbsp;allocator,
                long&nbsp;pool,
                long&nbsp;pPoolStats)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetPoolStats(long,long,org.lwjgl.util.vma.VmaPoolStats)"><code>GetPoolStats</code></a></div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaInvalidateAllocation(long,long,long,long)">nvmaInvalidateAllocation</a></span>&#8203;(long&nbsp;allocator,
                        long&nbsp;allocation,
                        long&nbsp;offset,
                        long&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a></div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaMakePoolAllocationsLost(long,long,long)">nvmaMakePoolAllocationsLost</a></span>&#8203;(long&nbsp;allocator,
                           long&nbsp;pool,
                           long&nbsp;pLostAllocationCount)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMakePoolAllocationsLost(long,long,org.lwjgl.PointerBuffer)"><code>MakePoolAllocationsLost</code></a></div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaMapMemory(long,long,long)">nvmaMapMemory</a></span>&#8203;(long&nbsp;allocator,
             long&nbsp;allocation,
             long&nbsp;ppData)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a></div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaResizeAllocation(long,long,long)">nvmaResizeAllocation</a></span>&#8203;(long&nbsp;allocator,
                    long&nbsp;allocation,
                    long&nbsp;newSize)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaResizeAllocation(long,long,long)"><code>ResizeAllocation</code></a></div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaSetAllocationUserData(long,long,long)">nvmaSetAllocationUserData</a></span>&#8203;(long&nbsp;allocator,
                         long&nbsp;allocation,
                         long&nbsp;pUserData)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetAllocationUserData(long,long,long)"><code>SetAllocationUserData</code></a></div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaSetCurrentFrameIndex(long,int)">nvmaSetCurrentFrameIndex</a></span>&#8203;(long&nbsp;allocator,
                        int&nbsp;frameIndex)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetCurrentFrameIndex(long,int)"><code>SetCurrentFrameIndex</code></a></div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaTouchAllocation(long,long)">nvmaTouchAllocation</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a></div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#nvmaUnmapMemory(long,long)">nvmaUnmapMemory</a></span>&#8203;(long&nbsp;allocator,
               long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a></div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">vmaAllocateMemory</a></span>&#8203;(long&nbsp;allocator,
                 <a href="../../../../org/lwjgl/vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
                 <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                 <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                 <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">General purpose memory allocation.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">vmaAllocateMemoryForBuffer</a></span>&#8203;(long&nbsp;allocator,
                          long&nbsp;buffer,
                          <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                          <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                          <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Buffer memory allocation.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">vmaAllocateMemoryForImage</a></span>&#8203;(long&nbsp;allocator,
                         long&nbsp;image,
                         <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                         <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                         <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Function similar to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)">vmaAllocateMemoryPages</a></span>&#8203;(long&nbsp;allocator,
                      <a href="../../../../org/lwjgl/vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
                      <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                      <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations,
                      <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.Buffer.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo.Buffer</a>&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">General purpose memory allocation for multiple allocation objects at once.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory(long,long,long)">vmaBindBufferMemory</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;allocation,
                   long&nbsp;buffer)</code></th>
<td class="colLast">
<div class="block">Binds buffer to allocation.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory2(long,long,long,long,long)">vmaBindBufferMemory2</a></span>&#8203;(long&nbsp;allocator,
                    long&nbsp;allocation,
                    long&nbsp;allocationLocalOffset,
                    long&nbsp;buffer,
                    long&nbsp;pNext)</code></th>
<td class="colLast">
<div class="block">Binds buffer to allocation with additional parameters.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory(long,long,long)">vmaBindImageMemory</a></span>&#8203;(long&nbsp;allocator,
                  long&nbsp;allocation,
                  long&nbsp;image)</code></th>
<td class="colLast">
<div class="block">Binds image to allocation.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory2(long,long,long,long,long)">vmaBindImageMemory2</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;allocation,
                   long&nbsp;allocationLocalOffset,
                   long&nbsp;image,
                   long&nbsp;pNext)</code></th>
<td class="colLast">
<div class="block">Binds image to allocation with additional parameters.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)">vmaBuildStatsString</a></span>&#8203;(long&nbsp;allocator,
                   <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppStatsString,
                   boolean&nbsp;detailedMap)</code></th>
<td class="colLast">
<div class="block">Builds and returns statistics as string in JSON format.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCalculateStats(long,org.lwjgl.util.vma.VmaStats)">vmaCalculateStats</a></span>&#8203;(long&nbsp;allocator,
                 <a href="../../../../org/lwjgl/util/vma/VmaStats.html" title="class in org.lwjgl.util.vma">VmaStats</a>&nbsp;pStats)</code></th>
<td class="colLast">
<div class="block">Retrieves statistics from current state of the Allocator.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckCorruption(long,int)">vmaCheckCorruption</a></span>&#8203;(long&nbsp;allocator,
                  int&nbsp;memoryTypeBits)</code></th>
<td class="colLast">
<div class="block">Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckPoolCorruption(long,long)">vmaCheckPoolCorruption</a></span>&#8203;(long&nbsp;allocator,
                      long&nbsp;pool)</code></th>
<td class="colLast">
<div class="block">Checks magic number in margins around all allocations in given memory pool in search for corruptions.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)">vmaCreateAllocator</a></span>&#8203;(<a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocatorCreateInfo</a>&nbsp;pCreateInfo,
                  <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocator)</code></th>
<td class="colLast">
<div class="block">Creates Allocator object.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">vmaCreateBuffer</a></span>&#8203;(long&nbsp;allocator,
               <a href="../../../../org/lwjgl/vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
               <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
               java.nio.LongBuffer&nbsp;pBuffer,
               <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
               <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">This function automatically:
 
 
 Creates buffer.
 Allocates appropriate memory for it.
 Binds the buffer with the memory.
 </div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">vmaCreateImage</a></span>&#8203;(long&nbsp;allocator,
              <a href="../../../../org/lwjgl/vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
              <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
              java.nio.LongBuffer&nbsp;pImage,
              <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
              <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Function similar to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateLostAllocation(long,org.lwjgl.PointerBuffer)">vmaCreateLostAllocation</a></span>&#8203;(long&nbsp;allocator,
                       <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation)</code></th>
<td class="colLast">
<div class="block">Creates new allocation that is in lost state from the beginning.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)">vmaCreatePool</a></span>&#8203;(long&nbsp;allocator,
             <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma">VmaPoolCreateInfo</a>&nbsp;pCreateInfo,
             <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pPool)</code></th>
<td class="colLast">
<div class="block">Allocates Vulkan device memory and creates <code>VmaPool</code> object.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragment(long,org.lwjgl.PointerBuffer,java.nio.IntBuffer,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.util.vma.VmaDefragmentationStats)">vmaDefragment</a></span>&#8203;(long&nbsp;allocator,
             <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations,
             java.nio.IntBuffer&nbsp;pAllocationsChanged,
             <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationInfo</a>&nbsp;pDefragmentationInfo,
             <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationStats.html" title="class in org.lwjgl.util.vma">VmaDefragmentationStats</a>&nbsp;pDefragmentationStats)</code></th>
<td class="colLast">
<div class="block">Deprecated: This is a part of the old interface.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)">vmaDefragmentationBegin</a></span>&#8203;(long&nbsp;allocator,
                       <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationInfo2.html" title="class in org.lwjgl.util.vma">VmaDefragmentationInfo2</a>&nbsp;pInfo,
                       <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationStats.html" title="class in org.lwjgl.util.vma">VmaDefragmentationStats</a>&nbsp;pStats,
                       <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pContext)</code></th>
<td class="colLast">
<div class="block">Begins defragmentation process.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)">vmaDefragmentationEnd</a></span>&#8203;(long&nbsp;allocator,
                     long&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Ends defragmentation process.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyAllocator(long)">vmaDestroyAllocator</a></span>&#8203;(long&nbsp;allocator)</code></th>
<td class="colLast">
<div class="block">Destroys allocator object.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyBuffer(long,long,long)">vmaDestroyBuffer</a></span>&#8203;(long&nbsp;allocator,
                long&nbsp;buffer,
                long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Destroys Vulkan buffer and frees allocated memory.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyImage(long,long,long)">vmaDestroyImage</a></span>&#8203;(long&nbsp;allocator,
               long&nbsp;image,
               long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Destroys Vulkan image and frees allocated memory.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyPool(long,long)">vmaDestroyPool</a></span>&#8203;(long&nbsp;allocator,
              long&nbsp;pool)</code></th>
<td class="colLast">
<div class="block">Destroys <code>VmaPool</code> object and frees Vulkan device memory.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">vmaFindMemoryTypeIndex</a></span>&#8203;(long&nbsp;allocator,
                      int&nbsp;memoryTypeBits,
                      <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                      java.nio.IntBuffer&nbsp;pMemoryTypeIndex)</code></th>
<td class="colLast">
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>memoryTypeBits</code> and <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">vmaFindMemoryTypeIndexForBufferInfo</a></span>&#8203;(long&nbsp;allocator,
                                   <a href="../../../../org/lwjgl/vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
                                   <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                                   java.nio.IntBuffer&nbsp;pMemoryTypeIndex)</code></th>
<td class="colLast">
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkBufferCreateInfo</code> and <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">vmaFindMemoryTypeIndexForImageInfo</a></span>&#8203;(long&nbsp;allocator,
                                  <a href="../../../../org/lwjgl/vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
                                  <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                                  java.nio.IntBuffer&nbsp;pMemoryTypeIndex)</code></th>
<td class="colLast">
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkImageCreateInfo</code> and <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFlushAllocation(long,long,long,long)">vmaFlushAllocation</a></span>&#8203;(long&nbsp;allocator,
                  long&nbsp;allocation,
                  long&nbsp;offset,
                  long&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Flushes memory of given allocation.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)">vmaFreeMemory</a></span>&#8203;(long&nbsp;allocator,
             long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Frees memory previously allocated using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, or <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)">vmaFreeMemoryPages</a></span>&#8203;(long&nbsp;allocator,
                  <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations)</code></th>
<td class="colLast">
<div class="block">Frees memory and destroys multiple allocations.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeStatsString(long,java.nio.ByteBuffer)">vmaFreeStatsString</a></span>&#8203;(long&nbsp;allocator,
                  java.nio.ByteBuffer&nbsp;pStatsString)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)">vmaGetAllocationInfo</a></span>&#8203;(long&nbsp;allocator,
                    long&nbsp;allocation,
                    <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></th>
<td class="colLast">
<div class="block">Returns current information about specified allocation and atomically marks it as used in current frame.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)">vmaGetMemoryProperties</a></span>&#8203;(long&nbsp;allocator,
                      <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceMemoryProperties)</code></th>
<td class="colLast">
<div class="block"><code>PhysicalDeviceMemoryProperties</code> are fetched from <code>physicalDevice</code> by the allocator.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)">vmaGetMemoryTypeProperties</a></span>&#8203;(long&nbsp;allocator,
                          int&nbsp;memoryTypeIndex,
                          java.nio.IntBuffer&nbsp;pFlags)</code></th>
<td class="colLast">
<div class="block">Given Memory Type Index, returns Property Flags of this memory type.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)">vmaGetPhysicalDeviceProperties</a></span>&#8203;(long&nbsp;allocator,
                              <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceProperties)</code></th>
<td class="colLast">
<div class="block"><code>PhysicalDeviceProperties</code> are fetched from <code>physicalDevice</code> by the allocator.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetPoolStats(long,long,org.lwjgl.util.vma.VmaPoolStats)">vmaGetPoolStats</a></span>&#8203;(long&nbsp;allocator,
               long&nbsp;pool,
               <a href="../../../../org/lwjgl/util/vma/VmaPoolStats.html" title="class in org.lwjgl.util.vma">VmaPoolStats</a>&nbsp;pPoolStats)</code></th>
<td class="colLast">
<div class="block">Retrieves statistics of existing VmaPool object.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaInvalidateAllocation(long,long,long,long)">vmaInvalidateAllocation</a></span>&#8203;(long&nbsp;allocator,
                       long&nbsp;allocation,
                       long&nbsp;offset,
                       long&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Invalidates memory of given allocation.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>static long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMakePoolAllocationsLost(long,long)">vmaMakePoolAllocationsLost</a></span>&#8203;(long&nbsp;allocator,
                          long&nbsp;pool)</code></th>
<td class="colLast">
<div class="block">Marks all allocations in given pool as lost if they are not used in current frame or <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::frameInUseCount</code> back from now.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMakePoolAllocationsLost(long,long,org.lwjgl.PointerBuffer)">vmaMakePoolAllocationsLost</a></span>&#8203;(long&nbsp;allocator,
                          long&nbsp;pool,
                          <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pLostAllocationCount)</code></th>
<td class="colLast">
<div class="block">Marks all allocations in given pool as lost if they are not used in current frame or <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::frameInUseCount</code> back from now.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)">vmaMapMemory</a></span>&#8203;(long&nbsp;allocator,
            long&nbsp;allocation,
            <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppData)</code></th>
<td class="colLast">
<div class="block">Maps memory represented by given allocation and returns pointer to it.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaResizeAllocation(long,long,long)">vmaResizeAllocation</a></span>&#8203;(long&nbsp;allocator,
                   long&nbsp;allocation,
                   long&nbsp;newSize)</code></th>
<td class="colLast">
<div class="block">Deprecated.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetAllocationUserData(long,long,long)">vmaSetAllocationUserData</a></span>&#8203;(long&nbsp;allocator,
                        long&nbsp;allocation,
                        long&nbsp;pUserData)</code></th>
<td class="colLast">
<div class="block">Sets <code>pUserData</code> in given allocation to new value.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetCurrentFrameIndex(long,int)">vmaSetCurrentFrameIndex</a></span>&#8203;(long&nbsp;allocator,
                       int&nbsp;frameIndex)</code></th>
<td class="colLast">
<div class="block">Sets index of the current frame.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)">vmaTouchAllocation</a></span>&#8203;(long&nbsp;allocator,
                  long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Returns <code>VK_TRUE</code> if allocation is not lost and atomically marks it as used in current frame.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaUnmapMemory(long,long)">vmaUnmapMemory</a></span>&#8203;(long&nbsp;allocator,
              long&nbsp;allocation)</code></th>
<td class="colLast">
<div class="block">Unmaps memory represented by given allocation, mapped previously using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="VMA_RECORD_FLUSH_AFTER_CALL_BIT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_RECORD_FLUSH_AFTER_CALL_BIT">VMA_RECORD_FLUSH_AFTER_CALL_BIT</a></h4>
<div class="block">Flags to be used in <a href="../../../../org/lwjgl/util/vma/VmaRecordSettings.html" title="class in org.lwjgl.util.vma"><code>VmaRecordSettings</code></a><code>::flags</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_RECORD_FLUSH_AFTER_CALL_BIT"><code>RECORD_FLUSH_AFTER_CALL_BIT</code></a> - 
 Enables flush after recording every function call.
 
 <p>Enable it if you expect your application to crash, which may leave recording file truncated. It may degrade performance though.</p>
 </li>
 </ul></div>
</li></ul>
<a id="VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT">VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a></h4>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>Using this extenion will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code></li>
 <li><code>VK_KHR_dedicated_allocation</code></li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 </ul></div>
</li></ul>
<a id="VMA_MEMORY_USAGE_UNKNOWN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VMA_MEMORY_USAGE_UNKNOWN</h4>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Memory will be used on device only, so fast access from the device is preferred.
 
 <p>It usually means device-local GPU (video) memory. No need to be mappable on host. It is roughly equivalent of <code>D3D12_HEAP_TYPE_DEFAULT</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written and read by device, e.g. images used as attachments.</li>
 <li>Resources transferred from host once (immutable) or infrequently and read by device multiple times, e.g. textures to be sampled, vertex
 buffers, uniform (constant) buffers, and majority of other types of resources used on GPU.</li>
 </ul>
 
 <p>Allocation may still end up in <code>HOST_VISIBLE</code> memory on some implementations. In such case, you are free to map it. You can use
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> with this usage type.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Memory will be mappable on host.
 
 <p>It usually means CPU (system) memory. Guarantees to be <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. CPU access is typically uncached. Writes may
 be write-combined. Resources created in this pool may still be accessible to the device, but access to them can be slow. It is roughly equivalent
 of <code>D3D12_HEAP_TYPE_UPLOAD</code>.</p>
 
 <p>Usage: Staging copy of resources used as transfer source.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Memory that is both mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and preferably fast to access by GPU.
 
 <p>CPU access is typically uncached. Writes may be write-combined.</p>
 
 <p>Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every
 draw call.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Memory mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and cached.
 
 <p>It is roughly equivalent of <code>D3D12_HEAP_TYPE_READBACK</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.</li>
 <li>Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision
 detection.</li></ul>
</li>
 </ul></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_UNKNOWN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="VMA_MEMORY_USAGE_GPU_ONLY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VMA_MEMORY_USAGE_GPU_ONLY</h4>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Memory will be used on device only, so fast access from the device is preferred.
 
 <p>It usually means device-local GPU (video) memory. No need to be mappable on host. It is roughly equivalent of <code>D3D12_HEAP_TYPE_DEFAULT</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written and read by device, e.g. images used as attachments.</li>
 <li>Resources transferred from host once (immutable) or infrequently and read by device multiple times, e.g. textures to be sampled, vertex
 buffers, uniform (constant) buffers, and majority of other types of resources used on GPU.</li>
 </ul>
 
 <p>Allocation may still end up in <code>HOST_VISIBLE</code> memory on some implementations. In such case, you are free to map it. You can use
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> with this usage type.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Memory will be mappable on host.
 
 <p>It usually means CPU (system) memory. Guarantees to be <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. CPU access is typically uncached. Writes may
 be write-combined. Resources created in this pool may still be accessible to the device, but access to them can be slow. It is roughly equivalent
 of <code>D3D12_HEAP_TYPE_UPLOAD</code>.</p>
 
 <p>Usage: Staging copy of resources used as transfer source.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Memory that is both mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and preferably fast to access by GPU.
 
 <p>CPU access is typically uncached. Writes may be write-combined.</p>
 
 <p>Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every
 draw call.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Memory mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and cached.
 
 <p>It is roughly equivalent of <code>D3D12_HEAP_TYPE_READBACK</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.</li>
 <li>Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision
 detection.</li></ul>
</li>
 </ul></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_GPU_ONLY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="VMA_MEMORY_USAGE_CPU_ONLY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VMA_MEMORY_USAGE_CPU_ONLY</h4>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Memory will be used on device only, so fast access from the device is preferred.
 
 <p>It usually means device-local GPU (video) memory. No need to be mappable on host. It is roughly equivalent of <code>D3D12_HEAP_TYPE_DEFAULT</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written and read by device, e.g. images used as attachments.</li>
 <li>Resources transferred from host once (immutable) or infrequently and read by device multiple times, e.g. textures to be sampled, vertex
 buffers, uniform (constant) buffers, and majority of other types of resources used on GPU.</li>
 </ul>
 
 <p>Allocation may still end up in <code>HOST_VISIBLE</code> memory on some implementations. In such case, you are free to map it. You can use
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> with this usage type.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Memory will be mappable on host.
 
 <p>It usually means CPU (system) memory. Guarantees to be <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. CPU access is typically uncached. Writes may
 be write-combined. Resources created in this pool may still be accessible to the device, but access to them can be slow. It is roughly equivalent
 of <code>D3D12_HEAP_TYPE_UPLOAD</code>.</p>
 
 <p>Usage: Staging copy of resources used as transfer source.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Memory that is both mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and preferably fast to access by GPU.
 
 <p>CPU access is typically uncached. Writes may be write-combined.</p>
 
 <p>Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every
 draw call.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Memory mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and cached.
 
 <p>It is roughly equivalent of <code>D3D12_HEAP_TYPE_READBACK</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.</li>
 <li>Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision
 detection.</li></ul>
</li>
 </ul></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_CPU_ONLY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="VMA_MEMORY_USAGE_CPU_TO_GPU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VMA_MEMORY_USAGE_CPU_TO_GPU</h4>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Memory will be used on device only, so fast access from the device is preferred.
 
 <p>It usually means device-local GPU (video) memory. No need to be mappable on host. It is roughly equivalent of <code>D3D12_HEAP_TYPE_DEFAULT</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written and read by device, e.g. images used as attachments.</li>
 <li>Resources transferred from host once (immutable) or infrequently and read by device multiple times, e.g. textures to be sampled, vertex
 buffers, uniform (constant) buffers, and majority of other types of resources used on GPU.</li>
 </ul>
 
 <p>Allocation may still end up in <code>HOST_VISIBLE</code> memory on some implementations. In such case, you are free to map it. You can use
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> with this usage type.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Memory will be mappable on host.
 
 <p>It usually means CPU (system) memory. Guarantees to be <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. CPU access is typically uncached. Writes may
 be write-combined. Resources created in this pool may still be accessible to the device, but access to them can be slow. It is roughly equivalent
 of <code>D3D12_HEAP_TYPE_UPLOAD</code>.</p>
 
 <p>Usage: Staging copy of resources used as transfer source.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Memory that is both mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and preferably fast to access by GPU.
 
 <p>CPU access is typically uncached. Writes may be write-combined.</p>
 
 <p>Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every
 draw call.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Memory mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and cached.
 
 <p>It is roughly equivalent of <code>D3D12_HEAP_TYPE_READBACK</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.</li>
 <li>Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision
 detection.</li></ul>
</li>
 </ul></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_CPU_TO_GPU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="VMA_MEMORY_USAGE_GPU_TO_CPU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VMA_MEMORY_USAGE_GPU_TO_CPU</h4>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Memory will be used on device only, so fast access from the device is preferred.
 
 <p>It usually means device-local GPU (video) memory. No need to be mappable on host. It is roughly equivalent of <code>D3D12_HEAP_TYPE_DEFAULT</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written and read by device, e.g. images used as attachments.</li>
 <li>Resources transferred from host once (immutable) or infrequently and read by device multiple times, e.g. textures to be sampled, vertex
 buffers, uniform (constant) buffers, and majority of other types of resources used on GPU.</li>
 </ul>
 
 <p>Allocation may still end up in <code>HOST_VISIBLE</code> memory on some implementations. In such case, you are free to map it. You can use
 <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> with this usage type.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Memory will be mappable on host.
 
 <p>It usually means CPU (system) memory. Guarantees to be <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. CPU access is typically uncached. Writes may
 be write-combined. Resources created in this pool may still be accessible to the device, but access to them can be slow. It is roughly equivalent
 of <code>D3D12_HEAP_TYPE_UPLOAD</code>.</p>
 
 <p>Usage: Staging copy of resources used as transfer source.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Memory that is both mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and preferably fast to access by GPU.
 
 <p>CPU access is typically uncached. Writes may be write-combined.</p>
 
 <p>Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every
 draw call.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Memory mappable on host (guarantees to be <code>HOST_VISIBLE</code>) and cached.
 
 <p>It is roughly equivalent of <code>D3D12_HEAP_TYPE_READBACK</code>.</p>
 
 <p>Usage:</p>
 
 <ul>
 <li>Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.</li>
 <li>Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision
 detection.</li></ul>
</li>
 </ul></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_GPU_TO_CPU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_MAPPED_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_DONT_BIND_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT">
<!--   -->
</a>
<a id="VMA_ALLOCATION_CREATE_STRATEGY_MASK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_MAPPED_BIT">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT">VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT">VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_DONT_BIND_BIT">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT">VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT">VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT">VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MASK">VMA_ALLOCATION_CREATE_STRATEGY_MASK</a></h4>
<div class="block">Flags to be passed as <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 
 <p>You should not use this flag if <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pool</code> is not null.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 
 <p>If <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pool</code> is not null, this flag is implied and ignored.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>Is it valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 
 <p>You should not use this flag together with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a>.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> - 
 Allocation created with this flag can become lost as a result of another allocation with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT"><code>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</code></a> flag, so you
 must check it before use.
 
 <p>To check if allocation is not lost, call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> and check if <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::deviceMemory</code> is not <code>VK_NULL_HANDLE</code>.</p>
 
 <p>For details about supporting lost allocations, see Lost Allocations chapter of User Guide on Main Page.</p>
 
 <p>You should not use this flag together with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT"><code>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</code></a> - 
 While creating allocation using this flag, other allocations that were created with flag <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> can become lost.
 
 <p>For details about supporting lost allocations, see Lost Allocations chapter of User Guide on Main Page.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Set this flag to treat <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pUserData</code>. The string is automatically freed together with the allocation. It
 is also used in <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Allocation strategy that chooses smallest possible free range for the allocation.</li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT</code></a> - Allocation strategy that chooses biggest possible free range for the allocation.</li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation.
 
 <p>"First" doesn't necessarily means the one with smallest offset in memory, but rather the one that is easiest and fastest to find.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - Allocation strategy that tries to minimize memory usage.</li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - Allocation strategy that tries to minimize allocation time.</li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT</code></a> - Allocation strategy that tries to minimize memory fragmentation.</li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
</li></ul>
<a id="VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT">
<!--   -->
</a>
<a id="VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT">
<!--   -->
</a>
<a id="VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT">
<!--   -->
</a>
<a id="VMA_POOL_CREATE_ALGORITHM_MASK">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT">VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT</a>, <a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_POOL_CREATE_ALGORITHM_MASK">VMA_POOL_CREATE_ALGORITHM_MASK</a></h4>
<div class="block">Flags to be passed as <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>. (<code>VmaPoolCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT"><code>POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</code></a> - 
 Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be
 ignored.
 
 <p>This is an optional optimization flag.</p>
 
 <p>If you always allocate using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, then you don't need to use it because allocator knows
 exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</p>
 
 <p>If you also allocate using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a> or <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, exact type of such allocations is not known, so allocator must be
 conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you
 always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image
 Granularity and so make allocations faster and more optimal.</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> - 
 Enables alternative, linear allocation algorithm in this pool.
 
 <p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from
 allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less
 memory for metadata.</p>
 
 <p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack.</p>
 
 <p>When using this flag, you must specify <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount == 1</code> (or 0 for default).</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT"><code>POOL_CREATE_BUDDY_ALGORITHM_BIT</code></a> - 
 Enables alternative, buddy allocation algorithm in this pool.
 
 <p>It operates on a tree of blocks, each having size that is a power of two and a half of its parent's size. Comparing to default algorithm, this one
 provides faster allocation and deallocation and decreased external fragmentation, at the expense of more memory wasted (internal fragmentation).</p>
 </li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_ALGORITHM_MASK"><code>POOL_CREATE_ALGORITHM_MASK</code></a> - Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
</li></ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="nvmaCreateAllocator(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCreateAllocator</h4>
<pre>public static&nbsp;int&nbsp;nvmaCreateAllocator&#8203;(long&nbsp;pCreateInfo,
                                      long&nbsp;pAllocator)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a></div>
</li>
</ul>
<a id="vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCreateAllocator</h4>
<pre>public static&nbsp;int&nbsp;vmaCreateAllocator&#8203;(<a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocatorCreateInfo</a>&nbsp;pCreateInfo,
                                     <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocator)</pre>
<div class="block">Creates Allocator object.
 
 <p>LWJGL: Use <a href="../../../../org/lwjgl/util/vma/VmaVulkanFunctions.html" title="class in org.lwjgl.util.vma"><code>VmaVulkanFunctions</code></a><code>::set(VkInstance, VkDevice)</code> to populate the <a href="../../../../org/lwjgl/util/vma/VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pVulkanFunctions</code> struct.</p></div>
</li>
</ul>
<a id="nvmaDestroyAllocator(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaDestroyAllocator</h4>
<pre>public static&nbsp;void&nbsp;nvmaDestroyAllocator&#8203;(long&nbsp;allocator)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyAllocator(long)"><code>DestroyAllocator</code></a></div>
</li>
</ul>
<a id="vmaDestroyAllocator(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaDestroyAllocator</h4>
<pre>public static&nbsp;void&nbsp;vmaDestroyAllocator&#8203;(long&nbsp;allocator)</pre>
<div class="block">Destroys allocator object.</div>
</li>
</ul>
<a id="nvmaGetPhysicalDeviceProperties(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaGetPhysicalDeviceProperties</h4>
<pre>public static&nbsp;void&nbsp;nvmaGetPhysicalDeviceProperties&#8203;(long&nbsp;allocator,
                                                   long&nbsp;ppPhysicalDeviceProperties)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)"><code>GetPhysicalDeviceProperties</code></a></div>
</li>
</ul>
<a id="vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaGetPhysicalDeviceProperties</h4>
<pre>public static&nbsp;void&nbsp;vmaGetPhysicalDeviceProperties&#8203;(long&nbsp;allocator,
                                                  <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceProperties)</pre>
<div class="block"><code>PhysicalDeviceProperties</code> are fetched from <code>physicalDevice</code> by the allocator. You can access it here, without fetching it again on your
 own.</div>
</li>
</ul>
<a id="nvmaGetMemoryProperties(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaGetMemoryProperties</h4>
<pre>public static&nbsp;void&nbsp;nvmaGetMemoryProperties&#8203;(long&nbsp;allocator,
                                           long&nbsp;ppPhysicalDeviceMemoryProperties)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)"><code>GetMemoryProperties</code></a></div>
</li>
</ul>
<a id="vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaGetMemoryProperties</h4>
<pre>public static&nbsp;void&nbsp;vmaGetMemoryProperties&#8203;(long&nbsp;allocator,
                                          <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceMemoryProperties)</pre>
<div class="block"><code>PhysicalDeviceMemoryProperties</code> are fetched from <code>physicalDevice</code> by the allocator. You can access it here, without fetching it again on
 your own.</div>
</li>
</ul>
<a id="nvmaGetMemoryTypeProperties(long,int,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaGetMemoryTypeProperties</h4>
<pre>public static&nbsp;void&nbsp;nvmaGetMemoryTypeProperties&#8203;(long&nbsp;allocator,
                                               int&nbsp;memoryTypeIndex,
                                               long&nbsp;pFlags)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)"><code>GetMemoryTypeProperties</code></a></div>
</li>
</ul>
<a id="vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaGetMemoryTypeProperties</h4>
<pre>public static&nbsp;void&nbsp;vmaGetMemoryTypeProperties&#8203;(long&nbsp;allocator,
                                              int&nbsp;memoryTypeIndex,
                                              java.nio.IntBuffer&nbsp;pFlags)</pre>
<div class="block">Given Memory Type Index, returns Property Flags of this memory type.
 
 <p>This is just a convenience function. Same information can be obtained using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)"><code>GetMemoryProperties</code></a>.</p></div>
</li>
</ul>
<a id="nvmaSetCurrentFrameIndex(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaSetCurrentFrameIndex</h4>
<pre>public static&nbsp;void&nbsp;nvmaSetCurrentFrameIndex&#8203;(long&nbsp;allocator,
                                            int&nbsp;frameIndex)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetCurrentFrameIndex(long,int)"><code>SetCurrentFrameIndex</code></a></div>
</li>
</ul>
<a id="vmaSetCurrentFrameIndex(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaSetCurrentFrameIndex</h4>
<pre>public static&nbsp;void&nbsp;vmaSetCurrentFrameIndex&#8203;(long&nbsp;allocator,
                                           int&nbsp;frameIndex)</pre>
<div class="block">Sets index of the current frame.
 
 <p>This function must be used if you make allocations with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> and <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT"><code>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</code></a> flags to
 inform the allocator when a new frame begins. Allocations queried using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> cannot become lost in the current frame.</p></div>
</li>
</ul>
<a id="nvmaCalculateStats(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCalculateStats</h4>
<pre>public static&nbsp;void&nbsp;nvmaCalculateStats&#8203;(long&nbsp;allocator,
                                      long&nbsp;pStats)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCalculateStats(long,org.lwjgl.util.vma.VmaStats)"><code>CalculateStats</code></a></div>
</li>
</ul>
<a id="vmaCalculateStats(long,org.lwjgl.util.vma.VmaStats)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCalculateStats</h4>
<pre>public static&nbsp;void&nbsp;vmaCalculateStats&#8203;(long&nbsp;allocator,
                                     <a href="../../../../org/lwjgl/util/vma/VmaStats.html" title="class in org.lwjgl.util.vma">VmaStats</a>&nbsp;pStats)</pre>
<div class="block">Retrieves statistics from current state of the Allocator.</div>
</li>
</ul>
<a id="nvmaBuildStatsString(long,long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaBuildStatsString</h4>
<pre>public static&nbsp;void&nbsp;nvmaBuildStatsString&#8203;(long&nbsp;allocator,
                                        long&nbsp;ppStatsString,
                                        int&nbsp;detailedMap)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a></div>
</li>
</ul>
<a id="vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaBuildStatsString</h4>
<pre>public static&nbsp;void&nbsp;vmaBuildStatsString&#8203;(long&nbsp;allocator,
                                       <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppStatsString,
                                       boolean&nbsp;detailedMap)</pre>
<div class="block">Builds and returns statistics as string in JSON format.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ppStatsString</code> - must be freed using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeStatsString(long,java.nio.ByteBuffer)"><code>FreeStatsString</code></a> function</dd>
</dl>
</li>
</ul>
<a id="nvmaFreeStatsString(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaFreeStatsString</h4>
<pre>public static&nbsp;void&nbsp;nvmaFreeStatsString&#8203;(long&nbsp;allocator,
                                       long&nbsp;pStatsString)</pre>
</li>
</ul>
<a id="vmaFreeStatsString(long,java.nio.ByteBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaFreeStatsString</h4>
<pre>public static&nbsp;void&nbsp;vmaFreeStatsString&#8203;(long&nbsp;allocator,
                                      java.nio.ByteBuffer&nbsp;pStatsString)</pre>
</li>
</ul>
<a id="nvmaFindMemoryTypeIndex(long,int,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaFindMemoryTypeIndex</h4>
<pre>public static&nbsp;int&nbsp;nvmaFindMemoryTypeIndex&#8203;(long&nbsp;allocator,
                                          int&nbsp;memoryTypeBits,
                                          long&nbsp;pAllocationCreateInfo,
                                          long&nbsp;pMemoryTypeIndex)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a></div>
</li>
</ul>
<a id="vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaFindMemoryTypeIndex</h4>
<pre>public static&nbsp;int&nbsp;vmaFindMemoryTypeIndex&#8203;(long&nbsp;allocator,
                                         int&nbsp;memoryTypeBits,
                                         <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                                         java.nio.IntBuffer&nbsp;pMemoryTypeIndex)</pre>
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>memoryTypeBits</code> and <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.
 
 <p>This algorithm tries to find a memory type that:</p>
 
 <ul>
 <li>Is allowed by <code>memoryTypeBits</code>.</li>
 <li>Contains all the flags from <code>pAllocationCreateInfo-&gt;requiredFlags</code>.</li>
 <li>Matches intended usage.</li>
 <li>Has as many flags from <code>pAllocationCreateInfo-&gt;preferredFlags</code> as possible.</li>
 </ul></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>VK_ERROR_FEATURE_NOT_PRESENT</code> if not found.
         
         <p>Receiving such result from this function or any other allocating function probably means that your device doesn't support any memory type with
         requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout
         (<code>OPTIMAL</code> versus LINEAR) or mip level count.</p></dd>
</dl>
</li>
</ul>
<a id="nvmaFindMemoryTypeIndexForBufferInfo(long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaFindMemoryTypeIndexForBufferInfo</h4>
<pre>public static&nbsp;int&nbsp;nvmaFindMemoryTypeIndexForBufferInfo&#8203;(long&nbsp;allocator,
                                                       long&nbsp;pBufferCreateInfo,
                                                       long&nbsp;pAllocationCreateInfo,
                                                       long&nbsp;pMemoryTypeIndex)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a></div>
</li>
</ul>
<a id="vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaFindMemoryTypeIndexForBufferInfo</h4>
<pre>public static&nbsp;int&nbsp;vmaFindMemoryTypeIndexForBufferInfo&#8203;(long&nbsp;allocator,
                                                      <a href="../../../../org/lwjgl/vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
                                                      <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                                                      java.nio.IntBuffer&nbsp;pMemoryTypeIndex)</pre>
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkBufferCreateInfo</code> and <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.
 
 <p>It can be useful e.g. to determine value to be used as <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::memoryTypeIndex</code>. It internally creates a temporary, dummy buffer
 that never has memory bound. It is just a convenience function, equivalent to calling:</p>
 
 <ul>
 <li><code>vkCreateBuffer</code></li>
 <li><code>vkGetBufferMemoryRequirements</code></li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a></li>
 <li><code>vkDestroyBuffer</code></li>
 </ul></div>
</li>
</ul>
<a id="nvmaFindMemoryTypeIndexForImageInfo(long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaFindMemoryTypeIndexForImageInfo</h4>
<pre>public static&nbsp;int&nbsp;nvmaFindMemoryTypeIndexForImageInfo&#8203;(long&nbsp;allocator,
                                                      long&nbsp;pImageCreateInfo,
                                                      long&nbsp;pAllocationCreateInfo,
                                                      long&nbsp;pMemoryTypeIndex)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a></div>
</li>
</ul>
<a id="vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaFindMemoryTypeIndexForImageInfo</h4>
<pre>public static&nbsp;int&nbsp;vmaFindMemoryTypeIndexForImageInfo&#8203;(long&nbsp;allocator,
                                                     <a href="../../../../org/lwjgl/vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
                                                     <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                                                     java.nio.IntBuffer&nbsp;pMemoryTypeIndex)</pre>
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkImageCreateInfo</code> and <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.
 
 <p>It can be useful e.g. to determine value to be used as <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::memoryTypeIndex</code>. It internally creates a temporary, dummy image
 that never has memory bound. It is just a convenience function, equivalent to calling:</p>
 
 <ul>
 <li><code>vkCreateImage</code></li>
 <li><code>vkGetImageMemoryRequirements</code></li>
 <li><a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a></li>
 <li><code>vkDestroyImage</code></li>
 </ul></div>
</li>
</ul>
<a id="nvmaCreatePool(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCreatePool</h4>
<pre>public static&nbsp;int&nbsp;nvmaCreatePool&#8203;(long&nbsp;allocator,
                                 long&nbsp;pCreateInfo,
                                 long&nbsp;pPool)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)"><code>CreatePool</code></a></div>
</li>
</ul>
<a id="vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCreatePool</h4>
<pre>public static&nbsp;int&nbsp;vmaCreatePool&#8203;(long&nbsp;allocator,
                                <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma">VmaPoolCreateInfo</a>&nbsp;pCreateInfo,
                                <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pPool)</pre>
<div class="block">Allocates Vulkan device memory and creates <code>VmaPool</code> object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocator</code> - Allocator object</dd>
<dd><code>pCreateInfo</code> - parameters of pool to create</dd>
<dd><code>pPool</code> - handle to created pool</dd>
</dl>
</li>
</ul>
<a id="nvmaDestroyPool(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaDestroyPool</h4>
<pre>public static&nbsp;void&nbsp;nvmaDestroyPool&#8203;(long&nbsp;allocator,
                                   long&nbsp;pool)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyPool(long,long)"><code>DestroyPool</code></a></div>
</li>
</ul>
<a id="vmaDestroyPool(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaDestroyPool</h4>
<pre>public static&nbsp;void&nbsp;vmaDestroyPool&#8203;(long&nbsp;allocator,
                                  long&nbsp;pool)</pre>
<div class="block">Destroys <code>VmaPool</code> object and frees Vulkan device memory.</div>
</li>
</ul>
<a id="nvmaGetPoolStats(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaGetPoolStats</h4>
<pre>public static&nbsp;void&nbsp;nvmaGetPoolStats&#8203;(long&nbsp;allocator,
                                    long&nbsp;pool,
                                    long&nbsp;pPoolStats)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetPoolStats(long,long,org.lwjgl.util.vma.VmaPoolStats)"><code>GetPoolStats</code></a></div>
</li>
</ul>
<a id="vmaGetPoolStats(long,long,org.lwjgl.util.vma.VmaPoolStats)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaGetPoolStats</h4>
<pre>public static&nbsp;void&nbsp;vmaGetPoolStats&#8203;(long&nbsp;allocator,
                                   long&nbsp;pool,
                                   <a href="../../../../org/lwjgl/util/vma/VmaPoolStats.html" title="class in org.lwjgl.util.vma">VmaPoolStats</a>&nbsp;pPoolStats)</pre>
<div class="block">Retrieves statistics of existing VmaPool object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocator</code> - Allocator object</dd>
<dd><code>pool</code> - pool object</dd>
<dd><code>pPoolStats</code> - statistics of specified pool</dd>
</dl>
</li>
</ul>
<a id="nvmaMakePoolAllocationsLost(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaMakePoolAllocationsLost</h4>
<pre>public static&nbsp;void&nbsp;nvmaMakePoolAllocationsLost&#8203;(long&nbsp;allocator,
                                               long&nbsp;pool,
                                               long&nbsp;pLostAllocationCount)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMakePoolAllocationsLost(long,long,org.lwjgl.PointerBuffer)"><code>MakePoolAllocationsLost</code></a></div>
</li>
</ul>
<a id="vmaMakePoolAllocationsLost(long,long,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaMakePoolAllocationsLost</h4>
<pre>public static&nbsp;void&nbsp;vmaMakePoolAllocationsLost&#8203;(long&nbsp;allocator,
                                              long&nbsp;pool,
                                              @Nullable
                                              <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pLostAllocationCount)</pre>
<div class="block">Marks all allocations in given pool as lost if they are not used in current frame or <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::frameInUseCount</code> back from now.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocator</code> - Allocator object</dd>
<dd><code>pool</code> - pool</dd>
<dd><code>pLostAllocationCount</code> - number of allocations marked as lost. Optional - pass null if you don't need this information.</dd>
</dl>
</li>
</ul>
<a id="vmaMakePoolAllocationsLost(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaMakePoolAllocationsLost</h4>
<pre>public static&nbsp;long&nbsp;vmaMakePoolAllocationsLost&#8203;(long&nbsp;allocator,
                                              long&nbsp;pool)</pre>
<div class="block">Marks all allocations in given pool as lost if they are not used in current frame or <a href="../../../../org/lwjgl/util/vma/VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::frameInUseCount</code> back from now.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocator</code> - Allocator object</dd>
<dd><code>pool</code> - pool</dd>
</dl>
</li>
</ul>
<a id="nvmaCheckPoolCorruption(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCheckPoolCorruption</h4>
<pre>public static&nbsp;int&nbsp;nvmaCheckPoolCorruption&#8203;(long&nbsp;allocator,
                                          long&nbsp;pool)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckPoolCorruption(long,long)"><code>CheckPoolCorruption</code></a></div>
</li>
</ul>
<a id="vmaCheckPoolCorruption(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCheckPoolCorruption</h4>
<pre>public static&nbsp;int&nbsp;vmaCheckPoolCorruption&#8203;(long&nbsp;allocator,
                                         long&nbsp;pool)</pre>
<div class="block">Checks magic number in margins around all allocations in given memory pool in search for corruptions.
 
 <p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to
 nonzero and the pool is created in memory type that is <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>possible return values:
         
         <ul>
         <li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for specified pool.</li>
         <li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
         <li><code>VK_ERROR_VALIDATION_FAILED_EXT</code> - corruption detection has been performed and found memory corruptions around one of the allocations.
         <code>VMA_ASSERT</code> is also fired in that case.</li>
         <li>Other value: Error returned by Vulkan, e.g. memory mapping failure.</li>
         </ul></dd>
</dl>
</li>
</ul>
<a id="nvmaAllocateMemory(long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaAllocateMemory</h4>
<pre>public static&nbsp;int&nbsp;nvmaAllocateMemory&#8203;(long&nbsp;allocator,
                                     long&nbsp;pVkMemoryRequirements,
                                     long&nbsp;pCreateInfo,
                                     long&nbsp;pAllocation,
                                     long&nbsp;pAllocationInfo)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a></div>
</li>
</ul>
<a id="vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaAllocateMemory</h4>
<pre>public static&nbsp;int&nbsp;vmaAllocateMemory&#8203;(long&nbsp;allocator,
                                    <a href="../../../../org/lwjgl/vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
                                    <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                                    <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                                    @Nullable
                                    <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</pre>
<div class="block">General purpose memory allocation.
 
 <p>You should free the memory using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> or <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a>.</p>
 
 <p>It is recommended to use <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a> instead whenever possible.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pAllocation</code> - handle to allocated memory</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</li>
</ul>
<a id="nvmaAllocateMemoryPages(long,long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaAllocateMemoryPages</h4>
<pre>public static&nbsp;int&nbsp;nvmaAllocateMemoryPages&#8203;(long&nbsp;allocator,
                                          long&nbsp;pVkMemoryRequirements,
                                          long&nbsp;pCreateInfo,
                                          long&nbsp;allocationCount,
                                          long&nbsp;pAllocations,
                                          long&nbsp;pAllocationInfo)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocationCount</code> - number of allocations to make</dd>
</dl>
</li>
</ul>
<a id="vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaAllocateMemoryPages</h4>
<pre>public static&nbsp;int&nbsp;vmaAllocateMemoryPages&#8203;(long&nbsp;allocator,
                                         <a href="../../../../org/lwjgl/vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
                                         <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                                         <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations,
                                         @Nullable
                                         <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.Buffer.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo.Buffer</a>&nbsp;pAllocationInfo)</pre>
<div class="block">General purpose memory allocation for multiple allocation objects at once.
 
 <p>You should free the memory using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> or <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a>.</p>
 
 <p>Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation
 function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>
 <code>allocationCount</code> times.</p>
 
 <p>All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations
 already made within this function call are also freed, so that when returned result is not <code>VK_SUCCESS</code>, <code>pAllocation</code> array is always
 entirely filled with <code>VK_NULL_HANDLE</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>pVkMemoryRequirements</code> - memory requirements for each allocation</dd>
<dd><code>pCreateInfo</code> - creation parameters for each alloction</dd>
<dd><code>pAllocations</code> - pointer to array that will be filled with handles to created allocations</dd>
<dd><code>pAllocationInfo</code> - pointer to array that will be filled with parameters of created allocations. Optional.</dd>
</dl>
</li>
</ul>
<a id="nvmaAllocateMemoryForBuffer(long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaAllocateMemoryForBuffer</h4>
<pre>public static&nbsp;int&nbsp;nvmaAllocateMemoryForBuffer&#8203;(long&nbsp;allocator,
                                              long&nbsp;buffer,
                                              long&nbsp;pCreateInfo,
                                              long&nbsp;pAllocation,
                                              long&nbsp;pAllocationInfo)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a></div>
</li>
</ul>
<a id="vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaAllocateMemoryForBuffer</h4>
<pre>public static&nbsp;int&nbsp;vmaAllocateMemoryForBuffer&#8203;(long&nbsp;allocator,
                                             long&nbsp;buffer,
                                             <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                                             <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                                             @Nullable
                                             <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</pre>
<div class="block">Buffer memory allocation.
 
 <p>You should free the memory using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pAllocation</code> - handle to allocated memory</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</li>
</ul>
<a id="nvmaAllocateMemoryForImage(long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaAllocateMemoryForImage</h4>
<pre>public static&nbsp;int&nbsp;nvmaAllocateMemoryForImage&#8203;(long&nbsp;allocator,
                                             long&nbsp;image,
                                             long&nbsp;pCreateInfo,
                                             long&nbsp;pAllocation,
                                             long&nbsp;pAllocationInfo)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a></div>
</li>
</ul>
<a id="vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaAllocateMemoryForImage</h4>
<pre>public static&nbsp;int&nbsp;vmaAllocateMemoryForImage&#8203;(long&nbsp;allocator,
                                            long&nbsp;image,
                                            <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
                                            <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                                            @Nullable
                                            <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</pre>
<div class="block">Function similar to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pAllocation</code> - handle to allocated memory</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</li>
</ul>
<a id="nvmaFreeMemory(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaFreeMemory</h4>
<pre>public static&nbsp;void&nbsp;nvmaFreeMemory&#8203;(long&nbsp;allocator,
                                  long&nbsp;allocation)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a></div>
</li>
</ul>
<a id="vmaFreeMemory(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaFreeMemory</h4>
<pre>public static&nbsp;void&nbsp;vmaFreeMemory&#8203;(long&nbsp;allocator,
                                 long&nbsp;allocation)</pre>
<div class="block">Frees memory previously allocated using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, or <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>.
 
 <p>Passing <code>VK_NULL_HANDLE</code> as <code>allocation</code> is valid. Such function call is just skipped.</p></div>
</li>
</ul>
<a id="nvmaFreeMemoryPages(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaFreeMemoryPages</h4>
<pre>public static&nbsp;void&nbsp;nvmaFreeMemoryPages&#8203;(long&nbsp;allocator,
                                       long&nbsp;allocationCount,
                                       long&nbsp;pAllocations)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a></div>
</li>
</ul>
<a id="vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaFreeMemoryPages</h4>
<pre>public static&nbsp;void&nbsp;vmaFreeMemoryPages&#8203;(long&nbsp;allocator,
                                      <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations)</pre>
<div class="block">Frees memory and destroys multiple allocations.
 
 <p>Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free
 memory and destroy allocations made using e.g. <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a> and other functions. It may be internally optimized to be more
 efficient than calling <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> <code>allocationCount</code> times.</p>
 
 <p>Allocations in <code>pAllocations</code> array can come from any memory pools and types. Passing <code>VK_NULL_HANDLE</code> as elements of <code>pAllocations</code>
 array is valid. Such entries are just skipped.</p></div>
</li>
</ul>
<a id="nvmaResizeAllocation(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaResizeAllocation</h4>
<pre>public static&nbsp;int&nbsp;nvmaResizeAllocation&#8203;(long&nbsp;allocator,
                                       long&nbsp;allocation,
                                       long&nbsp;newSize)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaResizeAllocation(long,long,long)"><code>ResizeAllocation</code></a></div>
</li>
</ul>
<a id="vmaResizeAllocation(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaResizeAllocation</h4>
<pre>public static&nbsp;int&nbsp;vmaResizeAllocation&#8203;(long&nbsp;allocator,
                                      long&nbsp;allocation,
                                      long&nbsp;newSize)</pre>
<div class="block">Deprecated.
 
 <p>In version 2.2.0 it used to try to change allocation's size without moving or reallocating it. In current version it returns <code>VK_SUCCESS</code> only if
 <code>newSize</code> equals current allocation's size. Otherwise returns <code>VK_ERROR_OUT_OF_POOL_MEMORY</code>, indicating that allocation's size could not be
 changed.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>VK_SUCCESS</code> if allocation's size has been successfully changed. Returns <code>VK_ERROR_OUT_OF_POOL_MEMORY</code> if allocation's size could not be
         changed.</dd>
</dl>
</li>
</ul>
<a id="nvmaGetAllocationInfo(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaGetAllocationInfo</h4>
<pre>public static&nbsp;void&nbsp;nvmaGetAllocationInfo&#8203;(long&nbsp;allocator,
                                         long&nbsp;allocation,
                                         long&nbsp;pAllocationInfo)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a></div>
</li>
</ul>
<a id="vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaGetAllocationInfo</h4>
<pre>public static&nbsp;void&nbsp;vmaGetAllocationInfo&#8203;(long&nbsp;allocator,
                                        long&nbsp;allocation,
                                        <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</pre>
<div class="block">Returns current information about specified allocation and atomically marks it as used in current frame.
 
 <p>Current parameters of given allocation are returned in <code>pAllocationInfo</code>.</p>
 
 <p>This function also atomically "touches" allocation - marks it as used in current frame, just like <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a>. If the allocation is in lost
 state, <code>pAllocationInfo-&gt;deviceMemory == VK_NULL_HANDLE</code>.</p>
 
 <p>Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient, you can avoid calling it too often.</p>
 
 <ul>
 <li>You can retrieve same <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a> structure while creating your resource, from function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. You can remember
 it if you are sure parameters don't change (e.g. due to defragmentation or allocation becoming lost).</li>
 <li>If you just want to check if allocation is not lost, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a> will work faster.</li>
 </ul></div>
</li>
</ul>
<a id="nvmaTouchAllocation(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaTouchAllocation</h4>
<pre>public static&nbsp;int&nbsp;nvmaTouchAllocation&#8203;(long&nbsp;allocator,
                                      long&nbsp;allocation)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a></div>
</li>
</ul>
<a id="vmaTouchAllocation(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaTouchAllocation</h4>
<pre>public static&nbsp;boolean&nbsp;vmaTouchAllocation&#8203;(long&nbsp;allocator,
                                         long&nbsp;allocation)</pre>
<div class="block">Returns <code>VK_TRUE</code> if allocation is not lost and atomically marks it as used in current frame.
 
 <p>If the allocation has been created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> flag, this function returns <code>VK_TRUE</code> if it's not in lost state,
 so it can still be used. It then also atomically "touches" the allocation - marks it as used in current frame, so that you can be sure it won't become
 lost in current frame or next <code>frameInUseCount</code> frames.</p>
 
 <p>If the allocation is in lost state, the function returns <code>VK_FALSE</code>. Memory of such allocation, as well as buffer or image bound to it, should
 not be used. Lost allocation and the buffer/image still need to be destroyed.</p>
 
 <p>If the allocation has been created without <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> flag, this function always returns <code>VK_TRUE</code>.</p></div>
</li>
</ul>
<a id="nvmaSetAllocationUserData(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaSetAllocationUserData</h4>
<pre>public static&nbsp;void&nbsp;nvmaSetAllocationUserData&#8203;(long&nbsp;allocator,
                                             long&nbsp;allocation,
                                             long&nbsp;pUserData)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaSetAllocationUserData(long,long,long)"><code>SetAllocationUserData</code></a></div>
</li>
</ul>
<a id="vmaSetAllocationUserData(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaSetAllocationUserData</h4>
<pre>public static&nbsp;void&nbsp;vmaSetAllocationUserData&#8203;(long&nbsp;allocator,
                                            long&nbsp;allocation,
                                            long&nbsp;pUserData)</pre>
<div class="block">Sets <code>pUserData</code> in given allocation to new value.
 
 <p>If the allocation was created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a>, <code>pUserData</code> must be either null, or pointer to a null-terminated
 string. The function makes local copy of the string and sets it as allocation's <code>pUserData</code>. String passed as <code>pUserData</code> doesn't need to
 be valid for whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation's <code>pUserData</code> is freed
 from memory.</p>
 
 <p>If the flag was not used, the value of pointer <code>pUserData</code> is just copied to allocation's <code>pUserData</code>. It is opaque, so you can use it
 however you want - e.g. as a pointer, ordinal number or some handle to you own data.</p></div>
</li>
</ul>
<a id="nvmaCreateLostAllocation(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCreateLostAllocation</h4>
<pre>public static&nbsp;void&nbsp;nvmaCreateLostAllocation&#8203;(long&nbsp;allocator,
                                            long&nbsp;pAllocation)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateLostAllocation(long,org.lwjgl.PointerBuffer)"><code>CreateLostAllocation</code></a></div>
</li>
</ul>
<a id="vmaCreateLostAllocation(long,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCreateLostAllocation</h4>
<pre>public static&nbsp;void&nbsp;vmaCreateLostAllocation&#8203;(long&nbsp;allocator,
                                           <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation)</pre>
<div class="block">Creates new allocation that is in lost state from the beginning.
 
 <p>It can be useful if you need a dummy, non-null allocation.</p>
 
 <p>You still need to destroy created object using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a>.</p>
 
 <p>Returned allocation is not tied to any specific memory pool or memory type and not bound to any image or buffer. It has size = 0. It cannot be turned
 into a real, non-empty allocation.</p></div>
</li>
</ul>
<a id="nvmaMapMemory(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaMapMemory</h4>
<pre>public static&nbsp;int&nbsp;nvmaMapMemory&#8203;(long&nbsp;allocator,
                                long&nbsp;allocation,
                                long&nbsp;ppData)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a></div>
</li>
</ul>
<a id="vmaMapMemory(long,long,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaMapMemory</h4>
<pre>public static&nbsp;int&nbsp;vmaMapMemory&#8203;(long&nbsp;allocator,
                               long&nbsp;allocation,
                               <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppData)</pre>
<div class="block">Maps memory represented by given allocation and returns pointer to it.
 
 <p>Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, <code>*ppData</code> contains pointer to first byte of this
 memory. If the allocation is part of bigger <code>VkDeviceMemory</code> block, the pointer is correctly offseted to the beginning of region assigned to this
 particular allocation.</p>
 
 <p>Mapping is internally reference-counted and synchronized, so despite raw Vulkan function <code>vkMapMemory()</code> cannot be used to map same block of
 <code>VkDeviceMemory</code> multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan
 memory will be mapped on first mapping and unmapped on last unmapping.</p>
 
 <p>If the function succeeded, you must call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a> to unmap the allocation when mapping is no longer needed or before freeing the allocation, at
 the latest.</p>
 
 <p>It also safe to call this function multiple times on the same allocation. You must call <code>vmaUnmapMemory()</code> same number of times as you called
 <code>vmaMapMemory()</code>.</p>
 
 <p>It is also safe to call this function on allocation created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag. Its memory stays mapped all the time. You must
 still call <code>vmaUnmapMemory()</code> same number of times as you called <code>vmaMapMemory()</code>. You must not call <code>vmaUnmapMemory()</code> additional
 time to free the "0-th" mapping made automatically due to <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag.</p>
 
 <p>This function fails when used on allocation made in memory type that is not <code>HOST_VISIBLE</code>.</p>
 
 <p>This function always fails when called for allocation that was created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT"><code>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</code></a> flag. Such allocations cannot be
 mapped.</p></div>
</li>
</ul>
<a id="nvmaUnmapMemory(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaUnmapMemory</h4>
<pre>public static&nbsp;void&nbsp;nvmaUnmapMemory&#8203;(long&nbsp;allocator,
                                   long&nbsp;allocation)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a></div>
</li>
</ul>
<a id="vmaUnmapMemory(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaUnmapMemory</h4>
<pre>public static&nbsp;void&nbsp;vmaUnmapMemory&#8203;(long&nbsp;allocator,
                                  long&nbsp;allocation)</pre>
<div class="block">Unmaps memory represented by given allocation, mapped previously using <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a>.
 
 <p>For details, see description of <code>vmaMapMemory()</code>.</p></div>
</li>
</ul>
<a id="nvmaFlushAllocation(long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaFlushAllocation</h4>
<pre>public static&nbsp;void&nbsp;nvmaFlushAllocation&#8203;(long&nbsp;allocator,
                                       long&nbsp;allocation,
                                       long&nbsp;offset,
                                       long&nbsp;size)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a></div>
</li>
</ul>
<a id="vmaFlushAllocation(long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaFlushAllocation</h4>
<pre>public static&nbsp;void&nbsp;vmaFlushAllocation&#8203;(long&nbsp;allocator,
                                      long&nbsp;allocation,
                                      long&nbsp;offset,
                                      long&nbsp;size)</pre>
<div class="block">Flushes memory of given allocation.
 
 <p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given range of given allocation.</p>
 
 <ul>
 <li><code>offset</code> must be relative to the beginning of allocation.</li>
 <li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
 <li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
 <li>If <code>size</code> is 0, this call is ignored.</li>
 <li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
 </ul>
 
 <p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and
 <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p></div>
</li>
</ul>
<a id="nvmaInvalidateAllocation(long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaInvalidateAllocation</h4>
<pre>public static&nbsp;void&nbsp;nvmaInvalidateAllocation&#8203;(long&nbsp;allocator,
                                            long&nbsp;allocation,
                                            long&nbsp;offset,
                                            long&nbsp;size)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a></div>
</li>
</ul>
<a id="vmaInvalidateAllocation(long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaInvalidateAllocation</h4>
<pre>public static&nbsp;void&nbsp;vmaInvalidateAllocation&#8203;(long&nbsp;allocator,
                                           long&nbsp;allocation,
                                           long&nbsp;offset,
                                           long&nbsp;size)</pre>
<div class="block">Invalidates memory of given allocation.
 
 <p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given range of given allocation.</p>
 
 <ul>
 <li><code>offset</code> must be relative to the beginning of allocation.</li>
 <li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
 <li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
 <li>If <code>size</code> is 0, this call is ignored.</li>
 <li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
 </ul>
 
 <p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and
 <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p></div>
</li>
</ul>
<a id="nvmaCheckCorruption(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCheckCorruption</h4>
<pre>public static&nbsp;int&nbsp;nvmaCheckCorruption&#8203;(long&nbsp;allocator,
                                      int&nbsp;memoryTypeBits)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCheckCorruption(long,int)"><code>CheckCorruption</code></a></div>
</li>
</ul>
<a id="vmaCheckCorruption(long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCheckCorruption</h4>
<pre>public static&nbsp;int&nbsp;vmaCheckCorruption&#8203;(long&nbsp;allocator,
                                     int&nbsp;memoryTypeBits)</pre>
<div class="block">Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.
 
 <p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to
 nonzero and only for memory types that are <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>memoryTypeBits</code> - bit mask, where each bit set means that a memory type with that index should be checked</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>possible return values:
         
         <ul>
         <li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for any of specified memory types.</li>
         <li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
         <li><code>VK_ERROR_VALIDATION_FAILED_EXT</code> - corruption detection has been performed and found memory corruptions around one of the allocations.
         <code>VMA_ASSERT</code> is also fired in that case.</li>
         <li>Other value: Error returned by Vulkan, e.g. memory mapping failure.</li>
         </ul></dd>
</dl>
</li>
</ul>
<a id="nvmaDefragmentationBegin(long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaDefragmentationBegin</h4>
<pre>public static&nbsp;int&nbsp;nvmaDefragmentationBegin&#8203;(long&nbsp;allocator,
                                           long&nbsp;pInfo,
                                           long&nbsp;pStats,
                                           long&nbsp;pContext)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)"><code>DefragmentationBegin</code></a></div>
</li>
</ul>
<a id="vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaDefragmentationBegin</h4>
<pre>public static&nbsp;int&nbsp;vmaDefragmentationBegin&#8203;(long&nbsp;allocator,
                                          <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationInfo2.html" title="class in org.lwjgl.util.vma">VmaDefragmentationInfo2</a>&nbsp;pInfo,
                                          @Nullable
                                          <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationStats.html" title="class in org.lwjgl.util.vma">VmaDefragmentationStats</a>&nbsp;pStats,
                                          <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pContext)</pre>
<div class="block">Begins defragmentation process.
 
 <p>Use this function instead of old, deprecated <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragment(long,org.lwjgl.PointerBuffer,java.nio.IntBuffer,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.util.vma.VmaDefragmentationStats)"><code>Defragment</code></a>.</p>
 
 <p>Warning! Between the call to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)"><code>DefragmentationBegin</code></a> and <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a>:</p>
 
 <ul>
 <li>You should not use any of allocations passed as <code>pInfo-&gt;pAllocations</code> or any allocations that belong to pools passed as
 <code>pInfo-&gt;pPools</code>, including calling <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>, <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaTouchAllocation(long,long)"><code>TouchAllocation</code></a>, or access their data.</li>
 <li>Some mutexes protecting internal data structures may be locked, so trying to make or free any allocations, bind buffers or images, map memory, or
 launch another simultaneous defragmentation in between may cause stall (when done on another thread) or deadlock (when done on the same thread),
 unless you are 100% sure that defragmented allocations are in different pools.</li>
 <li>Information returned via <code>pStats</code> and <code>pInfo-&gt;pAllocationsChanged</code> are undefined. They become valid after call to
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a>.</li>
 <li>If <code>pInfo-&gt;commandBuffer</code> is not null, you must submit that command buffer and make sure it finished execution before calling
 <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a>.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>pInfo</code> - structure filled with parameters of defragmentation</dd>
<dd><code>pStats</code> - Optional. Statistics of defragmentation. You can pass null if you are not interested in this information.</dd>
<dd><code>pContext</code> - context object that must be passed to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a> to finish defragmentation</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>VK_SUCCESS</code> and <code>*pContext == null</code> if defragmentation finished within this function call. <code>VK_NOT_READY</code> and
         <code>*pContext != null</code> if defragmentation has been started and you need to call <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a> to finish it. Negative value in case of error.</dd>
</dl>
</li>
</ul>
<a id="nvmaDefragmentationEnd(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaDefragmentationEnd</h4>
<pre>public static&nbsp;int&nbsp;nvmaDefragmentationEnd&#8203;(long&nbsp;allocator,
                                         long&nbsp;context)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationEnd(long,long)"><code>DefragmentationEnd</code></a></div>
</li>
</ul>
<a id="vmaDefragmentationEnd(long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaDefragmentationEnd</h4>
<pre>public static&nbsp;int&nbsp;vmaDefragmentationEnd&#8203;(long&nbsp;allocator,
                                        long&nbsp;context)</pre>
<div class="block">Ends defragmentation process.
 
 <p>Use this function to finish defragmentation started by <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)"><code>DefragmentationBegin</code></a>. It is safe to pass <code>context == null</code>. The function then does
 nothing.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocator</code> - allocator object</dd>
</dl>
</li>
</ul>
<a id="nvmaDefragment(long,long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaDefragment</h4>
<pre>public static&nbsp;int&nbsp;nvmaDefragment&#8203;(long&nbsp;allocator,
                                 long&nbsp;pAllocations,
                                 long&nbsp;allocationCount,
                                 long&nbsp;pAllocationsChanged,
                                 long&nbsp;pDefragmentationInfo,
                                 long&nbsp;pDefragmentationStats)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragment(long,org.lwjgl.PointerBuffer,java.nio.IntBuffer,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.util.vma.VmaDefragmentationStats)"><code>Defragment</code></a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocationCount</code> - number of elements in <code>pAllocations</code> and <code>pAllocationsChanged</code> arrays</dd>
</dl>
</li>
</ul>
<a id="vmaDefragment(long,org.lwjgl.PointerBuffer,java.nio.IntBuffer,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.util.vma.VmaDefragmentationStats)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaDefragment</h4>
<pre>public static&nbsp;int&nbsp;vmaDefragment&#8203;(long&nbsp;allocator,
                                <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations,
                                @Nullable
                                java.nio.IntBuffer&nbsp;pAllocationsChanged,
                                @Nullable
                                <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationInfo</a>&nbsp;pDefragmentationInfo,
                                @Nullable
                                <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationStats.html" title="class in org.lwjgl.util.vma">VmaDefragmentationStats</a>&nbsp;pDefragmentationStats)</pre>
<div class="block">Deprecated: This is a part of the old interface. It is recommended to use structure <a href="../../../../org/lwjgl/util/vma/VmaDefragmentationInfo2.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo2</code></a> and function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDefragmentationBegin(long,org.lwjgl.util.vma.VmaDefragmentationInfo2,org.lwjgl.util.vma.VmaDefragmentationStats,org.lwjgl.PointerBuffer)"><code>DefragmentationBegin</code></a>
 instead.
 
 <p>Compacts memory by moving allocations.</p>
 
 <p>This function works by moving allocations to different places (different <code>VkDeviceMemory</code> objects and/or different offsets) in order to optimize
 memory usage. Only allocations that are in <code>pAllocations</code> array can be moved. All other allocations are considered nonmovable in this call. Basic
 rules:</p>
 
 <ul>
 <li>Only allocations made in memory types that have <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> flags
 can be compacted. You may pass other allocations but it makes no sense - these will never be moved.</li>
 <li>Custom pools created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> or <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT"><code>POOL_CREATE_BUDDY_ALGORITHM_BIT</code></a> flag are not defragmented. Allocations passed to
 this function that come from such pools are ignored.</li>
 <li>Allocations created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> or created as dedicated allocations for any other reason are also ignored.</li>
 <li>Both allocations made with or without <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag can be compacted. If not persistently mapped, memory will be mapped
 temporarily inside this function if needed.</li>
 <li>You must not pass same <code>VmaAllocation</code> object multiple times in <code>pAllocations</code> array.</li>
 </ul>
 
 <p>The function also frees empty <code>VkDeviceMemory</code> blocks.</p>
 
 <p>Warning: This function may be time-consuming, so you shouldn't call it too often (like after every resource creation/destruction). You
 can call it on special occasions (like when reloading a game level or when you just destroyed a lot of objects). Calling it every frame may be OK, but
 you should measure that on your platform.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pAllocations</code> - array of allocations that can be moved during this compaction</dd>
<dd><code>pAllocationsChanged</code> - array of boolean values that will indicate whether matching allocation in <code>pAllocations</code> array has been moved. This parameter is optional.
                              Pass null if you don't need this information.</dd>
<dd><code>pDefragmentationInfo</code> - configuration parameters. Optional - pass null to use default values.</dd>
<dd><code>pDefragmentationStats</code> - statistics returned by the function. Optional - pass null if you don't need this information.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>VK_SUCCESS</code> if completed, negative error code in case of error.</dd>
</dl>
</li>
</ul>
<a id="nvmaBindBufferMemory(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaBindBufferMemory</h4>
<pre>public static&nbsp;int&nbsp;nvmaBindBufferMemory&#8203;(long&nbsp;allocator,
                                       long&nbsp;allocation,
                                       long&nbsp;buffer)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a></div>
</li>
</ul>
<a id="vmaBindBufferMemory(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaBindBufferMemory</h4>
<pre>public static&nbsp;int&nbsp;vmaBindBufferMemory&#8203;(long&nbsp;allocator,
                                      long&nbsp;allocation,
                                      long&nbsp;buffer)</pre>
<div class="block">Binds buffer to allocation.
 
 <p>Binds specified buffer to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If
 you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard
 <code>vkBindBufferMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations,
 calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
 
 <p>It is recommended to use function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> instead of this one.</p></div>
</li>
</ul>
<a id="nvmaBindBufferMemory2(long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaBindBufferMemory2</h4>
<pre>public static&nbsp;int&nbsp;nvmaBindBufferMemory2&#8203;(long&nbsp;allocator,
                                        long&nbsp;allocation,
                                        long&nbsp;allocationLocalOffset,
                                        long&nbsp;buffer,
                                        long&nbsp;pNext)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a></div>
</li>
</ul>
<a id="vmaBindBufferMemory2(long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaBindBufferMemory2</h4>
<pre>public static&nbsp;int&nbsp;vmaBindBufferMemory2&#8203;(long&nbsp;allocator,
                                       long&nbsp;allocation,
                                       long&nbsp;allocationLocalOffset,
                                       long&nbsp;buffer,
                                       long&nbsp;pNext)</pre>
<div class="block">Binds buffer to allocation with additional parameters.
 
 <p>This function is similar to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a>, but it provides additional parameters.</p>
 
 <p>If <code>pNext</code> is not null, <code>VmaAllocator</code> object must have been created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> flag. Otherwise the call
 fails.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocationLocalOffset</code> - additional offset to be added while binding, relative to the beginning of the <code>allocatio</code>n. Normally it should be 0.</dd>
<dd><code>pNext</code> - a chain of structures to be attached to <code>VkBindBufferMemoryInfoKHR</code> structure used internally. Normally it should be <code>null</code>.</dd>
</dl>
</li>
</ul>
<a id="nvmaBindImageMemory(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaBindImageMemory</h4>
<pre>public static&nbsp;int&nbsp;nvmaBindImageMemory&#8203;(long&nbsp;allocator,
                                      long&nbsp;allocation,
                                      long&nbsp;image)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a></div>
</li>
</ul>
<a id="vmaBindImageMemory(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaBindImageMemory</h4>
<pre>public static&nbsp;int&nbsp;vmaBindImageMemory&#8203;(long&nbsp;allocator,
                                     long&nbsp;allocation,
                                     long&nbsp;image)</pre>
<div class="block">Binds image to allocation.
 
 <p>Binds specified image to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If
 you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard
 <code>vkBindImageMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations,
 calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
 
 <p>It is recommended to use function vmaCreateImage() instead of this one.</p></div>
</li>
</ul>
<a id="nvmaBindImageMemory2(long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaBindImageMemory2</h4>
<pre>public static&nbsp;int&nbsp;nvmaBindImageMemory2&#8203;(long&nbsp;allocator,
                                       long&nbsp;allocation,
                                       long&nbsp;allocationLocalOffset,
                                       long&nbsp;image,
                                       long&nbsp;pNext)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a></div>
</li>
</ul>
<a id="vmaBindImageMemory2(long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaBindImageMemory2</h4>
<pre>public static&nbsp;int&nbsp;vmaBindImageMemory2&#8203;(long&nbsp;allocator,
                                      long&nbsp;allocation,
                                      long&nbsp;allocationLocalOffset,
                                      long&nbsp;image,
                                      long&nbsp;pNext)</pre>
<div class="block">Binds image to allocation with additional parameters.
 
 <p>This function is similar to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a>, but it provides additional parameters.</p>
 
 <p>If <code>pNext</code> is not null, <code>VmaAllocator</code> object must have been created with <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> flag. Otherwise the call
 fails.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>allocationLocalOffset</code> - additional offset to be added while binding, relative to the beginning of the <code>allocatio</code>n. Normally it should be 0.</dd>
<dd><code>pNext</code> - a chain of structures to be attached to <code>VkBindImageMemoryInfoKHR</code> structure used internally. Normally it should be null.</dd>
</dl>
</li>
</ul>
<a id="nvmaCreateBuffer(long,long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCreateBuffer</h4>
<pre>public static&nbsp;int&nbsp;nvmaCreateBuffer&#8203;(long&nbsp;allocator,
                                   long&nbsp;pBufferCreateInfo,
                                   long&nbsp;pAllocationCreateInfo,
                                   long&nbsp;pBuffer,
                                   long&nbsp;pAllocation,
                                   long&nbsp;pAllocationInfo)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a></div>
</li>
</ul>
<a id="vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCreateBuffer</h4>
<pre>public static&nbsp;int&nbsp;vmaCreateBuffer&#8203;(long&nbsp;allocator,
                                  <a href="../../../../org/lwjgl/vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
                                  <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                                  java.nio.LongBuffer&nbsp;pBuffer,
                                  <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                                  @Nullable
                                  <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</pre>
<div class="block">This function automatically:
 
 <ul>
 <li>Creates buffer.</li>
 <li>Allocates appropriate memory for it.</li>
 <li>Binds the buffer with the memory.</li>
 </ul>
 
 <p>If any of these operations fail, buffer and allocation are not created, returned value is negative error code, <code>*pBuffer</code> and
 <code>*pAllocation</code> are null.</p>
 
 <p>If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>
 or separately, using <code>vkDestroyBuffer()</code> and <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaFreeMemory(long,long)"><code>FreeMemory</code></a>.</p>
 
 <p>If <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> flag was used, <code>VK_KHR_dedicated_allocation</code> extension is used internally to query driver
 whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible
 <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pool</code> is null and <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> is not used), it creates dedicated allocation for this
 buffer, just like when using <a href="../../../../org/lwjgl/util/vma/Vma.html#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pBuffer</code> - buffer that was created</dd>
<dd><code>pAllocation</code> - allocation that was created</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</li>
</ul>
<a id="nvmaDestroyBuffer(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaDestroyBuffer</h4>
<pre>public static&nbsp;void&nbsp;nvmaDestroyBuffer&#8203;(long&nbsp;allocator,
                                     long&nbsp;buffer,
                                     long&nbsp;allocation)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a></div>
</li>
</ul>
<a id="vmaDestroyBuffer(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaDestroyBuffer</h4>
<pre>public static&nbsp;void&nbsp;vmaDestroyBuffer&#8203;(long&nbsp;allocator,
                                    long&nbsp;buffer,
                                    long&nbsp;allocation)</pre>
<div class="block">Destroys Vulkan buffer and frees allocated memory.
 
 <p>This is just a convenience function equivalent to:</p>
 
 <pre><code>
 vkDestroyBuffer(device, buffer, allocationCallbacks);
 vmaFreeMemory(allocator, allocation);</code></pre>
 
 <p>It it safe to pass null as buffer and/or allocation.</p></div>
</li>
</ul>
<a id="nvmaCreateImage(long,long,long,long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaCreateImage</h4>
<pre>public static&nbsp;int&nbsp;nvmaCreateImage&#8203;(long&nbsp;allocator,
                                  long&nbsp;pImageCreateInfo,
                                  long&nbsp;pAllocationCreateInfo,
                                  long&nbsp;pImage,
                                  long&nbsp;pAllocation,
                                  long&nbsp;pAllocationInfo)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a></div>
</li>
</ul>
<a id="vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vmaCreateImage</h4>
<pre>public static&nbsp;int&nbsp;vmaCreateImage&#8203;(long&nbsp;allocator,
                                 <a href="../../../../org/lwjgl/vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
                                 <a href="../../../../org/lwjgl/util/vma/VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
                                 java.nio.LongBuffer&nbsp;pImage,
                                 <a href="../../../../org/lwjgl/PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
                                 @Nullable
                                 <a href="../../../../org/lwjgl/util/vma/VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</pre>
<div class="block">Function similar to <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pImage</code> - image that was created</dd>
<dd><code>pAllocation</code> - allocation that was created</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</li>
</ul>
<a id="nvmaDestroyImage(long,long,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nvmaDestroyImage</h4>
<pre>public static&nbsp;void&nbsp;nvmaDestroyImage&#8203;(long&nbsp;allocator,
                                    long&nbsp;image,
                                    long&nbsp;allocation)</pre>
<div class="block">Unsafe version of: <a href="../../../../org/lwjgl/util/vma/Vma.html#vmaDestroyImage(long,long,long)"><code>DestroyImage</code></a></div>
</li>
</ul>
<a id="vmaDestroyImage(long,long,long)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>vmaDestroyImage</h4>
<pre>public static&nbsp;void&nbsp;vmaDestroyImage&#8203;(long&nbsp;allocator,
                                   long&nbsp;image,
                                   long&nbsp;allocation)</pre>
<div class="block">Destroys Vulkan image and frees allocated memory.
 
 <p>This is just a convenience function equivalent to:</p>
 
 <pre><code>
 vkDestroyImage(device, image, allocationCallbacks);
 vmaFreeMemory(allocator, allocation);</code></pre>
 
 <p>It it safe to pass null as image and/or allocation.</p></div>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../org/lwjgl/util/vma/VmaAllocateDeviceMemoryFunction.html" title="class in org.lwjgl.util.vma"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/lwjgl/util/vma/Vma.html" target="_top">Frames</a></li>
<li><a href="Vma.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</body>
</html>
