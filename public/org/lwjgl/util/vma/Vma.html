<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) -->
<title>Vma (LWJGL 3.3.2-snapshot)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.lwjgl.util.vma, class: Vma">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li><a href="#field-summary">Field</a></li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.lwjgl.util.vma</a></div>
<h1 title="Class Vma" class="title">Class Vma</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.lwjgl.util.vma.Vma</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">Vma</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">The Vulkan Memory Allocator.
 
 <h3>Quick start</h3>
 
 <h4>Initialization</h4>
 
 <p>At program startup:</p>
 
 <ol>
 <li>Initialize Vulkan to have <code>VkPhysicalDevice</code>, <code>VkDevice</code> and <code>VkInstance</code> object.</li>
 <li>Fill <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a> structure and create <code>VmaAllocator</code> object by calling <a href="#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a>.</li>
 </ol>
 
 <pre><code>
 VmaVulkanFunctions vulkanFunctions = {};
 vulkanFunctions.vkGetInstanceProcAddr = &amp;vkGetInstanceProcAddr;
 vulkanFunctions.vkGetDeviceProcAddr = &amp;vkGetDeviceProcAddr;
 
 VmaAllocatorCreateInfo allocatorCreateInfo = {};
 allocatorCreateInfo.vulkanApiVersion = VK_API_VERSION_1_2;
 allocatorCreateInfo.physicalDevice = physicalDevice;
 allocatorCreateInfo.device = device;
 allocatorCreateInfo.instance = instance;
 allocatorCreateInfo.pVulkanFunctions = &amp;vulkanFunctions;
 
 VmaAllocator allocator;
 vmaCreateAllocator(&amp;allocatorCreateInfo, &amp;allocator);</code></pre>
 
 <p>Only members <code>physicalDevice</code>, <code>device</code>, <code>instance</code> are required. However, you should inform the library which Vulkan version do you
 use by setting <code>VmaAllocatorCreateInfo::vulkanApiVersion</code> and which extensions did you enable by setting <code>VmaAllocatorCreateInfo::flags</code>
 (like <a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> for <code>VK_KHR_buffer_device_address</code>). Otherwise, VMA would use only features of Vulkan 1.0 core
 with no extensions.</p>
 
 <h4>Resource allocation</h4>
 
 <p>When you want to create a buffer or image:</p>
 
 <ol>
 <li>Fill <code>VkBufferCreateInfo</code> / <code>VkImageCreateInfo</code> structure.</li>
 <li>Fill <code>VmaAllocationCreateInfo</code> structure.</li>
 <li>Call <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> / <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a> to get <code>VkBuffer</code>/<code>VkImage</code> with memory already allocated and bound to it, plus
 <code>VmaAllocation</code> objects that represents its underlying memory.</li>
 </ol>
 
 <pre><code>
 VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufferInfo.size = 65536;
 bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <p>Don't forget to destroy your objects when no longer needed:</p>
 
 <pre><code>
 vmaDestroyBuffer(allocator, buffer, allocation);
 vmaDestroyAllocator(allocator);</code></pre>
 
 <h3>Choosing memory type</h3>
 
 <p>Physical devices in Vulkan support various combinations of memory heaps and types. Help with choosing correct and optimal memory type for your specific
 resource is one of the key features of this library. You can use it by filling appropriate members of VmaAllocationCreateInfo structure, as described
 below. You can also combine multiple methods.</p>
 
 <ol>
 <li>If you just want to find memory type index that meets your requirements, you can use function: <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, 
 <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a>, <a href="#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a>.</li>
 <li>If you want to allocate a region of device memory without association with any specific image or buffer, you can use function <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>.
 Usage of this function is not recommended and usually not needed. <a href="#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a> function is also provided for creating multiple
 allocations at once, which may be useful for sparse binding.</li>
 <li>If you already have a buffer or an image created, you want to allocate memory for it and then you will bind it yourself, you can use function
 <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>. For binding you should use functions: <a href="#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a>, <a href="#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a> or their
 extended versions: <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a>, <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</li>
 <li><b>This is the easiest and recommended way to use this library:</b> If you want to create a buffer or an image, allocate memory for it and bind
 them together, all in one call, you can use function <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>.</li>
 </ol>
 
 <p>When using 3. or 4., the library internally queries Vulkan for memory types supported for that buffer or image (function
 <code>vkGetBufferMemoryRequirements()</code>) and uses only one of these types.</p>
 
 <p>If no memory type can be found that meets all the requirements, these functions return <code>VK_ERROR_FEATURE_NOT_PRESENT</code>.</p>
 
 <p>You can leave <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> structure completely filled with zeros. It means no requirements are specified for memory type. It is valid,
 although not very useful.</p>
 
 <h4>Usage</h4>
 
 <p>The easiest way to specify memory requirements is to fill member <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::usage</code> using one of the values of enum
 <code>VmaMemoryUsage</code>. It defines high level, common usage types. Since version 3 of the library, it is recommended to use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> to let
 it select best memory type for your resource automatically.</p>
 
 <p>For example, if you want to create a uniform buffer that will be filled using transfer only once or infrequently and then used for rendering every
 frame as a uniform buffer, you can do it using following code. The buffer will most likely end up in a memory type with
 <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> to be fast to access by the GPU device.</p>
 
 <pre><code>
 VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufferInfo.size = 65536;
 bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <p>If you have a preference for putting the resource in GPU (device) memory or CPU (host) memory on systems with discrete graphics card that have the
 memories separate, you can use <a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> or <a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a>.</p>
 
 <p>When using <code>VMA_MEMORY_USAGE_AUTO*</code> while you want to map the allocated memory, you also need to specify one of the host access flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>. This will help the library decide about preferred
 memory type to ensure it has <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> so you can map it.</p>
 
 <p>For example, a staging buffer that will be filled via mapped pointer and then used as a source of transfer to the buffer described previously can be
 created like this. It will likely end up in a memory type that is <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code> but not <code>HOST_CACHED</code> (meaning
 uncached, write-combined) and not <code>DEVICE_LOCAL</code> (meaning system RAM).</p>
 
 <pre><code>
 VkBufferCreateInfo stagingBufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 stagingBufferInfo.size = 65536;
 stagingBufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
 
 VmaAllocationCreateInfo stagingAllocInfo = {};
 stagingAllocInfo.usage = VMA_MEMORY_USAGE_AUTO;
 stagingAllocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;
 
 VkBuffer stagingBuffer;
 VmaAllocation stagingAllocation;
 vmaCreateBuffer(allocator, &amp;stagingBufferInfo, &amp;stagingAllocInfo, &amp;stagingBuffer, &amp;stagingAllocation, nullptr);</code></pre>
 
 <p>Usage values <code>VMA_MEMORY_USAGE_AUTO*</code> are legal to use only when the library knows about the resource being created by having
 <code>VkBufferCreateInfo</code> / <code>VkImageCreateInfo</code> passed, so they work with functions like: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>,
 <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a> etc. If you allocate raw memory using function <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, you have to use other means of selecting memory
 type, as described below.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Old usage values (<a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a>, <a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a>, <a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a>, <a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a>, <a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a>) are still
 available and work same way as in previous versions of the library for backward compatibility, but they are not recommended.</p></div>
 
 <h4>Required and preferred flags</h4>
 
 <p>You can specify more detailed requirements by filling members <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::requiredFlags</code> and
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::preferredFlags</code> with a combination of bits from enum <code>VkMemoryPropertyFlags</code>. For example, if you want to
 create a buffer that will be persistently mapped on host (so it must be <code>HOST_VISIBLE</code>) and preferably will also be <code>HOST_COHERENT</code> and
 <code>HOST_CACHED</code>, use following code:</p>
 
 <pre><code>
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
 allocInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
 allocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <p>A memory type is chosen that has all the required flags and as many preferred flags set as possible.</p>
 
 <p>Value passed in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::usage</code> is internally converted to a set of required and preferred flags, plus some extra "magic"
 (heuristics).</p>
 
 <h4>Explicit memory types</h4>
 
 <p>If you inspected memory types available on the physical device and you have a preference for memory types that you want to use, you can fill member
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::memoryTypeBits</code>. It is a bit mask, where each bit set means that a memory type with that index is allowed to be used
 for the allocation. Special value 0, just like <code>UINT32_MAX</code>, means there are no restrictions to memory type index.</p>
 
 <p>Please note that this member is NOT just a memory type index. Still you can use it to choose just one, specific memory type. For example, if you
 already determined that your buffer should be created in memory type 2, use following code:</p>
 
 <pre><code>
 uint32_t memoryTypeIndex = 2;
 
 VmaAllocationCreateInfo allocInfo = {};
 allocInfo.memoryTypeBits = 1u &lt;&lt; memoryTypeIndex;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <h4>Custom memory pools</h4>
 
 <p>If you allocate from custom memory pool, all the ways of specifying memory requirements described above are not applicable and the aforementioned
 members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> structure are ignored. Memory type is selected explicitly when creating the pool and then used to make all the
 allocations from that pool. For further details, see Custom Memory Pools below.</p>
 
 <h4>Dedicated allocations</h4>
 
 <p>Memory for allocations is reserved out of larger block of <code>VkDeviceMemory</code> allocated from Vulkan internally. That is the main feature of this
 whole library. You can still request a separate memory block to be created for an allocation, just like you would do in a trivial solution without
 using any allocator. In that case, a buffer or image is always bound to that memory at offset 0. This is called a "dedicated allocation". You can
 explicitly request it by using flag <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>. The library can also internally decide to use dedicated allocation in some
 cases, e.g.:</p>
 
 <ul>
 <li>When the size of the allocation is large.</li>
 <li>When <code>VK_KHR_dedicated_allocation</code> extension is enabled and it reports that dedicated allocation is required or recommended for the resource.</li>
 <li>When allocation of next big memory block fails due to not enough device memory, but allocation with the exact requested size succeeds.</li>
 </ul>
 
 <h3>Memory mapping</h3>
 
 <p>To "map memory" in Vulkan means to obtain a CPU pointer to <code>VkDeviceMemory</code>, to be able to read from it or write to it in CPU code. Mapping is
 possible only of memory allocated from a memory type that has <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> flag. Functions <code>vkMapMemory()</code>,
 <code>vkUnmapMemory()</code> are designed for this purpose. You can use them directly with memory allocated by this library, but it is not recommended
 because of following issue: Mapping the same <code>VkDeviceMemory</code> block multiple times is illegal - only one mapping at a time is allowed. This
 includes mapping disjoint regions. Mapping is not reference-counted internally by Vulkan. Because of this, Vulkan Memory Allocator provides following
 facilities:</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If you want to be able to map an allocation, you need to specify one of the flags <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. These flags are required for an allocation to be mappable when
 using <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> enum values. For other usage values they are ignored and every such allocation made in
 <code>HOST_VISIBLE</code> memory type is mappable, but they can still be used for consistency.</p>
 </div>
 
 <h4>Mapping functions</h4>
 
 <p>The library provides following functions for mapping of a specific <code>VmaAllocation</code>: <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a>, <a href="#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a>. They are safer and more
 convenient to use than standard Vulkan functions. You can map an allocation multiple times simultaneously - mapping is reference-counted internally.
 You can also map different allocations simultaneously regardless of whether they use the same <code>VkDeviceMemory</code> block. The way it is implemented
 is that the library always maps entire memory block, not just region of the allocation. For further details, see description of <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> function.
 Example:</p>
 
 <pre><code>
 // Having these objects initialized:
 struct ConstantBuffer
 {
     ...
 };
 ConstantBuffer constantBufferData = ...
 
 VmaAllocator allocator = ...
 VkBuffer constantBuffer = ...
 VmaAllocation constantBufferAllocation = ...
 
 // You can map and fill your buffer using following code:
 
 void* mappedData;
 vmaMapMemory(allocator, constantBufferAllocation, &amp;mappedData);
 memcpy(mappedData, &amp;constantBufferData, sizeof(constantBufferData));
 vmaUnmapMemory(allocator, constantBufferAllocation);</code></pre>
 
 <p>When mapping, you may see a warning from Vulkan validation layer similar to this one:</p>
 
 <p><i>Mapping an image with layout <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> can result in undefined behavior if this memory is used by the
 device. Only <code>GENERAL</code> or <code>PREINITIALIZED</code> should be used.</i></p>
 
 <p>It happens because the library maps entire <code>VkDeviceMemory</code> block, where different types of images and buffers may end up together, especially on
 GPUs with unified memory like Intel. You can safely ignore it if you are sure you access only memory of the intended object that you wanted to map.</p>
 
 <h4>Persistently mapped memory</h4>
 
 <p>Keeping your memory persistently mapped is generally OK in Vulkan. You don't need to unmap it before using its data on the GPU. The library provides a
 special feature designed for that: Allocations made with <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag set in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code> stay mapped
 all the time, so you can just access CPU pointer to it any time without a need to call any "map" or "unmap" function. Example:</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = sizeof(ConstantBuffer);
 bufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
     VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 // Buffer is already mapped. You can access its memory.
 memcpy(allocInfo.pMappedData, &amp;constantBufferData, sizeof(constantBufferData));</code></pre>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> by itself doesn't guarantee that the allocation will end up in a mappable memory type. For this, you need to also specify
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>. <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> only guarantees that if
 the memory is <code>HOST_VISIBLE</code>, the allocation will be mapped on creation.</p></div>
 
 <h4>Cache flush and invalidate</h4>
 
 <p>Memory in Vulkan doesn't need to be unmapped before using it on GPU, but unless a memory types has <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> flag
 set, you need to manually <b>invalidate</b> cache before reading of mapped pointer and <b>flush</b> cache after writing to mapped pointer. Map/unmap
 operations don't do that automatically. Vulkan provides following functions for this purpose <code>vkFlushMappedMemoryRangs()</code>,
 <code>vkInvalidateMappedMemoryRanges()</code>, but this library provides more convenient functions that refer to given allocation object:
 <a href="#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a>, <a href="#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a>, or multiple objects at once: <a href="#vmaFlushAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)"><code>FlushAllocations</code></a>, <a href="#vmaInvalidateAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)"><code>InvalidateAllocations</code></a>.</p>
 
 <p>Regions of memory specified for flush/invalidate must be aligned to <code>VkPhysicalDeviceLimits::nonCoherentAtomSize</code>. This is automatically ensured
 by the library. In any memory type that is <code>HOST_VISIBLE</code> but not <code>HOST_COHERENT</code>, all allocations within blocks are aligned to this value,
 so their offsets are always multiply of <code>nonCoherentAtomSize</code> and two different allocations never share same "line" of this size.</p>
 
 <p>Please note that memory allocated with <a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> is guaranteed to be <code>HOST_COHERENT</code>.</p>
 
 <p>Also, Windows drivers from all 3 PC GPU vendors (AMD, Intel, NVIDIA) currently provide <code>HOST_COHERENT</code> flag on all memory types that are 
 <code>HOST_VISIBLE</code>, so on PC you may not need to bother.</p>
 
 <h4>Finding out if memory is mappable</h4>
 
 <p>It may happen that your allocation ends up in memory that is <code>HOST_VISIBLE</code> (available for mapping) despite it wasn't explicitly requested. For
 example, application may work on integrated graphics with unified memory (like Intel) or allocation from video memory might have failed, so the library
 chose system memory as fallback.</p>
 
 <p>You can detect this case and map such allocation to access its memory on CPU directly, instead of launching a transfer operation. In order to do that:
 call <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a> and look for <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> flag.</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = sizeof(ConstantBuffer);
 bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 allocCreateInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, nullptr);
 
 VkMemoryPropertyFlags memFlags;
 vmaGetAllocationMemoryProperties(allocator, alloc, &amp;memFlags);
 if((memFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0)
 {
     // Allocation ended up in mappable memory. You can map it and access it directly.
     void* mappedData;
     vmaMapMemory(allocator, alloc, &amp;mappedData);
     memcpy(mappedData, &amp;constantBufferData, sizeof(constantBufferData));
     vmaUnmapMemory(allocator, alloc);
 }
 else
 {
     // Allocation ended up in non-mappable memory.
     // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
 }</code></pre>
 
 <p>You can even use <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag while creating allocations that are not necessarily <code>HOST_VISIBLE</code> (e.g. using
 <a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a>). If the allocation ends up in memory type that is <code>HOST_VISIBL</code>E, it will be persistently mapped and you can use it
 directly. If not, the flag is just ignored. Example:</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = sizeof(ConstantBuffer);
 bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 if(allocInfo.pMappedData != nullptr)
 {
     // Allocation ended up in mappable memory.
     // It is persistently mapped. You can access it directly.
     memcpy(allocInfo.pMappedData, &amp;constantBufferData, sizeof(constantBufferData));
 }
 else
 {
     // Allocation ended up in non-mappable memory.
     // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
 }</code></pre>
 
 <h3>Staying within budget</h3>
 
 <p>When developing a graphics-intensive game or program, it is important to avoid allocating more GPU memory than it is physically available. When the
 memory is over-committed, various bad things can happen, depending on the specific GPU, graphics driver, and operating system:</p>
 
 <ul>
 <li>It may just work without any problems.</li>
 <li>The application may slow down because some memory blocks are moved to system RAM and the GPU has to access them through PCI Express bus.</li>
 <li>A new allocation may take very long time to complete, even few seconds, and possibly freeze entire system.</li>
 <li>The new allocation may fail with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</li>
 <li>It may even result in GPU crash (TDR), observed as <code>VK_ERROR_DEVICE_LOST</code> returned somewhere later.</li>
 </ul>
 
 <h4>Querying for budget</h4>
 
 <p>To query for current memory usage and available budget, use function <a href="#vmaGetHeapBudgets(long,org.lwjgl.util.vma.VmaBudget.Buffer)"><code>GetHeapBudgets</code></a>. Returned structure <a href="VmaBudget.html" title="class in org.lwjgl.util.vma"><code>VmaBudget</code></a> contains quantities expressed in
 bytes, per Vulkan memory heap.</p>
 
 <p>Please note that this function returns different information and works faster than <a href="#vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)"><code>CalculateStatistics</code></a>. <code>vmaGetHeapBudgets()</code> can be called
 every frame or even before every allocation, while <code>vmaCalculateStatistics()</code> is intended to be used rarely, only to obtain statistical
 information, e.g. for debugging purposes.</p>
 
 <p>It is recommended to use <b>VK_EXT_memory_budget</b> device extension to obtain information about the budget from Vulkan device. VMA is able to use
 this extension automatically. When not enabled, the allocator behaves same way, but then it estimates current usage and available budget based on its
 internal information and Vulkan memory heap sizes, which may be less precise. In order to use this extension:</p>
 
 <ol>
 <li>Make sure extensions <code>VK_EXT_memory_budget</code> and <code>VK_KHR_get_physical_device_properties2</code> required by it are available and enable them.
 Please note that the first is a device extension and the second is instance extension!</li>
 <li>Use flag <a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> when creating <code>VmaAllocator</code> object.</li>
 <li>Make sure to call <a href="#vmaSetCurrentFrameIndex(long,int)"><code>SetCurrentFrameIndex</code></a> every frame. Budget is queried from Vulkan inside of it to avoid overhead of querying it with every
 allocation.</li>
 </ol>
 
 <h4>Controlling memory usage</h4>
 
 <p>There are many ways in which you can try to stay within the budget.</p>
 
 <p>First, when making new allocation requires allocating a new memory block, the library tries not to exceed the budget automatically. If a block with
 default recommended size (e.g. 256 MB) would go over budget, a smaller block is allocated, possibly even dedicated memory for just this resource.</p>
 
 <p>If the size of the requested resource plus current memory usage is more than the budget, by default the library still tries to create it, leaving it to
 the Vulkan implementation whether the allocation succeeds or fails. You can change this behavior by using <a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> flag.
 With it, the allocation is not made if it would exceed the budget or if the budget is already exceeded. VMA then tries to make the allocation from the
 next eligible Vulkan memory type. The all of them fail, the call then fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>. Example usage pattern may be to
 pass the <code>VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code> flag when creating resources that are not essential for the application (e.g. the texture of a
 specific object) and not to pass it when creating critically important resources (e.g. render targets).</p>
 
 <p>On AMD graphics cards there is a custom vendor extension available: <code>VK_AMD_memory_overallocation_behavior</code> that allows to control the behavior
 of the Vulkan implementation in out-of-memory cases - whether it should fail with an error code or still allow the allocation. Usage of this extension
 involves only passing extra structure on Vulkan device creation, so it is out of scope of this library.</p>
 
 <p>Finally, you can also use <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> flag to make sure a new allocation is created only when it fits inside one of the
 existing memory blocks. If it would require to allocate a new block, if fails instead with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>. This also ensures
 that the function call is very fast because it never goes to Vulkan to obtain a new block.</p>
 
 <p>Note: Creating custom memory pools with <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::minBlockCount</code> set to more than 0 will currently try to allocate memory blocks
 without checking whether they fit within budget.</p>
 
 <h3>Resource aliasing (overlap)</h3>
 
 <p>New explicit graphics APIs (Vulkan and Direct3D 12), thanks to manual memory management, give an opportunity to alias (overlap) multiple resources in
 the same region of memory - a feature not available in the old APIs (Direct3D 11, OpenGL). It can be useful to save video memory, but it must be used
 with caution.</p>
 
 <p>For example, if you know the flow of your whole render frame in advance, you are going to use some intermediate textures or buffers only during a small
 range of render passes, and you know these ranges don't overlap in time, you can bind these resources to the same place in memory, even if they have
 completely different parameters (width, height, format etc.).</p>
 
 <p>Such scenario is possible using VMA, but you need to create your images manually. Then you need to calculate parameters of an allocation to be made
 using formula:</p>
 
 <ul>
 <li>allocation size = max(size of each image)</li>
 <li>allocation alignment = max(alignment of each image)</li>
 <li>allocation memoryTypeBits = bitwise AND(memoryTypeBits of each image)</li>
 </ul>
 
 <p>Following example shows two different images bound to the same place in memory, allocated to fit largest of them.</p>
 
 <pre><code>
 // A 512x512 texture to be sampled.
 VkImageCreateInfo img1CreateInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
 img1CreateInfo.imageType = VK_IMAGE_TYPE_2D;
 img1CreateInfo.extent.width = 512;
 img1CreateInfo.extent.height = 512;
 img1CreateInfo.extent.depth = 1;
 img1CreateInfo.mipLevels = 10;
 img1CreateInfo.arrayLayers = 1;
 img1CreateInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
 img1CreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
 img1CreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
 img1CreateInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
 img1CreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
 
 // A full screen texture to be used as color attachment.
 VkImageCreateInfo img2CreateInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
 img2CreateInfo.imageType = VK_IMAGE_TYPE_2D;
 img2CreateInfo.extent.width = 1920;
 img2CreateInfo.extent.height = 1080;
 img2CreateInfo.extent.depth = 1;
 img2CreateInfo.mipLevels = 1;
 img2CreateInfo.arrayLayers = 1;
 img2CreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
 img2CreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
 img2CreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
 img2CreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
 img2CreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
 
 VkImage img1;
 res = vkCreateImage(device, &amp;img1CreateInfo, nullptr, &amp;img1);
 VkImage img2;
 res = vkCreateImage(device, &amp;img2CreateInfo, nullptr, &amp;img2);
 
 VkMemoryRequirements img1MemReq;
 vkGetImageMemoryRequirements(device, img1, &amp;img1MemReq);
 VkMemoryRequirements img2MemReq;
 vkGetImageMemoryRequirements(device, img2, &amp;img2MemReq);
 
 VkMemoryRequirements finalMemReq = {};
 finalMemReq.size = std::max(img1MemReq.size, img2MemReq.size);
 finalMemReq.alignment = std::max(img1MemReq.alignment, img2MemReq.alignment);
 finalMemReq.memoryTypeBits = img1MemReq.memoryTypeBits &amp; img2MemReq.memoryTypeBits;
 // Validate if(finalMemReq.memoryTypeBits != 0)
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.preferredFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
 
 VmaAllocation alloc;
 res = vmaAllocateMemory(allocator, &amp;finalMemReq, &amp;allocCreateInfo, &amp;alloc, nullptr);
 
 res = vmaBindImageMemory(allocator, alloc, img1);
 res = vmaBindImageMemory(allocator, alloc, img2);
 
 // You can use img1, img2 here, but not at the same time!
 
 vmaFreeMemory(allocator, alloc);
 vkDestroyImage(allocator, img2, nullptr);
 vkDestroyImage(allocator, img1, nullptr);</code></pre>
 
 <p>Remember that using resources that alias in memory requires proper synchronization. You need to issue a memory barrier to make sure commands that use
 <code>img1</code> and <code>img2</code> don't overlap on GPU timeline. You also need to treat a resource after aliasing as uninitialized - containing garbage
 data. For example, if you use <code>img1</code> and then want to use <code>img2</code>, you need to issue an image memory barrier for <code>img2</code> with
 <code>oldLayout = VK_IMAGE_LAYOUT_UNDEFINED</code>.</p>
 
 <p>Additional considerations:</p>
 
 <ul>
 <li>Vulkan also allows to interpret contents of memory between aliasing resources consistently in some cases. See chapter 11.8. "Memory Aliasing" of
 Vulkan specification or <code>VK_IMAGE_CREATE_ALIAS_BIT</code> flag.</li>
 <li>You can create more complex layout where different images and buffers are bound at different offsets inside one large allocation. For example, one
 can imagine a big texture used in some render passes, aliasing with a set of many small buffers used between in some further passes. To bind a
 resource at non-zero offset in an allocation, use <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> / <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</li>
 <li>Before allocating memory for the resources you want to alias, check <code>memoryTypeBits</code> returned in memory requirements of each resource to make
 sure the bits overlap. Some GPUs may expose multiple memory types suitable e.g. only for buffers or images with <code>COLOR_ATTACHMENT</code> usage, so
 the sets of memory types supported by your resources may be disjoint. Aliasing them is not possible in that case.</li>
 </ul>
 
 <h3>Custom memory pools</h3>
 
 <p>A memory pool contains a number of <code>VkDeviceMemory</code> blocks. The library automatically creates and manages default pool for each memory type
 available on the device. Default memory pool automatically grows in size. Size of allocated blocks is also variable and managed automatically.</p>
 
 <p>You can create custom pool and allocate memory out of it. It can be useful if you want to:</p>
 
 <ul>
 <li>Keep certain kind of allocations separate from others.</li>
 <li>Enforce particular, fixed size of Vulkan memory blocks.</li>
 <li>Limit maximum amount of Vulkan memory allocated for that pool.</li>
 <li>Reserve minimum or fixed amount of Vulkan memory always preallocated for that pool.</li>
 <li>Use extra parameters for a set of your allocations that are available in <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a> but not in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> - e.g., custom
 minimum alignment, custom <code>pNext</code> chain.</li>
 <li>Perform defragmentation on a specific subset of your allocations.</li>
 </ul>
 
 <p>To use custom memory pools:</p>
 
 <ol>
 <li>Fill <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a> structure.</li>
 <li>Call <a href="#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)"><code>CreatePool</code></a> to obtain <code>VmaPool</code> handle.</li>
 <li>When making an allocation, set <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pool</code> to this handle. You don't need to specify any other parameters of this
 structure, like <code>usage</code>.</li>
 </ol>
 
 <p>Example:</p>
 
 <pre><code>
 // Find memoryTypeIndex for the pool.
 VkBufferCreateInfo sampleBufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 sampleBufCreateInfo.size = 0x10000; // Doesn't matter.
 sampleBufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo sampleAllocCreateInfo = {};
 sampleAllocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 
 uint32_t memTypeIndex;
 VkResult res = vmaFindMemoryTypeIndexForBufferInfo(allocator,
     &amp;sampleBufCreateInfo, &amp;sampleAllocCreateInfo, &amp;memTypeIndex);
 // Check res...
 
 // Create a pool that can have at most 2 blocks, 128 MiB each.
 VmaPoolCreateInfo poolCreateInfo = {};
 poolCreateInfo.memoryTypeIndex = memTypeIndex
 poolCreateInfo.blockSize = 128ull * 1024 * 1024;
 poolCreateInfo.maxBlockCount = 2;
 
 VmaPool pool;
 res = vmaCreatePool(allocator, &amp;poolCreateInfo, &amp;pool);
 // Check res...
 
 // Allocate a buffer out of it.
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = 1024;
 bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.pool = pool;
 
 VkBuffer buf;
 VmaAllocation alloc;
 res = vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, nullptr);
 // Check res...</code></pre>
 
 <p>You have to free all allocations made from this pool before destroying it.</p>
 
 <pre><code>
 vmaDestroyBuffer(allocator, buf, alloc);
 vmaDestroyPool(allocator, pool);</code></pre>
 
 <p>New versions of this library support creating dedicated allocations in custom pools. It is supported only when <code>VmaPoolCreateInfo::blockSize = 0</code>.
 To use this feature, set <code>VmaAllocationCreateInfo::pool</code> to the pointer to your custom pool and <code>VmaAllocationCreateInfo::flags</code> to
 <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Excessive use of custom pools is a common mistake when using this library. Custom pools may be useful for special purposes - when you want to keep
 certain type of resources separate e.g. to reserve minimum amount of memory for them or limit maximum amount of memory they can occupy. For most
 resources this is not needed and so it is not recommended to create <code>VmaPool</code> objects and allocations out of them. Allocating from the default
 pool is sufficient.</p>
 </div>
 
 <h4>Choosing memory type index</h4>
 
 <p>When creating a pool, you must explicitly specify memory type index. To find the one suitable for your buffers or images, you can use helper functions
 <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a>. You need to provide structures with example parameters of buffers or images
 that you are going to create in that pool.</p>
 
 <pre><code>
 VkBufferCreateInfo exampleBufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 exampleBufCreateInfo.size = 1024; // Doesn't matter
 exampleBufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 
 uint32_t memTypeIndex;
 vmaFindMemoryTypeIndexForBufferInfo(allocator, &amp;exampleBufCreateInfo, &amp;allocCreateInfo, &amp;memTypeIndex);
 
 VmaPoolCreateInfo poolCreateInfo = {};
 poolCreateInfo.memoryTypeIndex = memTypeIndex;
 // ...</code></pre>
 
 <p>When creating buffers/images allocated in that pool, provide following parameters:</p>
 
 <ul>
 <li><code>VkBufferCreateInfo</code>: Prefer to pass same parameters as above. Otherwise you risk creating resources in a memory type that is not suitable
 for them, which may result in undefined behavior. Using different <code>VK_BUFFER_USAGE_</code> flags may work, but you shouldn't create images in a
 pool intended for buffers or the other way around.</li>
 <li><a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>: You don't need to pass same parameters. Fill only <code>pool</code> member. Other members are ignored anyway.</li>
 </ul>
 
 <h4>Linear allocation algorithm</h4>
 
 <p>Each Vulkan memory block managed by this library has accompanying metadata that keeps track of used and unused regions. By default, the metadata
 structure and algorithm tries to find best place for new allocations among free regions to optimize memory usage. This way you can allocate and free
 objects in any order.</p>
 
 <p>Sometimes there is a need to use simpler, linear allocation algorithm. You can create custom pool that uses such algorithm by adding flag
 <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> to <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code> while creating <code>VmaPool</code> object. Then an alternative metadata management
 is used. It always creates new allocations after last one and doesn't reuse free regions after allocations freed in the middle. It results in better
 allocation performance and less memory consumed by metadata.</p>
 
 <p>With this one flag, you can create a custom pool that can be used in many ways: free-at-once, stack, double stack, and ring buffer. See below for
 details.</p>
 
 <h5>Free-at-once</h5>
 
 <p>In a pool that uses linear algorithm, you still need to free all the allocations individually, e.g. by using <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> or <a href="#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>. You can
 free them in any order. New allocations are always made after last one - free space in the middle is not reused. However, when you release all the
 allocation and the pool becomes empty, allocation starts from the beginning again. This way you can use linear algorithm to speed up creation of
 allocations that you are going to release all at once.</p>
 
 <p>This mode is also available for pools created with <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> value that allows multiple memory blocks.</p>
 
 <h5>Stack</h5>
 
 <p>When you free an allocation that was created last, its space can be reused. Thanks to this, if you always release allocations in the order opposite to
 their creation (LIFO - Last In First Out), you can achieve behavior of a stack.</p>
 
 <p>This mode is also available for pools created with <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> value that allows multiple memory blocks.</p>
 
 <h5>Double stack</h5>
 
 <p>The space reserved by a custom pool with linear algorithm may be used by two stacks:</p>
 
 <ul>
 <li>First, default one, growing up from offset 0.</li>
 <li>Second, "upper" one, growing down from the end towards lower offsets.</li>
 </ul>
 
 <p>To make allocation from upper stack, add flag <a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> to <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>Double stack is available only in pools with one memory block - <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> must be 1. Otherwise behavior is undefined.</p>
 
 <p>When the two stacks' ends meet so there is not enough space between them for a new allocation, such allocation fails with usual
 <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <h5>Ring buffer</h5>
 
 <p>When you free some allocations from the beginning and there is not enough free space for a new one at the end of a pool, allocator's "cursor" wraps
 around to the beginning and starts allocation there. Thanks to this, if you always release allocations in the same order as you created them (FIFO -
 First In First Out), you can achieve behavior of a ring buffer / queue.</p>
 
 <p>Ring buffer is available only in pools with one memory block - <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::maxBlockCount</code> must be 1. Otherwise behavior is undefined.</p>
 
 <p>Note: defragmentation is not supported in custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a>.</p>
 
 <h3>Defragmentation</h3>
 
 <p>Interleaved allocations and deallocations of many objects of varying size cause fragmentation over time, which can lead to a situation where the
 library is unable to find a continuous range of free memory for a new allocation despite there is enough free space, just scattered across many small
 free ranges between existing allocations.</p>
 
 <p>To mitigate this problem, you can use defragmentation feature. It doesn't happen automatically though and needs your cooperation, because VMA is a low
 level library that only allocates memory. It cannot recreate buffers and images in a new place as it doesn't remember the contents of
 <code>VkBufferCreateInfo</code> / <code>VkImageCreateInfo</code> structures. It cannot copy their contents as it doesn't record any commands to a command buffer.</p>
 
 <p>Example:</p>
 
 <pre><code>
 VmaDefragmentationInfo defragInfo = {};
 defragInfo.pool = myPool;
 defragInfo.flags = VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT;
 
 VmaDefragmentationContext defragCtx;
 VkResult res = vmaBeginDefragmentation(allocator, &amp;defragInfo, &amp;defragCtx);
 // Check res...
 
 for(;;)
 {
     VmaDefragmentationPassMoveInfo pass;
     res = vmaBeginDefragmentationPass(allocator, defragCtx, &amp;pass);
     if(res == VK_SUCCESS)
         break;
     else if(res != VK_INCOMPLETE)
         // Handle error...
 
     for(uint32_t i = 0; i &lt; pass.moveCount; ++i)
     {
         // Inspect pass.pMoves[i].srcAllocation, identify what buffer/image it represents.
         VmaAllocationInfo allocInfo;
         vmaGetAllocationInfo(allocator, pMoves[i].srcAllocation, &amp;allocInfo);
         MyEngineResourceData* resData = (MyEngineResourceData*)allocInfo.pUserData;
 
         // Recreate and bind this buffer/image at: pass.pMoves[i].dstMemory, pass.pMoves[i].dstOffset.
         VkImageCreateInfo imgCreateInfo = ...
         VkImage newImg;
         res = vkCreateImage(device, &amp;imgCreateInfo, nullptr, &amp;newImg);
         // Check res...
         res = vmaBindImageMemory(allocator, pMoves[i].dstTmpAllocation, newImg);
         // Check res...
 
         // Issue a vkCmdCopyBuffer/vkCmdCopyImage to copy its content to the new place.
         vkCmdCopyImage(cmdBuf, resData-&gt;img, ..., newImg, ...);
     }
 
     // Make sure the copy commands finished executing.
     vkWaitForFences(...);
 
     // Destroy old buffers/images bound with pass.pMoves[i].srcAllocation.
     for(uint32_t i = 0; i &lt; pass.moveCount; ++i)
     {
         // ...
         vkDestroyImage(device, resData-&gt;img, nullptr);
     }
 
     // Update appropriate descriptors to point to the new places...
 
     res = vmaEndDefragmentationPass(allocator, defragCtx, &amp;pass);
     if(res == VK_SUCCESS)
         break;
     else if(res != VK_INCOMPLETE)
         // Handle error...
 }
 
 vmaEndDefragmentation(allocator, defragCtx, nullptr);</code></pre>
 
 <p>Although functions like <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>, <a href="#vmaDestroyImage(long,long,long)"><code>DestroyImage</code></a> create/destroy an allocation and a buffer/image at once,
 these are just a shortcut for creating the resource, allocating memory, and binding them together. Defragmentation works on memory allocations only.
 You must handle the rest manually. Defragmentation is an iterative process that should repreat "passes" as long as related functions return
 <code>VK_INCOMPLETE</code> not <code>VK_SUCCESS</code>. In each pass:</p>
 
 <ol>
 <li><a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>BeginDefragmentationPass</code></a> function call:
 
 <ul>
 <li>Calculates and returns the list of allocations to be moved in this pass. Note this can be a time-consuming process.</li>
 <li>Reserves destination memory for them by creating temporary destination allocations that you can query for their <code>VkDeviceMemory</code> +
 <code>offset</code> using <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</li>
 </ul></li>
 <li>Inside the pass, <b>you should</b>:
 
 <ul>
 <li>Inspect the returned list of allocations to be moved.</li>
 <li>Create new buffers/images and bind them at the returned destination temporary allocations.</li>
 <li>Copy data from source to destination resources if necessary.</li>
 <li>Destroy the source buffers/images, but NOT their allocations.</li>
 </ul></li>
 <li><a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>EndDefragmentationPass</code></a> function call:
 
 <ul>
 <li>Frees the source memory reserved for the allocations that are moved.</li>
 <li>Modifies source <code>VmaAllocation</code> objects that are moved to point to the destination reserved memory.</li>
 <li>Frees <code>VkDeviceMemory</code> blocks that became empty.</li>
 </ul></li>
 </ol>
 
 <p>Unlike in previous iterations of the defragmentation API, there is no list of "movable" allocations passed as a parameter. Defragmentation algorithm
 tries to move all suitable allocations. You can, however, refuse to move some of them inside a defragmentation pass, by setting
 <code>pass.pMoves[i].operation</code> to <a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE"><code>DEFRAGMENTATION_MOVE_OPERATION_IGNORE</code></a>. This is not recommended and may result in suboptimal packing of the
 allocations after defragmentation. If you cannot ensure any allocation can be moved, it is better to keep movable allocations separate in a custom
 pool.</p>
 
 <p>Inside a pass, for each allocation that should be moved:</p>
 
 <ul>
 <li>You should copy its data from the source to the destination place by calling e.g. <code>vkCmdCopyBuffer()</code>, <code>vkCmdCopyImage()</code>.
 
 <p>You need to make sure these commands finished executing before destroying the source buffers/images and before calling <a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>EndDefragmentationPass</code></a>.</p></li>
 <li>If a resource doesn't contain any meaningful data, e.g. it is a transient color attachment image to be cleared, filled, and used temporarily in
 each rendering frame, you can just recreate this image without copying its data.</li>
 <li>If the resource is in <code>HOST_VISIBLE</code> and <code>HOST_CACHED</code> memory, you can copy its data on the CPU using <code>memcpy()</code>.</li>
 <li>If you cannot move the allocation, you can set <code>pass.pMoves[i].operation</code> to <a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE"><code>DEFRAGMENTATION_MOVE_OPERATION_IGNORE</code></a>. This will cancel the
 move.
 
 <p><a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>EndDefragmentationPass</code></a> will then free the destination memory not the source memory of the allocation, leaving it unchanged.</p></li>
 <li>If you decide the allocation is unimportant and can be destroyed instead of moved (e.g. it wasn't used for long time), you can set
 <code>pass.pMoves[i].operation</code> to <a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY"><code>DEFRAGMENTATION_MOVE_OPERATION_DESTROY</code></a>.
 
 <p><a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>EndDefragmentationPass</code></a> will then free both source and destination memory, and will destroy the source <code>VmaAllocation</code> object.</p></li>
 </ul>
 
 <p>You can defragment a specific custom pool by setting <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::pool</code> (like in the example above) or all the default pools by
 setting this member to null.</p>
 
 <p>Defragmentation is always performed in each pool separately. Allocations are never moved between different Vulkan memory types. The size of the
 destination memory reserved for a moved allocation is the same as the original one. Alignment of an allocation as it was determined using
 <code>vkGetBufferMemoryRequirements()</code> etc. is also respected after defragmentation. Buffers/images should be recreated with the same
 <code>VkBufferCreateInfo</code> / <code>VkImageCreateInfo</code> parameters as the original ones.</p>
 
 <p>You can perform the defragmentation incrementally to limit the number of allocations and bytes to be moved in each pass, e.g. to call it in sync with
 render frames and not to experience too big hitches. See members: <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::maxBytesPerPass</code>,
 <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::maxAllocationsPerPass</code>.</p>
 
 <p>It is also safe to perform the defragmentation asynchronously to render frames and other Vulkan and VMA usage, possibly from multiple threads, with the
 exception that allocations returned in <a href="VmaDefragmentationPassMoveInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationPassMoveInfo</code></a><code>::pMoves</code> shouldn't be destroyed until the defragmentation pass is ended.</p>
 
 <p><b>Mapping</b> is preserved on allocations that are moved during defragmentation. Whether through <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> or <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a>, the
 allocations are mapped at their new place. Of course, pointer to the mapped data changes, so it needs to be queried using
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>Note: Defragmentation is not supported in custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a>.</p>
 
 <h3>Statistics</h3>
 
 <p>This library contains several functions that return information about its internal state, especially the amount of memory allocated from Vulkan.</p>
 
 <h4>Numeric statistics</h4>
 
 <p>If you need to obtain basic statistics about memory usage per heap, together with current budget, you can call function <a href="#vmaGetHeapBudgets(long,org.lwjgl.util.vma.VmaBudget.Buffer)"><code>GetHeapBudgets</code></a> and inspect
 structure <a href="VmaBudget.html" title="class in org.lwjgl.util.vma"><code>VmaBudget</code></a>. This is useful to keep track of memory usage and stay within budget. Example:</p>
 
 <pre><code>
 uint32_t heapIndex = ...
 
 VmaBudget budgets[VK_MAX_MEMORY_HEAPS];
 vmaGetHeapBudgets(allocator, budgets);
 
 printf("My heap currently has %u allocations taking %llu B,\n",
     budgets[heapIndex].statistics.allocationCount,
     budgets[heapIndex].statistics.allocationBytes);
 printf("allocated out of %u Vulkan device memory blocks taking %llu B,\n",
     budgets[heapIndex].statistics.blockCount,
     budgets[heapIndex].statistics.blockBytes);
 printf("Vulkan reports total usage %llu B with budget %llu B.\n",
     budgets[heapIndex].usage,
     budgets[heapIndex].budget);</code></pre>
 
 <p>You can query for more detailed statistics per memory heap, type, and totals, including minimum and maximum allocation size and unused range size, by
 calling function <a href="#vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)"><code>CalculateStatistics</code></a> and inspecting structure <a href="VmaTotalStatistics.html" title="class in org.lwjgl.util.vma"><code>VmaTotalStatistics</code></a>. This function is slower though, as it has to traverse all the
 internal data structures, so it should be used only for debugging purposes.</p>
 
 <p>You can query for statistics of a custom pool using function <a href="#vmaGetPoolStatistics(long,long,org.lwjgl.util.vma.VmaStatistics)"><code>GetPoolStatistics</code></a> or <a href="#vmaCalculatePoolStatistics(long,long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculatePoolStatistics</code></a>.</p>
 
 <p>You can query for information about a specific allocation using function <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>. It fills structure <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a>.</p>
 
 <h3>JSON dump</h3>
 
 <p>You can dump internal state of the allocator to a string in JSON format using function <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>. The result is guaranteed to be correct
 JSON. It uses ANSI encoding. Any strings provided by user are copied as-is and properly escaped for JSON, so if they use UTF-8, ISO-8859-2 or any other
 encoding, this JSON string can be treated as using this encoding. It must be freed using function <a href="#vmaFreeStatsString(long,java.nio.ByteBuffer)"><code>FreeStatsString</code></a>.</p>
 
 <p>The format of this JSON string is not part of official documentation of the library, but it will not change in backward-incompatible way without
 increasing library major version number and appropriate mention in changelog.</p>
 
 <p>The JSON string contains all the data that can be obtained using <a href="#vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)"><code>CalculateStatistics</code></a>. It can also contain detailed map of allocated memory blocks
 and their regions - free and occupied by allocations. This allows e.g. to visualize the memory or assess fragmentation.</p>
 
 <h3>Allocation names and user data</h3>
 
 <h4>Allocation user data</h4>
 
 <p>You can annotate allocations with your own information, e.g. for debugging purposes. To do that, fill <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code>
 field when creating an allocation. It is an opaque <code>void*</code> pointer. You can use it e.g. as a pointer, some handle, index, key, ordinal number or
 any other value that would associate the allocation with your custom metadata. It is useful to identify appropriate data structures in your engine
 given <code>VmaAllocation</code>, e.g. when doing defragmentation.</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = ...
 
 MyBufferMetadata* pMetadata = CreateBufferMetadata();
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 allocCreateInfo.pUserData = pMetadata;
 
 VkBuffer buffer;
 VmaAllocation allocation;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buffer, &amp;allocation, nullptr);</code></pre>
 
 <p>The pointer may be later retrieved as <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pUserData</code>:</p>
 
 <pre><code>
 VmaAllocationInfo allocInfo;
 vmaGetAllocationInfo(allocator, allocation, &amp;allocInfo);
 MyBufferMetadata* pMetadata = (MyBufferMetadata*)allocInfo.pUserData;</code></pre>
 
 <p>It can also be changed using function <a href="#vmaSetAllocationUserData(long,long,long)"><code>SetAllocationUserData</code></a>.</p>
 
 <p>Values of (non-zero) allocations' <code>pUserData</code> are printed in JSON report created by <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a> in hexadecimal form.</p>
 
 <h4>Allocation names</h4>
 
 <p>An allocation can also carry a null-terminated string, giving a name to the allocation. To set it, call <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a>. The library creates
 internal copy of the string, so the pointer you pass doesn't need to be valid for whole lifetime of the allocation. You can free it after the call.</p>
 
 <pre><code>
 std::string imageName = "Texture: ";
 imageName += fileName;
 vmaSetAllocationName(allocator, allocation, imageName.c_str());</code></pre>
 
 <p>The string can be later retrieved by inspecting <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pName</code>. It is also printed in JSON report created by <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 
 <p>Note: Setting string name to VMA allocation doesn't automatically set it to the Vulkan buffer or image created with it. You must do it manually using
 an extension like <code>VK_EXT_debug_utils</code>, which is independent of this library.</p>
 
 <h3>Virtual allocator</h3>
 
 <p>As an extra feature, the core allocation algorithm of the library is exposed through a simple and convenient API of "virtual allocator". It doesn't
 allocate any real GPU memory. It just keeps track of used and free regions of a "virtual block". You can use it to allocate your own memory or other
 objects, even completely unrelated to Vulkan. A common use case is sub-allocation of pieces of one large GPU buffer.</p>
 
 <h4>Creating virtual block</h4>
 
 <p>To use this functionality, there is no main "allocator" object. You don't need to have <code>VmaAllocator</code> object created. All you need to do is to
 create a separate <code>VmaVirtualBlock</code> object for each block of memory you want to be managed by the allocator:</p>
 
 <ul>
 <li>Fill in <a href="VmaVirtualBlockCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualBlockCreateInfo</code></a> structure.</li>
 <li>Call <a href="#vmaCreateVirtualBlock(org.lwjgl.util.vma.VmaVirtualBlockCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateVirtualBlock</code></a>. Get new <code>VmaVirtualBlock</code> object.</li>
 </ul>
 
 <p>Example:</p>
 
 <pre><code>
 VmaVirtualBlockCreateInfo blockCreateInfo = {};
 blockCreateInfo.size = 1048576; // 1 MB
 
 VmaVirtualBlock block;
 VkResult res = vmaCreateVirtualBlock(&amp;blockCreateInfo, &amp;block);</code></pre>
 
 <h4>Making virtual allocations</h4>
 
 <p><code>VmaVirtualBlock</code> object contains internal data structure that keeps track of free and occupied regions using the same code as the main Vulkan
 memory allocator. Similarly to <code>VmaAllocation</code> for standard GPU allocations, there is <code>VmaVirtualAllocation</code> type that represents an opaque
 handle to an allocation within the virtual block.</p>
 
 <p>In order to make such allocation:</p>
 
 <ul>
 <li>Fill in <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a> structure.</li>
 <li>Call <a href="#vmaVirtualAllocate(long,org.lwjgl.util.vma.VmaVirtualAllocationCreateInfo,org.lwjgl.PointerBuffer,java.nio.LongBuffer)"><code>VirtualAllocate</code></a>. Get new <code>VmaVirtualAllocation</code> object that represents the allocation. You can also receive
 <code>VkDeviceSize offset</code> that was assigned to the allocation.</li>
 </ul>
 
 <p>Example:</p>
 
 <pre><code>
 VmaVirtualAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.size = 4096; // 4 KB
 
 VmaVirtualAllocation alloc;
 VkDeviceSize offset;
 res = vmaVirtualAllocate(block, &amp;allocCreateInfo, &amp;alloc, &amp;offset);
 if(res == VK_SUCCESS)
 {
     // Use the 4 KB of your memory starting at offset.
 }
 else
 {
     // Allocation failed - no space for it could be found. Handle this error!
 }</code></pre>
 
 <h4>Deallocation</h4>
 
 <p>When no longer needed, an allocation can be freed by calling <a href="#vmaVirtualFree(long,long)"><code>VirtualFree</code></a>. You can only pass to this function an allocation that was previously
 returned by <code>vmaVirtualAllocate()</code> called for the same <code>VmaVirtualBlock</code>.</p>
 
 <p>When whole block is no longer needed, the block object can be released by calling <a href="#vmaDestroyVirtualBlock(long)"><code>DestroyVirtualBlock</code></a>. All allocations must be freed before the
 block is destroyed, which is checked internally by an assert. However, if you don't want to call <code>vmaVirtualFree()</code> for each allocation, you can
 use <a href="#vmaClearVirtualBlock(long)"><code>ClearVirtualBlock</code></a> to free them all at once - a feature not available in normal Vulkan memory allocator. Example:</p>
 
 <pre><code>
 vmaVirtualFree(block, alloc);
 vmaDestroyVirtualBlock(block);</code></pre>
 
 <h4>Allocation parameters</h4>
 
 <p>You can attach a custom pointer to each allocation by using <a href="#vmaSetVirtualAllocationUserData(long,long,long)"><code>SetVirtualAllocationUserData</code></a>. Its default value is null. It can be used to store any
 data that needs to be associated with that allocation - e.g. an index, a handle, or a pointer to some larger data structure containing more
 information. Example:</p>
 
 <pre><code>
 struct CustomAllocData
 {
     std::string m_AllocName;
 };
 CustomAllocData* allocData = new CustomAllocData();
 allocData-&gt;m_AllocName = "My allocation 1";
 vmaSetVirtualAllocationUserData(block, alloc, allocData);</code></pre>
 
 <p>The pointer can later be fetched, along with allocation offset and size, by passing the allocation handle to function <a href="#vmaGetVirtualAllocationInfo(long,long,org.lwjgl.util.vma.VmaVirtualAllocationInfo)"><code>GetVirtualAllocationInfo</code></a> and
 inspecting returned structure <code>VmaVirtualAllocationInfo</code>. If you allocated a new object to be used as the custom pointer, don't forget to delete
 that object before freeing the allocation! Example:</p>
 
 <pre><code>
 VmaVirtualAllocationInfo allocInfo;
 vmaGetVirtualAllocationInfo(block, alloc, &amp;allocInfo);
 delete (CustomAllocData*)allocInfo.pUserData;
 
 vmaVirtualFree(block, alloc);</code></pre>
 
 <h4>Alignment and units</h4>
 
 <p>It feels natural to express sizes and offsets in bytes. If an offset of an allocation needs to be aligned to a multiply of some number (e.g. 4 bytes),
 you can fill optional member <code>VmaVirtualAllocationCreateInfo::alignment</code> to request it. Example:</p>
 
 <pre><code>
 VmaVirtualAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.size = 4096; // 4 KB
 allocCreateInfo.alignment = 4; // Returned offset must be a multiply of 4 B
 
 VmaVirtualAllocation alloc;
 res = vmaVirtualAllocate(block, &amp;allocCreateInfo, &amp;alloc, nullptr);</code></pre>
 
 <p>Alignments of different allocations made from one block may vary. However, if all alignments and sizes are always multiply of some size e.g. 4 B or
 <code>sizeof(MyDataStruct)</code>, you can express all sizes, alignments, and offsets in multiples of that size instead of individual bytes. It might be
 more convenient, but you need to make sure to use this new unit consistently in all the places:</p>
 
 <ul>
 <li><code>VmaVirtualBlockCreateInfo::size</code></li>
 <li><code>VmaVirtualAllocationCreateInfo::size</code> and <code>VmaVirtualAllocationCreateInfo::alignment</code></li>
 <li>Using offset returned by <code>vmaVirtualAllocate()</code> or in <code>VmaVirtualAllocationInfo::offset</code></li>
 </ul>
 
 <h4>Statistics</h4>
 
 <p>You can obtain statistics of a virtual block using <a href="#vmaGetVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaStatistics)"><code>GetVirtualBlockStatistics</code></a> (to get brief statistics that are fast to calculate) or 
 <a href="#vmaCalculateVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculateVirtualBlockStatistics</code></a> (to get more detailed statistics, slower to calculate). The functions fill structures <a href="VmaStatistics.html" title="class in org.lwjgl.util.vma"><code>VmaStatistics</code></a>,
 <a href="VmaDetailedStatistics.html" title="class in org.lwjgl.util.vma"><code>VmaDetailedStatistics</code></a> respectively - same as used by the normal Vulkan memory allocator. Example:</p>
 
 <pre><code>
 VmaStatistics stats;
 vmaGetVirtualBlockStatistics(block, &amp;stats);
 printf("My virtual block has %llu bytes used by %u virtual allocations\n",
     stats.allocationBytes, stats.allocationCount);</code></pre>
 
 <p>You can also request a full list of allocations and free regions as a string in JSON format by calling <a href="#vmaBuildVirtualBlockStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildVirtualBlockStatsString</code></a>. Returned string
 must be later freed using <a href="#vmaFreeVirtualBlockStatsString(long,java.nio.ByteBuffer)"><code>FreeVirtualBlockStatsString</code></a>. The format of this string differs from the one returned by the main Vulkan allocator, but it
 is similar.</p>
 
 <h4>Additional considerations</h4>
 
 <p>The "virtual allocator" functionality is implemented on a level of individual memory blocks. Keeping track of a whole collection of blocks, allocating
 new ones when out of free space, deleting empty ones, and deciding which one to try first for a new allocation must be implemented by the user.</p>
 
 <p>Alternative allocation algorithms are supported, just like in custom pools of the real GPU memory. See enum <code>VmaVirtualBlockCreateFlagBits</code> to
 learn how to specify them (e.g. <a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a>). Allocation strategies are also supported. See enum
 <code>VmaVirtualAllocationCreateFlagBits</code> to learn how to specify them (e.g. <a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>).</p>
 
 <p>Following features are supported only by the allocator of the real GPU memory and not by virtual allocations: buffer-image granularity,
 <code>VMA_DEBUG_MARGIN</code>, <code>VMA_MIN_ALIGNMENT</code>.</p>
 
 <h3>Debugging incorrect memory usage</h3>
 
 <p>If you suspect a bug with memory usage, like usage of uninitialized memory or memory being overwritten out of bounds of an allocation, you can use
 debug features of this library to verify this.</p>
 
 <h4>Memory initialization</h4>
 
 <p>If you experience a bug with incorrect and nondeterministic data in your program and you suspect uninitialized memory to be used, you can enable
 automatic memory initialization to verify this. To do it, define macro <code>VMA_DEBUG_INITIALIZE_ALLOCATIONS</code> to 1.</p>
 
 <p>It makes memory of all allocations initialized to bit pattern <code>0xDCDCDCDC</code>. Before an allocation is destroyed, its memory is filled with bit
 pattern <code>0xEFEFEFEF</code>. Memory is automatically mapped and unmapped if necessary.</p>
 
 <p>If you find these values while debugging your program, good chances are that you incorrectly read Vulkan memory that is allocated but not initialized,
 or already freed, respectively.</p>
 
 <p>Memory initialization works only with memory types that are <code>HOST_VISIBLE</code> and with allocations that can be mapped.. It works also with dedicated
 allocations.</p>
 
 <h4>Margins</h4>
 
 <p>By default, allocations are laid out in memory blocks next to each other if possible (considering required alignment, <code>bufferImageGranularity</code>,
 and <code>nonCoherentAtomSize</code>).</p>
 
 <p>Define macro <code>VMA_DEBUG_MARGIN</code> to some non-zero value (e.g. 16) to enforce specified number of bytes as a margin after every allocation.</p>
 
 <p>If your bug goes away after enabling margins, it means it may be caused by memory being overwritten outside of allocation boundaries. It is not 100%
 certain though. Change in application behavior may also be caused by different order and distribution of allocations across memory blocks after margins
 are applied.</p>
 
 <p>The margin is applied also before first and after last allocation in a block. It may occur only once between two adjacent allocations.</p>
 
 <p>Margins work with all types of memory.</p>
 
 <p>Margin is applied only to allocations made out of memory blocks and not to dedicated allocations, which have their own memory block of specific size.
 It is thus not applied to allocations made using <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag or those automatically decided to put into dedicated
 allocations, e.g. due to its large size or recommended by <code>VK_KHR_dedicated_allocation</code> extension.</p>
 
 <p>Margins appear in JSON dump as part of free space.</p>
 
 <p>Note that enabling margins increases memory usage and fragmentation.</p>
 
 <p>Margins do not apply to virtual allocator.</p>
 
 <h4>Corruption detection</h4>
 
 <p>You can additionally define macro <code>VMA_DEBUG_DETECT_CORRUPTION</code> to 1 to enable validation of contents of the margins.</p>
 
 <p>When this feature is enabled, number of bytes specified as <code>VMA_DEBUG_MARGIN</code> (it must be multiple of 4) after every allocation is
 filled with a magic number. This idea is also know as "canary". Memory is automatically mapped and unmapped if necessary.</p>
 
 <p>This number is validated automatically when the allocation is destroyed. If it is not equal to the expected value, <code>VMA_ASSERT()</code> is executed. It
 clearly means that either CPU or GPU overwritten the memory outside of boundaries of the allocation, which indicates a serious bug.</p>
 
 <p>You can also explicitly request checking margins of all allocations in all memory blocks that belong to specified memory types by using function
 <a href="#vmaCheckCorruption(long,int)"><code>CheckCorruption</code></a>, or in memory blocks that belong to specified custom pool, by using function <a href="#vmaCheckPoolCorruption(long,long)"><code>CheckPoolCorruption</code></a>.</p>
 
 <p>Margin validation (corruption detection) works only for memory types that are <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>.</p>
 
 <h3>OpenGL Interop</h3>
 
 <p>VMA provides some features that help with interoperability with OpenGL.</p>
 
 <h4>Exporting memory</h4>
 
 <p>If you want to attach <code>VkExportMemoryAllocateInfoKHR</code> structure to <code>pNext</code> chain of memory allocations made by the library:</p>
 
 <p>It is recommended to create custom memory pools for such allocations. Define and fill in your <code>VkExportMemoryAllocateInfoKHR</code> structure and
 attach it to <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::pMemoryAllocateNext</code> while creating the custom pool. Please note that the structure must remain alive and
 unchanged for the whole lifetime of the <code>VmaPool</code>, not only while creating it, as no copy of the structure is made, but its original pointer is
 used for each allocation instead.</p>
 
 <p>If you want to export all memory allocated by the library from certain memory types, also dedicated allocations or other allocations made from default
 pools, an alternative solution is to fill in <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pTypeExternalMemoryHandleTypes</code>. It should point to an array with
 <code>VkExternalMemoryHandleTypeFlagsKHR</code> to be automatically passed by the library through <code>VkExportMemoryAllocateInfoKHR</code> on each allocation
 made from a specific memory type. Please note that new versions of the library also support dedicated allocations created in custom pools.</p>
 
 <p>You should not mix these two methods in a way that allows to apply both to the same memory type. Otherwise, <code>VkExportMemoryAllocateInfoKHR</code>
 structure would be attached twice to the <code>pNext</code> chain of <code>VkMemoryAllocateInfo</code>.</p>
 
 <h4>Custom alignment</h4>
 
 <p>Buffers or images exported to a different API like OpenGL may require a different alignment, higher than the one used by the library automatically,
 queried from functions like <code>vkGetBufferMemoryRequirements</code>. To impose such alignment:</p>
 
 <p>It is recommended to create custom memory pools for such allocations. Set <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::minAllocationAlignment</code> member to the minimum
 alignment required for each allocation to be made out of this pool. The alignment actually used will be the maximum of this member and the alignment
 returned for the specific buffer or image from a function like <code>vkGetBufferMemoryRequirements</code>, which is called by VMA automatically.</p>
 
 <p>If you want to create a buffer with a specific minimum alignment out of default pools, use special function <a href="#vmaCreateBufferWithAlignment(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,long,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBufferWithAlignment</code></a>, which takes
 additional parameter <code>minAlignment</code>.</p>
 
 <p>Note the problem of alignment affects only resources placed inside bigger <code>VkDeviceMemory</code> blocks and not dedicated allocations, as these, by
 definition, always have <code>alignment = 0</code> because the resource is bound to the beginning of its dedicated block. Contrary to Direct3D 12, Vulkan
 doesn't have a concept of alignment of the entire memory block passed on its allocation.</p>
 
 <h3>Recommended usage patterns</h3>
 
 <p>Vulkan gives great flexibility in memory allocation. This chapter shows the most common patterns.</p>
 
 <p>See also slides from talk: <a href="https://www.gdcvault.com/play/1025458/Advanced-Graphics-Techniques-Tutorial-New">Sawicki, Adam. Advanced Graphics
 Techniques Tutorial: Memory management in Vulkan and DX12. Game Developers Conference, 2018</a></p>
 
 <h4>GPU-only resource</h4>
 
 <p><b>When:</b> Any resources that you frequently write and read on GPU, e.g. images used as color attachments (aka "render targets"), depth-stencil
 attachments, images/buffers used as storage image/buffer (aka "Unordered Access View (UAV)").</p>
 
 <p><b>What to do:</b> Let the library select the optimal memory type, which will likely have <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 
 <pre><code>
 VkImageCreateInfo imgCreateInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
 imgCreateInfo.imageType = VK_IMAGE_TYPE_2D;
 imgCreateInfo.extent.width = 3840;
 imgCreateInfo.extent.height = 2160;
 imgCreateInfo.extent.depth = 1;
 imgCreateInfo.mipLevels = 1;
 imgCreateInfo.arrayLayers = 1;
 imgCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
 imgCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
 imgCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
 imgCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
 imgCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
 allocCreateInfo.priority = 1.0f;
 
 VkImage img;
 VmaAllocation alloc;
 vmaCreateImage(allocator, &amp;imgCreateInfo, &amp;allocCreateInfo, &amp;img, &amp;alloc, nullptr);</code></pre>
 
 <p><b>Also consider:</b> creating them as dedicated allocations using <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>, especially if they are large or if you plan
 to destroy and recreate them with different sizes e.g. when display resolution changes. Prefer to create such resources first and all other GPU
 resources (like textures and vertex buffers) later. When <code>VK_EXT_memory_priority</code> extension is enabled, it is also worth setting high priority to
 such allocation to decrease chances to be evicted to system memory by the operating system.</p>
 
 <h4>Staging copy for upload</h4>
 
 <p><b>When:</b> A "staging" buffer than you want to map and fill from CPU code, then use as a source of transfer to some GPU resource.</p>
 
 <p><b>What to do:</b> Use flag <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a>. Let the library select the optimal memory type, which will always have
 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>.</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = 65536;
 bufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
     VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 ...
 
 memcpy(allocInfo.pMappedData, myData, myDataSize);</code></pre>
 
 <p><b>Also consider:</b> You can map the allocation using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or you can create it as persistenly mapped using <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>, as
 in the example above.</p>
 
 <h4>Readback</h4>
 
 <p><b>When:</b> Buffers for data written by or transferred from the GPU that you want to read back on the CPU, e.g. results of some computations.</p>
 
 <p><b>What to do:</b> Use flag <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>. Let the library select the optimal memory type, which will always have
 <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = 65536;
 bufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT |
     VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 ...
 
 const float* downloadedData = (const float*)allocInfo.pMappedData;</code></pre>
 
 <h4>Advanced data uploading</h4>
 
 <p>For resources that you frequently write on CPU via mapped pointer and frequently read on GPU e.g. as a uniform buffer (also called "dynamic"), multiple
 options are possible:</p>
 
 <ul>
 <li>Easiest solution is to have one copy of the resource in <code>HOST_VISIBLE</code> memory, even if it means system RAM (not <code>DEVICE_LOCAL</code>) on
 systems with a discrete graphics card, and make the device reach out to that resource directly. Reads performed by the device will then go through
 PCI Express bus. The performance of this access may be limited, but it may be fine depending on the size of this resource (whether it is small
 enough to quickly end up in GPU cache) and the sparsity of access.</li>
 <li>On systems with unified memory (e.g. AMD APU or Intel integrated graphics, mobile chips), a memory type may be available that is both
 <code>HOST_VISIBLE</code> (available for mapping) and <code>DEVICE_LOCAL</code> (fast to access from the GPU). Then, it is likely the best choice for such
 type of resource.</li>
 <li>Systems with a discrete graphics card and separate video memory may or may not expose a memory type that is both <code>HOST_VISIBLE</code> and
 <code>DEVICE_LOCAL</code>, also known as Base Address Register (BAR). If they do, it represents a piece of VRAM (or entire VRAM, if ReBAR is enabled in
 the motherboard BIOS) that is available to CPU for mapping. Writes performed by the host to that memory go through PCI Express bus. The performance
 of these writes may be limited, but it may be fine, especially on PCIe 4.0, as long as rules of using uncached and write-combined memory are
 followed - only sequential writes and no reads.</li>
 <li>Finally, you may need or prefer to create a separate copy of the resource in <code>DEVICE_LOCAL</code> memory, a separate "staging" copy in
 <code>HOST_VISIBLE</code> memory and perform an explicit transfer command between them.</li>
 </ul>
 
 <p>Thankfully, VMA offers an aid to create and use such resources in the the way optimal for the current Vulkan device. To help the library make the best
 choice, use flag <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a>. It will
 then prefer a memory type that is both <code>DEVICE_LOCAL</code> and <code>HOST_VISIBLE</code> (integrated memory or BAR), but if no such memory type is
 available or allocation from it fails (PC graphics cards have only 256 MB of BAR by default, unless ReBAR is supported and enabled in BIOS), it will
 fall back to <code>DEVICE_LOCAL</code> memory for fast GPU access. It is then up to you to detect that the allocation ended up in a memory type that is not
 <code>HOST_VISIBLE</code>, so you need to create another "staging" allocation and perform explicit transfers.</p>
 
 <pre><code>
 VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
 bufCreateInfo.size = 65536;
 bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
     VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT |
     VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
 VkBuffer buf;
 VmaAllocation alloc;
 VmaAllocationInfo allocInfo;
 vmaCreateBuffer(allocator, &amp;bufCreateInfo, &amp;allocCreateInfo, &amp;buf, &amp;alloc, &amp;allocInfo);
 
 VkMemoryPropertyFlags memPropFlags;
 vmaGetAllocationMemoryProperties(allocator, alloc, &amp;memPropFlags);
 
 if(memPropFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)
 {
     // Allocation ended up in a mappable memory and is already mapped - write to it directly.
 
     // [Executed in runtime]:
     memcpy(allocInfo.pMappedData, myData, myDataSize);
 }
 else
 {
     // Allocation ended up in a non-mappable memory - need to transfer.
     VkBufferCreateInfo stagingBufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
     stagingBufCreateInfo.size = 65536;
     stagingBufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
 
     VmaAllocationCreateInfo stagingAllocCreateInfo = {};
     stagingAllocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
     stagingAllocCreateInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
         VMA_ALLOCATION_CREATE_MAPPED_BIT;
 
     VkBuffer stagingBuf;
     VmaAllocation stagingAlloc;
     VmaAllocationInfo stagingAllocInfo;
     vmaCreateBuffer(allocator, &amp;stagingBufCreateInfo, &amp;stagingAllocCreateInfo,
         &amp;stagingBuf, &amp;stagingAlloc, stagingAllocInfo);
 
     // [Executed in runtime]:
     memcpy(stagingAllocInfo.pMappedData, myData, myDataSize);
     //vkCmdPipelineBarrier: VK_ACCESS_HOST_WRITE_BIT --&gt; VK_ACCESS_TRANSFER_READ_BIT
     VkBufferCopy bufCopy = {
         0, // srcOffset
         0, // dstOffset,
         myDataSize); // size
     vkCmdCopyBuffer(cmdBuf, stagingBuf, buf, 1, &amp;bufCopy);
 }</code></pre>
 
 <h4>Other use cases</h4>
 
 <p>Here are some other, less obvious use cases and their recommended settings:</p>
 
 <ul>
 <li>An image that is used only as transfer source and destination, but it should stay on the device, as it is used to temporarily store a copy of some
 texture, e.g. from the current to the next frame, for temporal antialiasing or other temporal effects.
 
 <ul>
 <li>Use <code>VkImageCreateInfo::usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT</code></li>
 <li>Use <code>VmaAllocationCreateInfo::usage = VMA_MEMORY_USAGE_AUTO</code></li>
 </ul></li>
 <li>An image that is used only as transfer source and destination, but it should be placed in the system RAM despite it doesn't need to be mapped,
 because it serves as a "swap" copy to evict least recently used textures from VRAM.
 
 <ul>
 <li>Use <code>VkImageCreateInfo::usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT</code></li>
 <li>Use <code>VmaAllocationCreateInfo::usage = VMA_MEMORY_USAGE_AUTO_PREFER_HOST</code>, as VMA needs a hint here to differentiate from the previous
 case.</li>
 </ul></li>
 <li>A buffer that you want to map and write from the CPU, directly read from the GPU (e.g. as a uniform or vertex buffer), but you have a clear
 preference to place it in device or host memory due to its large size.
 
 <ul>
 <li>Use <code>VkBufferCreateInfo::usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</code></li>
 <li>Use <code>VmaAllocationCreateInfo::usage = VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE or VMA_MEMORY_USAGE_AUTO_PREFER_HOST</code></li>
 <li>Use <code>VmaAllocationCreateInfo::flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></li>
 </ul></li>
 </ul>
 
 <h3>Configuration</h3>
 
 <h4>Custom host memory allocator</h4>
 
 <p>If you use custom allocator for CPU memory rather than default operator <code>new</code> and <code>delete</code> from C++, you can make this library using your
 allocator as well by filling optional member <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pAllocationCallbacks</code>. These functions will be passed to Vulkan, as well
 as used by the library itself to make any CPU-side allocations.</p>
 
 <h4>Device memory allocation callbacks</h4>
 
 <p>The library makes calls to <code>vkAllocateMemory()</code> and <code>vkFreeMemory()</code> internally. You can setup callbacks to be informed about these calls,
 e.g. for the purpose of gathering some statistics. To do it, fill optional member <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pDeviceMemoryCallbacks</code>.</p>
 
 <h4>Device heap memory limit</h4>
 
 <p>When device memory of certain heap runs out of free space, new allocations may fail (returning error code) or they may succeed, silently pushing some
 existing memory blocks from GPU VRAM to system RAM (which degrades performance). This behavior is implementation-dependent - it depends on GPU vendor
 and graphics driver.</p>
 
 <p>On AMD cards it can be controlled while creating Vulkan device object by using <code>VK_AMD_memory_overallocation_behavior</code> extension, if available.</p>
 
 <p>Alternatively, if you want to test how your program behaves with limited amount of Vulkan devicememory available without switching your graphics card
 to one that really has smaller VRAM, you can use a feature of this library intended for this purpose. To do it, fill optional member
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pHeapSizeLimit</code>.</p>
 
 <h3>VK_KHR_dedicated_allocation</h3>
 
 <p><code>VK_KHR_dedicated_allocation</code> is a Vulkan extension which can be used to improve performance on some GPUs. It augments Vulkan API with
 possibility to query driver whether it prefers particular buffer or image to have its own, dedicated allocation (separate <code>VkDeviceMemory</code> block)
 for better efficiency - to be able to do some internal optimizations. The extension is supported by this library. It will be used automatically when
 enabled.</p>
 
 <p>It has been promoted to core Vulkan 1.1, so if you use eligible Vulkan version and inform VMA about it by setting
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion</code>, you are all set.</p>
 
 <p>Otherwise, if you want to use it as an extension:</p>
 
 <p>1 . When creating Vulkan device, check if following 2 device extensions are supported (call <code>vkEnumerateDeviceExtensionProperties()</code>). If yes,
 enable them (fill <a href="../../vulkan/VkDeviceCreateInfo.html" title="class in org.lwjgl.vulkan"><code>VkDeviceCreateInfo</code></a><code>::ppEnabledExtensionNames</code>).</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code></li>
 <li><code>VK_KHR_dedicated_allocation</code></li>
 </ul>
 
 <p>If you enabled these extensions:</p>
 
 <p>2 . Use <a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> flag when creating your <code>VmaAllocator</code> to inform the library that you enabled required
 extensions and you want the library to use them.</p>
 
 <pre><code>
 allocatorInfo.flags |= VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;
 
 vmaCreateAllocator(&amp;allocatorInfo, &amp;allocator);</code></pre>
 
 <p>That is all. The extension will be automatically used whenever you create a buffer using <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> or image using <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>.</p>
 
 <p>When using the extension together with Vulkan Validation Layer, you will receive warnings like this:</p>
 
 <pre><code>
 vkBindBufferMemory(): Binding memory to buffer 0x33 but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 
 <p>It is OK, you should just ignore it. It happens because you use function <code>vkGetBufferMemoryRequirements2KHR()</code> instead of standard
 <code>vkGetBufferMemoryRequirements()</code>, while the validation layer seems to be unaware of it.</p>
 
 <p>To learn more about this extension, see:</p>
 
 <ul>
 <li><a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/chap50.html#VK_KHR_dedicated_allocation">VK_KHR_dedicated_allocation in Vulkan specification</a></li>
 <li><a href="http://asawicki.info/articles/VK_KHR_dedicated_allocation.php5">VK_KHR_dedicated_allocation unofficial manual</a></li>
 </ul>
 
 <h4>VK_EXT_memory_priority</h4>
 
 <p><code>VK_EXT_memory_priority</code> is a device extension that allows to pass additional "priority" value to Vulkan memory allocations that the
 implementation may use prefer certain buffers and images that are critical for performance to stay in device-local memory in cases when the memory is
 over-subscribed, while some others may be moved to the system memory.</p>
 
 <p>VMA offers convenient usage of this extension. If you enable it, you can pass "priority" parameter when creating allocations or custom pools and the
 library automatically passes the value to Vulkan using this extension.</p>
 
 <p>If you want to use this extension in connection with VMA, follow these steps:</p>
 
 <h5>Initialization</h5>
 
 <ol>
 <li>Call <code>vkEnumerateDeviceExtensionProperties</code> for the physical device. Check if the extension is supported - if returned array of
 <code>VkExtensionProperties</code> contains <code>"VK_EXT_memory_priority"</code>.</li>
 <li>Call <code>vkGetPhysicalDeviceFeatures2</code> for the physical device instead of old <code>vkGetPhysicalDeviceFeatures</code>. Attach additional structure
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT</code> to <code>VkPhysicalDeviceFeatures2::pNext</code> to be returned. Check if the device feature is really
 supported - check if <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority</code> is true.</li>
 <li>While creating device with <code>vkCreateDevice</code>, enable this extension - add <code>"VK_EXT_memory_priority"</code> to the list passed as
 <code>VkDeviceCreateInfo::ppEnabledExtensionNames</code>.</li>
 <li>While creating the device, also don't set <code>VkDeviceCreateInfo::pEnabledFeatures</code>. Fill in <code>VkPhysicalDeviceFeatures2</code> structure instead
 and pass it as <code>VkDeviceCreateInfo::pNext</code>. Enable this device feature - attach additional structure
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT</code> to <code>VkPhysicalDeviceFeatures2::pNext</code> chain and set its member <code>memoryPriority</code> to
 <code>VK_TRUE</code>.</li>
 <li>While creating <code>VmaAllocator</code> with <a href="#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a> inform VMA that you have enabled this extension and feature - add
 <a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> to <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::flags</code>.</li>
 </ol>
 
 <h5>Usage</h5>
 
 <p>When using this extension, you should initialize following member:</p>
 
 <ul>
 <li><a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::priority</code> when creating a dedicated allocation with <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</li>
 <li><a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::priority</code> when creating a custom pool.</li>
 </ul>
 
 <p>It should be a floating-point value between <code>0.0f</code> and <code>1.0f</code>, where recommended default is <code>0.5f</code>. Memory allocated with higher
 value can be treated by the Vulkan implementation as higher priority and so it can have lower chances of being pushed out to system memory,
 experiencing degraded performance.</p>
 
 <p>It might be a good idea to create performance-critical resources like color-attachment or depth-stencil images as dedicated and set high priority to
 them. For example:</p>
 
 <pre><code>
 VkImageCreateInfo imgCreateInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
 imgCreateInfo.imageType = VK_IMAGE_TYPE_2D;
 imgCreateInfo.extent.width = 3840;
 imgCreateInfo.extent.height = 2160;
 imgCreateInfo.extent.depth = 1;
 imgCreateInfo.mipLevels = 1;
 imgCreateInfo.arrayLayers = 1;
 imgCreateInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
 imgCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
 imgCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
 imgCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
 imgCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
 
 VmaAllocationCreateInfo allocCreateInfo = {};
 allocCreateInfo.usage = VMA_MEMORY_USAGE_AUTO;
 allocCreateInfo.flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
 allocCreateInfo.priority = 1.0f;
 
 VkImage img;
 VmaAllocation alloc;
 vmaCreateImage(allocator, &amp;imgCreateInfo, &amp;allocCreateInfo, &amp;img, &amp;alloc, nullptr);</code></pre>
 
 <p><code>priority</code> member is ignored in the following situations:</p>
 
 <ul>
 <li>Allocations created in custom pools: They inherit the priority, along with all other allocation parameters from the parameters passed in
 <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a> when the pool was created.</li>
 <li>Allocations created in default pools: They inherit the priority from the parameters VMA used when creating default pools, which means
 <code>priority == 0.5f</code>.</li>
 </ul>
 
 <h4>VK_AMD_device_coherent_memory</h4>
 
 <p><code>VK_AMD_device_coherent_memory</code> is a device extension that enables access to additional memory types with
 <code>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD</code> and <code>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD</code> flag. It is useful mostly for allocation of
 buffers intended for writing "breadcrumb markers" in between passes or draw calls, which in turn are useful for debugging GPU crash/hang/TDR cases.</p>
 
 <p>When the extension is available but has not been enabled, Vulkan physical device still exposes those memory types, but their usage is forbidden. VMA
 automatically takes care of that - it returns <code>VK_ERROR_FEATURE_NOT_PRESENT</code> when an attempt to allocate memory of such type is made.</p>
 
 <p>If you want to use this extension in connection with VMA, follow these steps:</p>
 
 <h5>Initialization</h5>
 
 <ol>
 <li>Call <code>vkEnumerateDeviceExtensionProperties</code> for the physical device. Check if the extension is supported - if returned array of
 <code>VkExtensionProperties</code> contains <code>"VK_AMD_device_coherent_memory"</code>.</li>
 <li>Call <code>vkGetPhysicalDeviceFeatures2</code> for the physical device instead of old <code>vkGetPhysicalDeviceFeatures</code>. Attach additional structure
 <code>VkPhysicalDeviceCoherentMemoryFeaturesAMD</code> to <code>VkPhysicalDeviceFeatures2::pNext</code> to be returned. Check if the device feature is really
 supported - check if <code>VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory</code> is true.</li>
 <li>While creating device with <code>vkCreateDevice</code>, enable this extension - add <code>"VK_AMD_device_coherent_memory"</code> to the list passed as
 <code>VkDeviceCreateInfo::ppEnabledExtensionNames</code>.</li>
 <li>While creating the device, also don't set <code>VkDeviceCreateInfo::pEnabledFeatures</code>. Fill in <code>VkPhysicalDeviceFeatures2</code> structure instead
 and pass it as <code>VkDeviceCreateInfo::pNext</code>. Enable this device feature - attach additional structure
 <code>VkPhysicalDeviceCoherentMemoryFeaturesAMD</code> to <code>VkPhysicalDeviceFeatures2::pNext</code> and set its member <code>deviceCoherentMemory</code> to
 <code>VK_TRUE</code>.</li>
 <li>While creating <code>VmaAllocator</code> with <a href="#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a> inform VMA that you have enabled this extension and feature - add
 <a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> to <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::flags</code>.</li>
 </ol>
 
 <h5>Usage</h5>
 
 <p>After following steps described above, you can create VMA allocations and custom pools out of the special <code>DEVICE_COHERENT</code> and
 <code>DEVICE_UNCACHED</code> memory types on eligible devices. There are multiple ways to do it, for example:</p>
 
 <ul>
 <li>You can request or prefer to allocate out of such memory types by adding <code>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD</code> to
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::requiredFlags</code> or <code>VmaAllocationCreateInfo::preferredFlags</code>. Those flags can be freely mixed with other
 ways of choosing memory type, like setting <code>VmaAllocationCreateInfo::usage</code>.</li>
 <li>If you manually found memory type index to use for this purpose, force allocation from this specific index by setting
 <code>VmaAllocationCreateInfo::memoryTypeBits = 1u &lt;&lt; index</code>.</li>
 </ul>
 
 <h5>More information</h5>
 
 <p>To learn more about this extension, see
 <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_AMD_device_coherent_memory.html">VK_AMD_device_coherent_memory in Vulkan specification</a>.</p>
 
 <p>Example use of this extension can be found in the code of the sample and test suite accompanying this library.</p>
 
 <h4>Enabling buffer device address</h4>
 
 <p>Device extension <code>VK_KHR_buffer_device_address</code> allows to fetch raw GPU pointer to a buffer and pass it for usage in a shader code. It has been
 promoted to core Vulkan 1.2.</p>
 
 <p>If you want to use this feature in connection with VMA, follow these steps:</p>
 
 <h5>Initialization</h5>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Call <code>vkEnumerateDeviceExtensionProperties</code> for the physical device. Check if the extension is supported - if
 returned array of <code>VkExtensionProperties</code> contains <code>"VK_KHR_buffer_device_address"</code>.</li>
 <li>Call <code>vkGetPhysicalDeviceFeatures2</code> for the physical device instead of old <code>vkGetPhysicalDeviceFeatures</code>. Attach additional structure
 <code>VkPhysicalDeviceBufferDeviceAddressFeatures*</code> to <code>VkPhysicalDeviceFeatures2::pNext</code> to be returned. Check if the device feature is
 really supported - check if <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code> is true.</li>
 <li>(For Vulkan version &lt; 1.2) While creating device with <code>vkCreateDevice</code>, enable this extension - add <code>"VK_KHR_buffer_device_address"</code>
 to the list passed as <code>VkDeviceCreateInfo::ppEnabledExtensionNames</code>.</li>
 <li>While creating the device, also don't set <code>VkDeviceCreateInfo::pEnabledFeatures</code>. Fill in <code>VkPhysicalDeviceFeatures2</code> structure instead
 and pass it as <code>VkDeviceCreateInfo::pNext</code>. Enable this device feature - attach additional structure
 <code>VkPhysicalDeviceBufferDeviceAddressFeatures*</code> to <code>VkPhysicalDeviceFeatures2::pNext</code> and set its member <code>bufferDeviceAddress</code> to
 <code>VK_TRUE</code>.</li>
 <li>While creating <code>VmaAllocator</code> with <a href="#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a> inform VMA that you have enabled this feature - add
 <a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> to <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::flags</code>.</li>
 </ol>
 
 <h5>Usage</h5>
 
 <p>After following steps described above, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT*</code> using VMA. The library
 automatically adds <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT*</code> to allocated memory blocks wherever it might be needed.</p>
 
 <p>Please note that the library supports only <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT*</code>. The second part of this functionality related to
 "capture and replay" is not supported, as it is intended for usage in debugging tools like RenderDoc, not in everyday Vulkan usage.</p>
 
 <h5>More information</h5>
 
 <p>To learn more about this extension, see
 <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/chap46.html#VK_KHR_buffer_device_address">VK_KHR_buffer_device_address in Vulkan specification</a></p>
 
 <p>Example use of this extension can be found in the code of the sample and test suite accompanying this library.</p>
 
 <h3>General considerations</h3>
 
 <h4>Thread safety</h4>
 
 <ul>
 <li>The library has no global state, so separate <code>VmaAllocator</code> objects can be used independently. There should be no need to create multiple
 such objects though - one per <code>VkDevice</code> is enough.</li>
 <li>By default, all calls to functions that take <code>VmaAllocator</code> as first parameter are safe to call from multiple threads simultaneously because
 they are synchronized internally when needed. This includes allocation and deallocation from default memory pool, as well as custom
 <code>VmaPool</code>.</li>
 <li>When the allocator is created with <a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> flag, calls to functions that take such <code>VmaAllocator</code>
 object must be synchronized externally.</li>
 <li>Access to a <code>VmaAllocation</code> object must be externally synchronized. For example, you must not call <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> and <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> from
 different threads at the same time if you pass the same <code>VmaAllocation</code> object to these functions.</li>
 <li><code>VmaVirtualBlock</code> is not safe to be used from multiple threads simultaneously.</li>
 </ul>
 
 <h4>Validation layer warnings</h4>
 
 <p>When using this library, you can meet following types of warnings issued by Vulkan validation layer. They don't necessarily indicate a bug, so you may
 need to just ignore them.</p>
 
 <ul>
 <li><i><code>vkBindBufferMemory()</code>: Binding memory to buffer <code>0xeb8e4</code> but <code>vkGetBufferMemoryRequirements()</code> has not been called on that
 buffer.</i>
 
 <p>It happens when <code>VK_KHR_dedicated_allocation</code> extension is enabled. <code>vkGetBufferMemoryRequirements2KHR</code> function is used instead, while
 validation layer seems to be unaware of it.</p></li>
 <li><i>Mapping an image with layout <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> can result in undefined behavior if this memory is used by
 the device. Only <code>GENERAL</code> or <code>PREINITIALIZED</code> should be used.</i>
 
 <p>It happens when you map a buffer or image, because the library maps entire <code>VkDeviceMemory</code> block, where different types of images and
 buffers may end up together, especially on GPUs with unified memory like Intel.</p></li>
 <li><i>Non-linear image <code>0xebc91</code> is aliased with linear buffer <code>0xeb8e4</code> which may indicate a bug.</i>
 
 <p>It may happen when you use defragmentation.</p></li>
 </ul>
 
 <h4>Allocation algorithm</h4>
 
 <p>The library uses following algorithm for allocation, in order:</p>
 
 <ol>
 <li>Try to find free range of memory in existing blocks.</li>
 <li>If failed, try to create a new block of <code>VkDeviceMemor</code>y, with preferred block size.</li>
 <li>If failed, try to create such block with <code>size / 2</code>, <code>size / 4</code>, <code>size / 8</code>.</li>
 <li>If failed, try to allocate separate <code>VkDeviceMemory</code> for this allocation, just like when you use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</li>
 <li>If failed, choose other memory type that meets the requirements specified in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> and go to point 1.</li>
 <li>If failed, return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</li>
 </ol>
 
 <h4>Features not supported</h4>
 
 <p>Features deliberately excluded from the scope of this library:</p>
 
 <ul>
 <li><b>Data transfer</b>. Uploading (streaming) and downloading data of buffers and images between CPU and GPU memory and related synchronization is
 responsibility of the user.
 
 <p>Defining some "texture" object that would automatically stream its data from a staging copy in CPU memory to GPU memory would rather be a feature
 of another, higher-level library implemented on top of VMA. VMA doesn't record any commands to a <code>VkCommandBuffer</code>. It just allocates memory.</p></li>
 <li><b>Recreation of buffers and images</b>. Although the library has functions for buffer and image creation: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, you
 need to recreate these objects yourself after defragmentation. That is because the big structures <code>VkBufferCreateInfo</code>,
 <code>VkImageCreateInfo</code> are not stored in <code>VmaAllocation</code> object.</li>
 <li><b>Handling CPU memory allocation failures</b>. When dynamically creating small C++ objects in CPU memory (not Vulkan memory), allocation failures
 are not checked and handled gracefully, because that would complicate code significantly and is usually not needed in desktop PC applications
 anyway. Success of an allocation is just checked with an assert.</li>
 <li><b>Code free of any compiler warnings</b>. Maintaining the library to compile and work correctly on so many different platforms is hard enough. Being free
 of any warnings, on any version of any compiler, is simply not feasible.
 
 <p>There are many preprocessor macros that make some variables unused, function parameters unreferenced, or conditional expressions constant in some
 configurations. The code of this library should not be bigger or more complicated just to silence these warnings. It is recommended to disable such
 warnings instead.</p></li>
 <li>This is a C++ library with C interface. <b>Bindings or ports to any other programming languages</b> are welcome as external projects but are not
 going to be included into this repository.</li>
 </ul></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_MAPPED_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK" class="member-name-link">VMA_ALLOCATION_CREATE_STRATEGY_MASK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT" class="member-name-link">VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT" class="member-name-link">VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT" class="member-name-link">VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT" class="member-name-link">VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT" class="member-name-link">VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT" class="member-name-link">VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT" class="member-name-link">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT" class="member-name-link">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags for created <code>VmaAllocator</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT" class="member-name-link">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT" class="member-name-link">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT" class="member-name-link">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT" class="member-name-link">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK" class="member-name-link">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY" class="member-name-link">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</a></code></div>
<div class="col-last even-row-color">
<div class="block">VmaDefragmentationMoveOperation</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY" class="member-name-link">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">VmaDefragmentationMoveOperation</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE" class="member-name-link">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</a></code></div>
<div class="col-last even-row-color">
<div class="block">VmaDefragmentationMoveOperation</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_MEMORY_USAGE_AUTO" class="member-name-link">VMA_MEMORY_USAGE_AUTO</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE" class="member-name-link">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST" class="member-name-link">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_MEMORY_USAGE_CPU_COPY" class="member-name-link">VMA_MEMORY_USAGE_CPU_COPY</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_MEMORY_USAGE_CPU_ONLY" class="member-name-link">VMA_MEMORY_USAGE_CPU_ONLY</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU" class="member-name-link">VMA_MEMORY_USAGE_CPU_TO_GPU</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED" class="member-name-link">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_MEMORY_USAGE_GPU_ONLY" class="member-name-link">VMA_MEMORY_USAGE_GPU_ONLY</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU" class="member-name-link">VMA_MEMORY_USAGE_GPU_TO_CPU</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_MEMORY_USAGE_UNKNOWN" class="member-name-link">VMA_MEMORY_USAGE_UNKNOWN</a></code></div>
<div class="col-last even-row-color">
<div class="block"><code>VmaMemoryUsage</code></div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_POOL_CREATE_ALGORITHM_MASK" class="member-name-link">VMA_POOL_CREATE_ALGORITHM_MASK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT" class="member-name-link">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT" class="member-name-link">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK" class="member-name-link">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT" class="member-name-link">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT" class="member-name-link">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT" class="member-name-link">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT" class="member-name-link">VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK" class="member-name-link">VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaVirtualBlockCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualBlockCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT" class="member-name-link">VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flags to be passed as <a href="VmaVirtualBlockCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualBlockCreateInfo</code></a><code>::flags</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT" class="member-name-link">VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaAllocateMemory(long,long,long,long,long)" class="member-name-link">nvmaAllocateMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;pVkMemoryRequirements,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaAllocateMemoryForBuffer(long,long,long,long,long)" class="member-name-link">nvmaAllocateMemoryForBuffer</a><wbr>(long&nbsp;allocator,
 long&nbsp;buffer,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaAllocateMemoryForImage(long,long,long,long,long)" class="member-name-link">nvmaAllocateMemoryForImage</a><wbr>(long&nbsp;allocator,
 long&nbsp;image,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaAllocateMemoryPages(long,long,long,long,long,long)" class="member-name-link">nvmaAllocateMemoryPages</a><wbr>(long&nbsp;allocator,
 long&nbsp;pVkMemoryRequirements,
 long&nbsp;pCreateInfo,
 long&nbsp;allocationCount,
 long&nbsp;pAllocations,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBeginDefragmentation(long,long,long)" class="member-name-link">nvmaBeginDefragmentation</a><wbr>(long&nbsp;allocator,
 long&nbsp;pInfo,
 long&nbsp;pContext)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)"><code>BeginDefragmentation</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBeginDefragmentationPass(long,long,long)" class="member-name-link">nvmaBeginDefragmentationPass</a><wbr>(long&nbsp;allocator,
 long&nbsp;context,
 long&nbsp;pInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>BeginDefragmentationPass</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBindBufferMemory(long,long,long)" class="member-name-link">nvmaBindBufferMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBindBufferMemory2(long,long,long,long,long)" class="member-name-link">nvmaBindBufferMemory2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;buffer,
 long&nbsp;pNext)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBindImageMemory(long,long,long)" class="member-name-link">nvmaBindImageMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;image)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBindImageMemory2(long,long,long,long,long)" class="member-name-link">nvmaBindImageMemory2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;image,
 long&nbsp;pNext)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBuildStatsString(long,long,int)" class="member-name-link">nvmaBuildStatsString</a><wbr>(long&nbsp;allocator,
 long&nbsp;ppStatsString,
 int&nbsp;detailedMap)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaBuildVirtualBlockStatsString(long,long,int)" class="member-name-link">nvmaBuildVirtualBlockStatsString</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;ppStatsString,
 int&nbsp;detailedMap)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaBuildVirtualBlockStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildVirtualBlockStatsString</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCalculatePoolStatistics(long,long,long)" class="member-name-link">nvmaCalculatePoolStatistics</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;pPoolStats)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCalculatePoolStatistics(long,long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculatePoolStatistics</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCalculateStatistics(long,long)" class="member-name-link">nvmaCalculateStatistics</a><wbr>(long&nbsp;allocator,
 long&nbsp;pStats)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)"><code>CalculateStatistics</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCalculateVirtualBlockStatistics(long,long)" class="member-name-link">nvmaCalculateVirtualBlockStatistics</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;pStats)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCalculateVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculateVirtualBlockStatistics</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCheckCorruption(long,int)" class="member-name-link">nvmaCheckCorruption</a><wbr>(long&nbsp;allocator,
 int&nbsp;memoryTypeBits)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCheckCorruption(long,int)"><code>CheckCorruption</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCheckPoolCorruption(long,long)" class="member-name-link">nvmaCheckPoolCorruption</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCheckPoolCorruption(long,long)"><code>CheckPoolCorruption</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaClearVirtualBlock(long)" class="member-name-link">nvmaClearVirtualBlock</a><wbr>(long&nbsp;virtualBlock)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaClearVirtualBlock(long)"><code>ClearVirtualBlock</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateAliasingBuffer(long,long,long,long)" class="member-name-link">nvmaCreateAliasingBuffer</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pBuffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingBuffer(long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateAliasingBuffer2(long,long,long,long,long)" class="member-name-link">nvmaCreateAliasingBuffer2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pBuffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingBuffer2(long,long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer2</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateAliasingImage(long,long,long,long)" class="member-name-link">nvmaCreateAliasingImage</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pImage)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingImage(long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingImage</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateAliasingImage2(long,long,long,long,long)" class="member-name-link">nvmaCreateAliasingImage2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pImage)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingImage2(long,long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingImage2</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateAllocator(long,long)" class="member-name-link">nvmaCreateAllocator</a><wbr>(long&nbsp;pCreateInfo,
 long&nbsp;pAllocator)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateBuffer(long,long,long,long,long,long)" class="member-name-link">nvmaCreateBuffer</a><wbr>(long&nbsp;allocator,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pBuffer,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateBufferWithAlignment(long,long,long,long,long,long,long)" class="member-name-link">nvmaCreateBufferWithAlignment</a><wbr>(long&nbsp;allocator,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;minAlignment,
 long&nbsp;pBuffer,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateBufferWithAlignment(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,long,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBufferWithAlignment</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateImage(long,long,long,long,long,long)" class="member-name-link">nvmaCreateImage</a><wbr>(long&nbsp;allocator,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pImage,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreatePool(long,long,long)" class="member-name-link">nvmaCreatePool</a><wbr>(long&nbsp;allocator,
 long&nbsp;pCreateInfo,
 long&nbsp;pPool)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)"><code>CreatePool</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaCreateVirtualBlock(long,long)" class="member-name-link">nvmaCreateVirtualBlock</a><wbr>(long&nbsp;pCreateInfo,
 long&nbsp;pVirtualBlock)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaCreateVirtualBlock(org.lwjgl.util.vma.VmaVirtualBlockCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateVirtualBlock</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaDestroyAllocator(long)" class="member-name-link">nvmaDestroyAllocator</a><wbr>(long&nbsp;allocator)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaDestroyAllocator(long)"><code>DestroyAllocator</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaDestroyBuffer(long,long,long)" class="member-name-link">nvmaDestroyBuffer</a><wbr>(long&nbsp;allocator,
 long&nbsp;buffer,
 long&nbsp;allocation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaDestroyImage(long,long,long)" class="member-name-link">nvmaDestroyImage</a><wbr>(long&nbsp;allocator,
 long&nbsp;image,
 long&nbsp;allocation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaDestroyImage(long,long,long)"><code>DestroyImage</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaDestroyPool(long,long)" class="member-name-link">nvmaDestroyPool</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaDestroyPool(long,long)"><code>DestroyPool</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaDestroyVirtualBlock(long)" class="member-name-link">nvmaDestroyVirtualBlock</a><wbr>(long&nbsp;virtualBlock)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaDestroyVirtualBlock(long)"><code>DestroyVirtualBlock</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaEndDefragmentation(long,long,long)" class="member-name-link">nvmaEndDefragmentation</a><wbr>(long&nbsp;allocator,
 long&nbsp;context,
 long&nbsp;pStats)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaEndDefragmentation(long,long,org.lwjgl.util.vma.VmaDefragmentationStats)"><code>EndDefragmentation</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaEndDefragmentationPass(long,long,long)" class="member-name-link">nvmaEndDefragmentationPass</a><wbr>(long&nbsp;allocator,
 long&nbsp;context,
 long&nbsp;pPassInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>EndDefragmentationPass</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFindMemoryTypeIndex(long,int,long,long)" class="member-name-link">nvmaFindMemoryTypeIndex</a><wbr>(long&nbsp;allocator,
 int&nbsp;memoryTypeBits,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pMemoryTypeIndex)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFindMemoryTypeIndexForBufferInfo(long,long,long,long)" class="member-name-link">nvmaFindMemoryTypeIndexForBufferInfo</a><wbr>(long&nbsp;allocator,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pMemoryTypeIndex)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFindMemoryTypeIndexForImageInfo(long,long,long,long)" class="member-name-link">nvmaFindMemoryTypeIndexForImageInfo</a><wbr>(long&nbsp;allocator,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pMemoryTypeIndex)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFlushAllocation(long,long,long,long)" class="member-name-link">nvmaFlushAllocation</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFlushAllocations(long,int,long,long,long)" class="member-name-link">nvmaFlushAllocations</a><wbr>(long&nbsp;allocator,
 int&nbsp;allocationCount,
 long&nbsp;allocations,
 long&nbsp;offsets,
 long&nbsp;sizes)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFlushAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)"><code>FlushAllocations</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFreeMemory(long,long)" class="member-name-link">nvmaFreeMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFreeMemoryPages(long,long,long)" class="member-name-link">nvmaFreeMemoryPages</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocationCount,
 long&nbsp;pAllocations)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFreeStatsString(long,long)" class="member-name-link">nvmaFreeStatsString</a><wbr>(long&nbsp;allocator,
 long&nbsp;pStatsString)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaFreeVirtualBlockStatsString(long,long)" class="member-name-link">nvmaFreeVirtualBlockStatsString</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;pStatsString)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaFreeVirtualBlockStatsString(long,java.nio.ByteBuffer)"><code>FreeVirtualBlockStatsString</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetAllocationInfo(long,long,long)" class="member-name-link">nvmaGetAllocationInfo</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetAllocationMemoryProperties(long,long,long)" class="member-name-link">nvmaGetAllocationMemoryProperties</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pFlags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetAllocatorInfo(long,long)" class="member-name-link">nvmaGetAllocatorInfo</a><wbr>(long&nbsp;allocator,
 long&nbsp;pAllocatorInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetAllocatorInfo(long,org.lwjgl.util.vma.VmaAllocatorInfo)"><code>GetAllocatorInfo</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetHeapBudgets(long,long)" class="member-name-link">nvmaGetHeapBudgets</a><wbr>(long&nbsp;allocator,
 long&nbsp;pBudget)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetHeapBudgets(long,org.lwjgl.util.vma.VmaBudget.Buffer)"><code>GetHeapBudgets</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetMemoryProperties(long,long)" class="member-name-link">nvmaGetMemoryProperties</a><wbr>(long&nbsp;allocator,
 long&nbsp;ppPhysicalDeviceMemoryProperties)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)"><code>GetMemoryProperties</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetMemoryTypeProperties(long,int,long)" class="member-name-link">nvmaGetMemoryTypeProperties</a><wbr>(long&nbsp;allocator,
 int&nbsp;memoryTypeIndex,
 long&nbsp;pFlags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)"><code>GetMemoryTypeProperties</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetPhysicalDeviceProperties(long,long)" class="member-name-link">nvmaGetPhysicalDeviceProperties</a><wbr>(long&nbsp;allocator,
 long&nbsp;ppPhysicalDeviceProperties)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)"><code>GetPhysicalDeviceProperties</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetPoolName(long,long,long)" class="member-name-link">nvmaGetPoolName</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;ppName)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetPoolName(long,long,org.lwjgl.PointerBuffer)"><code>GetPoolName</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetPoolStatistics(long,long,long)" class="member-name-link">nvmaGetPoolStatistics</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;pPoolStats)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetPoolStatistics(long,long,org.lwjgl.util.vma.VmaStatistics)"><code>GetPoolStatistics</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetVirtualAllocationInfo(long,long,long)" class="member-name-link">nvmaGetVirtualAllocationInfo</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 long&nbsp;pVirtualAllocInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetVirtualAllocationInfo(long,long,org.lwjgl.util.vma.VmaVirtualAllocationInfo)"><code>GetVirtualAllocationInfo</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaGetVirtualBlockStatistics(long,long)" class="member-name-link">nvmaGetVirtualBlockStatistics</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;pStats)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaGetVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaStatistics)"><code>GetVirtualBlockStatistics</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaInvalidateAllocation(long,long,long,long)" class="member-name-link">nvmaInvalidateAllocation</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaInvalidateAllocations(long,int,long,long,long)" class="member-name-link">nvmaInvalidateAllocations</a><wbr>(long&nbsp;allocator,
 int&nbsp;allocationCount,
 long&nbsp;allocations,
 long&nbsp;offsets,
 long&nbsp;sizes)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaInvalidateAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)"><code>InvalidateAllocations</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaIsVirtualBlockEmpty(long)" class="member-name-link">nvmaIsVirtualBlockEmpty</a><wbr>(long&nbsp;virtualBlock)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaIsVirtualBlockEmpty(long)"><code>IsVirtualBlockEmpty</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaMapMemory(long,long,long)" class="member-name-link">nvmaMapMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;ppData)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaSetAllocationName(long,long,long)" class="member-name-link">nvmaSetAllocationName</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pName)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaSetAllocationUserData(long,long,long)" class="member-name-link">nvmaSetAllocationUserData</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pUserData)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaSetAllocationUserData(long,long,long)"><code>SetAllocationUserData</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaSetCurrentFrameIndex(long,int)" class="member-name-link">nvmaSetCurrentFrameIndex</a><wbr>(long&nbsp;allocator,
 int&nbsp;frameIndex)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaSetCurrentFrameIndex(long,int)"><code>SetCurrentFrameIndex</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaSetPoolName(long,long,long)" class="member-name-link">nvmaSetPoolName</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;pName)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaSetPoolName(long,long,java.nio.ByteBuffer)"><code>SetPoolName</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaSetVirtualAllocationUserData(long,long,long)" class="member-name-link">nvmaSetVirtualAllocationUserData</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 long&nbsp;pUserData)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaSetVirtualAllocationUserData(long,long,long)"><code>SetVirtualAllocationUserData</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaUnmapMemory(long,long)" class="member-name-link">nvmaUnmapMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaVirtualAllocate(long,long,long,long)" class="member-name-link">nvmaVirtualAllocate</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pOffset)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaVirtualAllocate(long,org.lwjgl.util.vma.VmaVirtualAllocationCreateInfo,org.lwjgl.PointerBuffer,java.nio.LongBuffer)"><code>VirtualAllocate</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nvmaVirtualFree(long,long)" class="member-name-link">nvmaVirtualFree</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;allocation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#vmaVirtualFree(long,long)"><code>VirtualFree</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)" class="member-name-link">vmaAllocateMemory</a><wbr>(long&nbsp;allocator,
 <a href="../../vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">General purpose memory allocation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)" class="member-name-link">vmaAllocateMemoryForBuffer</a><wbr>(long&nbsp;allocator,
 long&nbsp;buffer,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Allocates memory suitable for given <code>VkBuffer</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)" class="member-name-link">vmaAllocateMemoryForImage</a><wbr>(long&nbsp;allocator,
 long&nbsp;image,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Allocates memory suitable for given <code>VkImage</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)" class="member-name-link">vmaAllocateMemoryPages</a><wbr>(long&nbsp;allocator,
 <a href="../../vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations,
 <a href="VmaAllocationInfo.Buffer.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo.Buffer</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">General purpose memory allocation for multiple allocation objects at once.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)" class="member-name-link">vmaBeginDefragmentation</a><wbr>(long&nbsp;allocator,
 <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationInfo</a>&nbsp;pInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pContext)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Begins defragmentation process.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)" class="member-name-link">vmaBeginDefragmentationPass</a><wbr>(long&nbsp;allocator,
 long&nbsp;context,
 <a href="VmaDefragmentationPassMoveInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationPassMoveInfo</a>&nbsp;pInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Starts single defragmentation pass.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBindBufferMemory(long,long,long)" class="member-name-link">vmaBindBufferMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Binds buffer to allocation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBindBufferMemory2(long,long,long,long,long)" class="member-name-link">vmaBindBufferMemory2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;buffer,
 long&nbsp;pNext)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Binds buffer to allocation with additional parameters.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBindImageMemory(long,long,long)" class="member-name-link">vmaBindImageMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;image)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Binds image to allocation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBindImageMemory2(long,long,long,long,long)" class="member-name-link">vmaBindImageMemory2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;image,
 long&nbsp;pNext)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Binds image to allocation with additional parameters.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)" class="member-name-link">vmaBuildStatsString</a><wbr>(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppStatsString,
 boolean&nbsp;detailedMap)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Builds and returns statistics as a null-terminated string in JSON format.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaBuildVirtualBlockStatsString(long,org.lwjgl.PointerBuffer,boolean)" class="member-name-link">vmaBuildVirtualBlockStatsString</a><wbr>(long&nbsp;virtualBlock,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppStatsString,
 boolean&nbsp;detailedMap)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Builds and returns a null-terminated string in JSON format with information about given <code>VmaVirtualBlock</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCalculatePoolStatistics(long,long,org.lwjgl.util.vma.VmaDetailedStatistics)" class="member-name-link">vmaCalculatePoolStatistics</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="VmaDetailedStatistics.html" title="class in org.lwjgl.util.vma">VmaDetailedStatistics</a>&nbsp;pPoolStats)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieves detailed statistics of existing <code>VmaPool</code> object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)" class="member-name-link">vmaCalculateStatistics</a><wbr>(long&nbsp;allocator,
 <a href="VmaTotalStatistics.html" title="class in org.lwjgl.util.vma">VmaTotalStatistics</a>&nbsp;pStats)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieves statistics from current state of the Allocator.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCalculateVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaDetailedStatistics)" class="member-name-link">vmaCalculateVirtualBlockStatistics</a><wbr>(long&nbsp;virtualBlock,
 <a href="VmaDetailedStatistics.html" title="class in org.lwjgl.util.vma">VmaDetailedStatistics</a>&nbsp;pStats)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates and returns detailed statistics about virtual allocations and memory usage in given <code>VmaVirtualBlock</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCheckCorruption(long,int)" class="member-name-link">vmaCheckCorruption</a><wbr>(long&nbsp;allocator,
 int&nbsp;memoryTypeBits)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCheckPoolCorruption(long,long)" class="member-name-link">vmaCheckPoolCorruption</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Checks magic number in margins around all allocations in given memory pool in search for corruptions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaClearVirtualBlock(long)" class="member-name-link">vmaClearVirtualBlock</a><wbr>(long&nbsp;virtualBlock)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees all virtual allocations inside given <code>VmaVirtualBlock</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateAliasingBuffer(long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)" class="member-name-link">vmaCreateAliasingBuffer</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a new <code>VkBuffer</code>, binds already created memory for it.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateAliasingBuffer2(long,long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)" class="member-name-link">vmaCreateAliasingBuffer2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a new <code>VkBuffer</code>, binds already created memory for it.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateAliasingImage(long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)" class="member-name-link">vmaCreateAliasingImage</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pImage)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Function similar to <a href="#vmaCreateAliasingBuffer(long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer</code></a> but for images.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateAliasingImage2(long,long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)" class="member-name-link">vmaCreateAliasingImage2</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pImage)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Function similar to <a href="#vmaCreateAliasingBuffer2(long,long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer2</code></a> but for images.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)" class="member-name-link">vmaCreateAllocator</a><wbr>(<a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocatorCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocator)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates Allocator object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)" class="member-name-link">vmaCreateBuffer</a><wbr>(long&nbsp;allocator,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a new <code>VkBuffer</code>, allocates and binds memory for it.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateBufferWithAlignment(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,long,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)" class="member-name-link">vmaCreateBufferWithAlignment</a><wbr>(long&nbsp;allocator,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 long&nbsp;minAlignment,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Similar to <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> but provides additional parameter <code>minAlignment</code> which allows to specify custom, minimum alignment to be used when
 placing the buffer inside a larger memory block, which may be needed e.g.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)" class="member-name-link">vmaCreateImage</a><wbr>(long&nbsp;allocator,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pImage,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Function similar to <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)" class="member-name-link">vmaCreatePool</a><wbr>(long&nbsp;allocator,
 <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma">VmaPoolCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pPool)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Allocates Vulkan device memory and creates <code>VmaPool</code> object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaCreateVirtualBlock(org.lwjgl.util.vma.VmaVirtualBlockCreateInfo,org.lwjgl.PointerBuffer)" class="member-name-link">vmaCreateVirtualBlock</a><wbr>(<a href="VmaVirtualBlockCreateInfo.html" title="class in org.lwjgl.util.vma">VmaVirtualBlockCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pVirtualBlock)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates new <code>VmaVirtualBlock</code> object.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaDestroyAllocator(long)" class="member-name-link">vmaDestroyAllocator</a><wbr>(long&nbsp;allocator)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Destroys allocator object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaDestroyBuffer(long,long,long)" class="member-name-link">vmaDestroyBuffer</a><wbr>(long&nbsp;allocator,
 long&nbsp;buffer,
 long&nbsp;allocation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Destroys Vulkan buffer and frees allocated memory.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaDestroyImage(long,long,long)" class="member-name-link">vmaDestroyImage</a><wbr>(long&nbsp;allocator,
 long&nbsp;image,
 long&nbsp;allocation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Destroys Vulkan image and frees allocated memory.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaDestroyPool(long,long)" class="member-name-link">vmaDestroyPool</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Destroys <code>VmaPool</code> object and frees Vulkan device memory.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaDestroyVirtualBlock(long)" class="member-name-link">vmaDestroyVirtualBlock</a><wbr>(long&nbsp;virtualBlock)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Destroys <code>VmaVirtualBlock</code> object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaEndDefragmentation(long,long,org.lwjgl.util.vma.VmaDefragmentationStats)" class="member-name-link">vmaEndDefragmentation</a><wbr>(long&nbsp;allocator,
 long&nbsp;context,
 <a href="VmaDefragmentationStats.html" title="class in org.lwjgl.util.vma">VmaDefragmentationStats</a>&nbsp;pStats)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Ends defragmentation process.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)" class="member-name-link">vmaEndDefragmentationPass</a><wbr>(long&nbsp;allocator,
 long&nbsp;context,
 <a href="VmaDefragmentationPassMoveInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationPassMoveInfo</a>&nbsp;pPassInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Ends single defragmentation pass.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)" class="member-name-link">vmaFindMemoryTypeIndex</a><wbr>(long&nbsp;allocator,
 int&nbsp;memoryTypeBits,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMemoryTypeIndex)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>memoryTypeBits</code> and <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)" class="member-name-link">vmaFindMemoryTypeIndexForBufferInfo</a><wbr>(long&nbsp;allocator,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMemoryTypeIndex)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkBufferCreateInfo</code> and <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)" class="member-name-link">vmaFindMemoryTypeIndexForImageInfo</a><wbr>(long&nbsp;allocator,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMemoryTypeIndex)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkImageCreateInfo</code> and <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFlushAllocation(long,long,long,long)" class="member-name-link">vmaFlushAllocation</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Flushes memory of given allocation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFlushAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)" class="member-name-link">vmaFlushAllocations</a><wbr>(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;allocations,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;offsets,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;sizes)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Flushes memory of given set of allocations.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFreeMemory(long,long)" class="member-name-link">vmaFreeMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory previously allocated using <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, or <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)" class="member-name-link">vmaFreeMemoryPages</a><wbr>(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees memory and destroys multiple allocations.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFreeStatsString(long,java.nio.ByteBuffer)" class="member-name-link">vmaFreeStatsString</a><wbr>(long&nbsp;allocator,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pStatsString)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaFreeVirtualBlockStatsString(long,java.nio.ByteBuffer)" class="member-name-link">vmaFreeVirtualBlockStatsString</a><wbr>(long&nbsp;virtualBlock,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pStatsString)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees a string returned by <a href="#vmaBuildVirtualBlockStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildVirtualBlockStatsString</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)" class="member-name-link">vmaGetAllocationInfo</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns current information about specified allocation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)" class="member-name-link">vmaGetAllocationMemoryProperties</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pFlags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given an allocation, returns Property Flags of its memory type.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetAllocatorInfo(long,org.lwjgl.util.vma.VmaAllocatorInfo)" class="member-name-link">vmaGetAllocatorInfo</a><wbr>(long&nbsp;allocator,
 <a href="VmaAllocatorInfo.html" title="class in org.lwjgl.util.vma">VmaAllocatorInfo</a>&nbsp;pAllocatorInfo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns information about existing <code>VmaAllocator</code> object - handle to Vulkan device etc.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetHeapBudgets(long,org.lwjgl.util.vma.VmaBudget.Buffer)" class="member-name-link">vmaGetHeapBudgets</a><wbr>(long&nbsp;allocator,
 <a href="VmaBudget.Buffer.html" title="class in org.lwjgl.util.vma">VmaBudget.Buffer</a>&nbsp;pBudget)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieves information about current memory usage and budget for all memory heaps.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)" class="member-name-link">vmaGetMemoryProperties</a><wbr>(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceMemoryProperties)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block"><code>PhysicalDeviceMemoryProperties</code> are fetched from <code>physicalDevice</code> by the allocator.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)" class="member-name-link">vmaGetMemoryTypeProperties</a><wbr>(long&nbsp;allocator,
 int&nbsp;memoryTypeIndex,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pFlags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given Memory Type Index, returns Property Flags of this memory type.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)" class="member-name-link">vmaGetPhysicalDeviceProperties</a><wbr>(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceProperties)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block"><code>PhysicalDeviceProperties</code> are fetched from <code>physicalDevice</code> by the allocator.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetPoolName(long,long,org.lwjgl.PointerBuffer)" class="member-name-link">vmaGetPoolName</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppName)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieves name of a custom pool.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetPoolStatistics(long,long,org.lwjgl.util.vma.VmaStatistics)" class="member-name-link">vmaGetPoolStatistics</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="VmaStatistics.html" title="class in org.lwjgl.util.vma">VmaStatistics</a>&nbsp;pPoolStats)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieves statistics of existing VmaPool object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetVirtualAllocationInfo(long,long,org.lwjgl.util.vma.VmaVirtualAllocationInfo)" class="member-name-link">vmaGetVirtualAllocationInfo</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 <a href="VmaVirtualAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaVirtualAllocationInfo</a>&nbsp;pVirtualAllocInfo)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns information about a specific virtual allocation within a virtual block, like its size and <code>pUserData</code> pointer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaGetVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaStatistics)" class="member-name-link">vmaGetVirtualBlockStatistics</a><wbr>(long&nbsp;virtualBlock,
 <a href="VmaStatistics.html" title="class in org.lwjgl.util.vma">VmaStatistics</a>&nbsp;pStats)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Calculates and returns statistics about virtual allocations and memory usage in given <code>VmaVirtualBlock</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaInvalidateAllocation(long,long,long,long)" class="member-name-link">vmaInvalidateAllocation</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Invalidates memory of given allocation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaInvalidateAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)" class="member-name-link">vmaInvalidateAllocations</a><wbr>(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;allocations,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;offsets,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;sizes)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Invalidates memory of given set of allocations.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaIsVirtualBlockEmpty(long)" class="member-name-link">vmaIsVirtualBlockEmpty</a><wbr>(long&nbsp;virtualBlock)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns true of the <code>VmaVirtualBlock</code> is empty - contains 0 virtual allocations and has all its space available for new allocations.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)" class="member-name-link">vmaMapMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppData)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Maps memory represented by given allocation and returns pointer to it.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaSetAllocationName(long,long,java.lang.CharSequence)" class="member-name-link">vmaSetAllocationName</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pName)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Sets <code>pName</code> in given allocation to new value.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)" class="member-name-link">vmaSetAllocationName</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pName)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Sets <code>pName</code> in given allocation to new value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaSetAllocationUserData(long,long,long)" class="member-name-link">vmaSetAllocationUserData</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pUserData)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Sets <code>pUserData</code> in given allocation to new value.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaSetCurrentFrameIndex(long,int)" class="member-name-link">vmaSetCurrentFrameIndex</a><wbr>(long&nbsp;allocator,
 int&nbsp;frameIndex)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Sets index of the current frame.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaSetPoolName(long,long,java.lang.CharSequence)" class="member-name-link">vmaSetPoolName</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pName)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Sets name of a custom pool.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaSetPoolName(long,long,java.nio.ByteBuffer)" class="member-name-link">vmaSetPoolName</a><wbr>(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pName)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Sets name of a custom pool.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaSetVirtualAllocationUserData(long,long,long)" class="member-name-link">vmaSetVirtualAllocationUserData</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 long&nbsp;pUserData)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Changes custom pointer associated with given virtual allocation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaUnmapMemory(long,long)" class="member-name-link">vmaUnmapMemory</a><wbr>(long&nbsp;allocator,
 long&nbsp;allocation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unmaps memory represented by given allocation, mapped previously using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaVirtualAllocate(long,org.lwjgl.util.vma.VmaVirtualAllocationCreateInfo,org.lwjgl.PointerBuffer,java.nio.LongBuffer)" class="member-name-link">vmaVirtualAllocate</a><wbr>(long&nbsp;virtualBlock,
 <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaVirtualAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pOffset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Allocates new virtual allocation inside given <code>VmaVirtualBlock</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#vmaVirtualFree(long,long)" class="member-name-link">vmaVirtualFree</a><wbr>(long&nbsp;virtualBlock,
 long&nbsp;allocation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees virtual allocation inside given <code>VmaVirtualBlock</code>.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT">
<h3>VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</span></div>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code> (device extension)</li>
 <li><code>VK_KHR_dedicated_allocation</code> (device extension)</li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_budget</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library, along with another instance extension
 <code>VK_KHR_get_physical_device_properties2</code>, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
 
 <p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library
 otherwise.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> - 
 Enables usage of <code>VK_AMD_device_coherent_memory</code> extension.
 
 <p>You may set this flag only if you:</p>
 
 <ul>
 <li>found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,</li>
 <li>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</li>
 <li>want it to be used internally by this library.</li>
 </ul>
 
 <p>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
 
 <p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> - 
 Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a
 buffer and pass it for usage inside a shader.
 
 <p>You may set this flag only if you:</p>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension <code>VK_KHR_buffer_device_address</code>. This extension is promoted
 to core Vulkan 1.2.</li>
 <li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code>.</li>
 </ol>
 
 <p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> using VMA. The library automatically adds
 <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT</code> to allocated memory blocks wherever it might be needed.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_priority</code> extension in the library.
 
 <p>You may set this flag only if you found available and enabled this device extension, along with
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE</code>, while creating Vulkan device passed as
 <code>VmaAllocatorCreateInfo::device</code>.</p>
 
 <p>When this flag is used, <code>VmaAllocationCreateInfo::priority</code> and <code>VmaPoolCreateInfo::priority</code> are used to set priorities of allocated
 Vulkan memory. Without it, these variables are ignored.</p>
 
 <p>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger
 values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to
 <code>vkAllocateMemory</code> done by the library using structure <code>VkMemoryPriorityAllocateInfoEXT</code>. The value to be used for default priority is
 0.5. For more details, see the documentation of the <code>VK_EXT_memory_priority</code> extension.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT">
<h3>VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</span></div>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code> (device extension)</li>
 <li><code>VK_KHR_dedicated_allocation</code> (device extension)</li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_budget</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library, along with another instance extension
 <code>VK_KHR_get_physical_device_properties2</code>, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
 
 <p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library
 otherwise.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> - 
 Enables usage of <code>VK_AMD_device_coherent_memory</code> extension.
 
 <p>You may set this flag only if you:</p>
 
 <ul>
 <li>found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,</li>
 <li>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</li>
 <li>want it to be used internally by this library.</li>
 </ul>
 
 <p>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
 
 <p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> - 
 Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a
 buffer and pass it for usage inside a shader.
 
 <p>You may set this flag only if you:</p>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension <code>VK_KHR_buffer_device_address</code>. This extension is promoted
 to core Vulkan 1.2.</li>
 <li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code>.</li>
 </ol>
 
 <p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> using VMA. The library automatically adds
 <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT</code> to allocated memory blocks wherever it might be needed.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_priority</code> extension in the library.
 
 <p>You may set this flag only if you found available and enabled this device extension, along with
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE</code>, while creating Vulkan device passed as
 <code>VmaAllocatorCreateInfo::device</code>.</p>
 
 <p>When this flag is used, <code>VmaAllocationCreateInfo::priority</code> and <code>VmaPoolCreateInfo::priority</code> are used to set priorities of allocated
 Vulkan memory. Without it, these variables are ignored.</p>
 
 <p>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger
 values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to
 <code>vkAllocateMemory</code> done by the library using structure <code>VkMemoryPriorityAllocateInfoEXT</code>. The value to be used for default priority is
 0.5. For more details, see the documentation of the <code>VK_EXT_memory_priority</code> extension.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT">
<h3>VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</span></div>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code> (device extension)</li>
 <li><code>VK_KHR_dedicated_allocation</code> (device extension)</li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_budget</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library, along with another instance extension
 <code>VK_KHR_get_physical_device_properties2</code>, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
 
 <p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library
 otherwise.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> - 
 Enables usage of <code>VK_AMD_device_coherent_memory</code> extension.
 
 <p>You may set this flag only if you:</p>
 
 <ul>
 <li>found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,</li>
 <li>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</li>
 <li>want it to be used internally by this library.</li>
 </ul>
 
 <p>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
 
 <p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> - 
 Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a
 buffer and pass it for usage inside a shader.
 
 <p>You may set this flag only if you:</p>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension <code>VK_KHR_buffer_device_address</code>. This extension is promoted
 to core Vulkan 1.2.</li>
 <li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code>.</li>
 </ol>
 
 <p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> using VMA. The library automatically adds
 <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT</code> to allocated memory blocks wherever it might be needed.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_priority</code> extension in the library.
 
 <p>You may set this flag only if you found available and enabled this device extension, along with
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE</code>, while creating Vulkan device passed as
 <code>VmaAllocatorCreateInfo::device</code>.</p>
 
 <p>When this flag is used, <code>VmaAllocationCreateInfo::priority</code> and <code>VmaPoolCreateInfo::priority</code> are used to set priorities of allocated
 Vulkan memory. Without it, these variables are ignored.</p>
 
 <p>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger
 values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to
 <code>vkAllocateMemory</code> done by the library using structure <code>VkMemoryPriorityAllocateInfoEXT</code>. The value to be used for default priority is
 0.5. For more details, see the documentation of the <code>VK_EXT_memory_priority</code> extension.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT">
<h3>VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</span></div>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code> (device extension)</li>
 <li><code>VK_KHR_dedicated_allocation</code> (device extension)</li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_budget</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library, along with another instance extension
 <code>VK_KHR_get_physical_device_properties2</code>, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
 
 <p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library
 otherwise.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> - 
 Enables usage of <code>VK_AMD_device_coherent_memory</code> extension.
 
 <p>You may set this flag only if you:</p>
 
 <ul>
 <li>found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,</li>
 <li>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</li>
 <li>want it to be used internally by this library.</li>
 </ul>
 
 <p>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
 
 <p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> - 
 Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a
 buffer and pass it for usage inside a shader.
 
 <p>You may set this flag only if you:</p>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension <code>VK_KHR_buffer_device_address</code>. This extension is promoted
 to core Vulkan 1.2.</li>
 <li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code>.</li>
 </ol>
 
 <p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> using VMA. The library automatically adds
 <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT</code> to allocated memory blocks wherever it might be needed.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_priority</code> extension in the library.
 
 <p>You may set this flag only if you found available and enabled this device extension, along with
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE</code>, while creating Vulkan device passed as
 <code>VmaAllocatorCreateInfo::device</code>.</p>
 
 <p>When this flag is used, <code>VmaAllocationCreateInfo::priority</code> and <code>VmaPoolCreateInfo::priority</code> are used to set priorities of allocated
 Vulkan memory. Without it, these variables are ignored.</p>
 
 <p>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger
 values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to
 <code>vkAllocateMemory</code> done by the library using structure <code>VkMemoryPriorityAllocateInfoEXT</code>. The value to be used for default priority is
 0.5. For more details, see the documentation of the <code>VK_EXT_memory_priority</code> extension.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT">
<h3>VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</span></div>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code> (device extension)</li>
 <li><code>VK_KHR_dedicated_allocation</code> (device extension)</li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_budget</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library, along with another instance extension
 <code>VK_KHR_get_physical_device_properties2</code>, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
 
 <p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library
 otherwise.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> - 
 Enables usage of <code>VK_AMD_device_coherent_memory</code> extension.
 
 <p>You may set this flag only if you:</p>
 
 <ul>
 <li>found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,</li>
 <li>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</li>
 <li>want it to be used internally by this library.</li>
 </ul>
 
 <p>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
 
 <p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> - 
 Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a
 buffer and pass it for usage inside a shader.
 
 <p>You may set this flag only if you:</p>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension <code>VK_KHR_buffer_device_address</code>. This extension is promoted
 to core Vulkan 1.2.</li>
 <li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code>.</li>
 </ol>
 
 <p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> using VMA. The library automatically adds
 <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT</code> to allocated memory blocks wherever it might be needed.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_priority</code> extension in the library.
 
 <p>You may set this flag only if you found available and enabled this device extension, along with
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE</code>, while creating Vulkan device passed as
 <code>VmaAllocatorCreateInfo::device</code>.</p>
 
 <p>When this flag is used, <code>VmaAllocationCreateInfo::priority</code> and <code>VmaPoolCreateInfo::priority</code> are used to set priorities of allocated
 Vulkan memory. Without it, these variables are ignored.</p>
 
 <p>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger
 values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to
 <code>vkAllocateMemory</code> done by the library using structure <code>VkMemoryPriorityAllocateInfoEXT</code>. The value to be used for default priority is
 0.5. For more details, see the documentation of the <code>VK_EXT_memory_priority</code> extension.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT">
<h3>VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</span></div>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code> (device extension)</li>
 <li><code>VK_KHR_dedicated_allocation</code> (device extension)</li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_budget</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library, along with another instance extension
 <code>VK_KHR_get_physical_device_properties2</code>, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
 
 <p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library
 otherwise.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> - 
 Enables usage of <code>VK_AMD_device_coherent_memory</code> extension.
 
 <p>You may set this flag only if you:</p>
 
 <ul>
 <li>found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,</li>
 <li>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</li>
 <li>want it to be used internally by this library.</li>
 </ul>
 
 <p>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
 
 <p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> - 
 Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a
 buffer and pass it for usage inside a shader.
 
 <p>You may set this flag only if you:</p>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension <code>VK_KHR_buffer_device_address</code>. This extension is promoted
 to core Vulkan 1.2.</li>
 <li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code>.</li>
 </ol>
 
 <p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> using VMA. The library automatically adds
 <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT</code> to allocated memory blocks wherever it might be needed.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_priority</code> extension in the library.
 
 <p>You may set this flag only if you found available and enabled this device extension, along with
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE</code>, while creating Vulkan device passed as
 <code>VmaAllocatorCreateInfo::device</code>.</p>
 
 <p>When this flag is used, <code>VmaAllocationCreateInfo::priority</code> and <code>VmaPoolCreateInfo::priority</code> are used to set priorities of allocated
 Vulkan memory. Without it, these variables are ignored.</p>
 
 <p>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger
 values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to
 <code>vkAllocateMemory</code> done by the library using structure <code>VkMemoryPriorityAllocateInfoEXT</code>. The value to be used for default priority is
 0.5. For more details, see the documentation of the <code>VK_EXT_memory_priority</code> extension.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT">
<h3>VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</span></div>
<div class="block">Flags for created <code>VmaAllocator</code>. (<code>VmaAllocatorCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"><code>ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</code></a> - 
 Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time
 or synchronized externally by you.
 
 <p>Using this flag may increase performance because internal mutexes are not used.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> - 
 Enables usage of <code>VK_KHR_dedicated_allocation</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out
 of bigger memory blocks (as if you explicitly used <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> flag) when it is recommended by the driver. It may
 improve performance on some GPUs.</p>
 
 <p>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want them to be used internally by this library:</p>
 
 <ul>
 <li><code>VK_KHR_get_memory_requirements2</code> (device extension)</li>
 <li><code>VK_KHR_dedicated_allocation</code> (device extension)</li>
 </ul>
 
 <p>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</p>
 
 <pre><code>
 &gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.</code></pre>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> - 
 Enables usage of <code>VK_KHR_bind_memory2</code> extension.
 
 <p>The flag works only if <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion == VK_API_VERSION_1_0</code>. When it is <code>VK_API_VERSION_1_1</code>, the flag is
 ignored because the extension has been promoted to Vulkan 1.1.</p>
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library.</p>
 
 <p>The extension provides functions <code>vkBindBufferMemory2KHR</code> and <code>vkBindImageMemory2KHR</code>, which allow to pass a chain of <code>pNext</code>
 structures while binding. This flag is required if you use <code>pNext</code> parameter in <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a> or <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_budget</code> extension.
 
 <p>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::device</code>, and you want it to be used internally by this library, along with another instance extension
 <code>VK_KHR_get_physical_device_properties2</code>, which is required by it (or Vulkan 1.1, where this extension is promoted).</p>
 
 <p>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library
 otherwise.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT"><code>ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</code></a> - 
 Enables usage of <code>VK_AMD_device_coherent_memory</code> extension.
 
 <p>You may set this flag only if you:</p>
 
 <ul>
 <li>found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,</li>
 <li>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</li>
 <li>want it to be used internally by this library.</li>
 </ul>
 
 <p>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</p>
 
 <p>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT"><code>ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</code></a> - 
 Enables usage of "buffer device address" feature, which allows you to use function <code>vkGetBufferDeviceAddress*</code> to get raw GPU pointer to a
 buffer and pass it for usage inside a shader.
 
 <p>You may set this flag only if you:</p>
 
 <ol>
 <li>(For Vulkan version &lt; 1.2) Found as available and enabled device extension <code>VK_KHR_buffer_device_address</code>. This extension is promoted
 to core Vulkan 1.2.</li>
 <li>Found as available and enabled device feature <code>VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress</code>.</li>
 </ol>
 
 <p>When this flag is set, you can create buffers with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code> using VMA. The library automatically adds
 <code>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT</code> to allocated memory blocks wherever it might be needed.</p>
 </li>
 <li><a href="#VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT"><code>ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</code></a> - 
 Enables usage of <code>VK_EXT_memory_priority</code> extension in the library.
 
 <p>You may set this flag only if you found available and enabled this device extension, along with
 <code>VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE</code>, while creating Vulkan device passed as
 <code>VmaAllocatorCreateInfo::device</code>.</p>
 
 <p>When this flag is used, <code>VmaAllocationCreateInfo::priority</code> and <code>VmaPoolCreateInfo::priority</code> are used to set priorities of allocated
 Vulkan memory. Without it, these variables are ignored.</p>
 
 <p>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger
 values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to
 <code>vkAllocateMemory</code> done by the library using structure <code>VkMemoryPriorityAllocateInfoEXT</code>. The value to be used for default priority is
 0.5. For more details, see the documentation of the <code>VK_EXT_memory_priority</code> extension.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_UNKNOWN">
<h3>VMA_MEMORY_USAGE_UNKNOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_UNKNOWN</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_UNKNOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_GPU_ONLY">
<h3>VMA_MEMORY_USAGE_GPU_ONLY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_GPU_ONLY</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_GPU_ONLY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_CPU_ONLY">
<h3>VMA_MEMORY_USAGE_CPU_ONLY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_CPU_ONLY</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_CPU_ONLY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_CPU_TO_GPU">
<h3>VMA_MEMORY_USAGE_CPU_TO_GPU</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_CPU_TO_GPU</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_CPU_TO_GPU">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_GPU_TO_CPU">
<h3>VMA_MEMORY_USAGE_GPU_TO_CPU</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_GPU_TO_CPU</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_GPU_TO_CPU">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_CPU_COPY">
<h3>VMA_MEMORY_USAGE_CPU_COPY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_CPU_COPY</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_CPU_COPY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED">
<h3>VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_AUTO">
<h3>VMA_MEMORY_USAGE_AUTO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_AUTO</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_AUTO">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE">
<h3>VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_MEMORY_USAGE_AUTO_PREFER_HOST">
<h3>VMA_MEMORY_USAGE_AUTO_PREFER_HOST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</span></div>
<div class="block"><code>VmaMemoryUsage</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_MEMORY_USAGE_UNKNOWN"><code>MEMORY_USAGE_UNKNOWN</code></a> - 
 No intended memory usage specified.
 
 <p>Use other members of <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a> to specify your requirements.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_ONLY"><code>MEMORY_USAGE_GPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_ONLY"><code>MEMORY_USAGE_CPU_ONLY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_TO_GPU"><code>MEMORY_USAGE_CPU_TO_GPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_TO_CPU"><code>MEMORY_USAGE_GPU_TO_CPU</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_CPU_COPY"><code>MEMORY_USAGE_CPU_COPY</code></a> - 
 Obsolete, preserved for backward compatibility.
 
 <p>Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED"><code>MEMORY_USAGE_GPU_LAZILY_ALLOCATED</code></a> - 
 Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>.
 
 <p>Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
 
 <p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with
 <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
 
 <p>Allocations with this usage are always created as dedicated - it implies <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> - 
 Selects best memory type automatically. This flag is recommended for most common use cases.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE"><code>MEMORY_USAGE_AUTO_PREFER_DEVICE</code></a> - 
 Selects best memory type automatically with preference for GPU (device) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 <li><a href="#VMA_MEMORY_USAGE_AUTO_PREFER_HOST"><code>MEMORY_USAGE_AUTO_PREFER_HOST</code></a> - 
 Selects best memory type automatically with preference for CPU (host) memory.
 
 <p>When using this flag, if you want to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>), you must pass one of the flags:
 <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> in <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>.</p>
 
 <p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>,
 <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a>, <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a> and not with generic memory allocation functions.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_MEMORY_USAGE_AUTO_PREFER_HOST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT">
<h3>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT">
<h3>VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_MAPPED_BIT">
<h3>VMA_ALLOCATION_CREATE_MAPPED_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_MAPPED_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_MAPPED_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT">
<h3>VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT">
<h3>VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_DONT_BIND_BIT">
<h3>VMA_ALLOCATION_CREATE_DONT_BIND_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_DONT_BIND_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT">
<h3>VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT">
<h3>VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT">
<h3>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT">
<h3>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT">
<h3>VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT">
<h3>VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT">
<h3>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT">
<h3>VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT">
<h3>VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT">
<h3>VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_ALLOCATION_CREATE_STRATEGY_MASK">
<h3>VMA_ALLOCATION_CREATE_STRATEGY_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_ALLOCATION_CREATE_STRATEGY_MASK</span></div>
<div class="block">Flags to be passed as <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> - 
 Set this flag if the allocation should have its own memory block.
 
 <p>Use it for special, big resources, like fullscreen images used as attachments.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> - 
 Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block.
 
 <p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
 
 <p>You should not use <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> and <a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> at the same time. It makes no sense.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> - 
 Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
 
 <p>Pointer to mapped memory will be returned through <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationInfo</code></a><code>::pMappedData</code>.</p>
 
 <p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not
 mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if
 possible on platforms that support it (e.g. Intel GPU).</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT"><code>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</code></a> - 
 Preserved for backward compatibility. Consider using <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a> instead.
 
 <p>Set this flag to treat <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a><code>::pUserData</code> as pointer to a null-terminated string. Instead of copying pointer value, a
 local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is
 also used in <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for custom pools created with <a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_DONT_BIND_BIT"><code>ALLOCATION_CREATE_DONT_BIND_BIT</code></a> - 
 Create both buffer/image and allocation, but don't bind them together.
 
 <p>It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with
 functions that bind by default: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. Otherwise it is ignored.</p>
 
 <p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure
 in case the allocation ends up in its own memory block, use also flag <a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT"><code>ALLOCATION_CREATE_WITHIN_BUDGET_BIT</code></a> - 
 Create allocation only if additional device memory required for it, if any, won't exceed memory budget.
 
 <p>Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT"><code>ALLOCATION_CREATE_CAN_ALIAS_BIT</code></a> - 
 Set this flag if the allocated memory will have aliasing resources.
 
 <p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a> is specified.
 Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> - 
 Requests possibility to map the allocation (using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a> or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or
 accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
 
 <p>Warning: Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g.
 <code>pMappedData[i] += x;</code>. Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a> - 
 Requests possibility to map the allocation (using MapMemory() or <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a>).
 
 <ul>
 <li>If you use <a href="#VMA_MEMORY_USAGE_AUTO"><code>MEMORY_USAGE_AUTO</code></a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation.
 Otherwise, mapping is incorrect.</li>
 <li>If you use other value of <code>VmaMemoryUsage</code>, this flag is ignored and mapping is always possible in memory types that are
 <code>HOST_VISIBLE</code>. This includes allocations created in custom memory pools.</li>
 </ul>
 
 <p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</code></a> - 
 Together with <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</code></a> or <a href="#VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"><code>ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</code></a>, it says that despite request for
 host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.
 
 <p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using
 <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To
 prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>,
 <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - 
 Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the
 expense of allocation time.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - 
 Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is
 easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality.
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage.</p>
 </li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT"><code>ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a>.</li>
 <li><a href="#VMA_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT"><code>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</code></a> - Alias to <a href="#VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a>.</li>
 <li><a href="#VMA_ALLOCATION_CREATE_STRATEGY_MASK"><code>ALLOCATION_CREATE_STRATEGY_MASK</code></a> - A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_ALLOCATION_CREATE_STRATEGY_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT">
<h3>VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>. (<code>VmaPoolCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT"><code>POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</code></a> - 
 Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be
 ignored.
 
 <p>This is an optional optimization flag.</p>
 
 <p>If you always allocate using <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, then you don't need to use it because allocator knows
 exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</p>
 
 <p>If you also allocate using <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a> or <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, exact type of such allocations is not known, so allocator must be
 conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you
 always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image
 Granularity and so make allocations faster and more optimal.</p>
 </li>
 <li><a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> - 
 Enables alternative, linear allocation algorithm in this pool.
 
 <p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from
 allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less
 memory for metadata.</p>
 
 <p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack.</p>
 </li>
 <li><a href="#VMA_POOL_CREATE_ALGORITHM_MASK"><code>POOL_CREATE_ALGORITHM_MASK</code></a> - Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT">
<h3>VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>. (<code>VmaPoolCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT"><code>POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</code></a> - 
 Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be
 ignored.
 
 <p>This is an optional optimization flag.</p>
 
 <p>If you always allocate using <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, then you don't need to use it because allocator knows
 exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</p>
 
 <p>If you also allocate using <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a> or <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, exact type of such allocations is not known, so allocator must be
 conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you
 always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image
 Granularity and so make allocations faster and more optimal.</p>
 </li>
 <li><a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> - 
 Enables alternative, linear allocation algorithm in this pool.
 
 <p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from
 allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less
 memory for metadata.</p>
 
 <p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack.</p>
 </li>
 <li><a href="#VMA_POOL_CREATE_ALGORITHM_MASK"><code>POOL_CREATE_ALGORITHM_MASK</code></a> - Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_POOL_CREATE_ALGORITHM_MASK">
<h3>VMA_POOL_CREATE_ALGORITHM_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_POOL_CREATE_ALGORITHM_MASK</span></div>
<div class="block">Flags to be passed as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::flags</code>. (<code>VmaPoolCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT"><code>POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</code></a> - 
 Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be
 ignored.
 
 <p>This is an optional optimization flag.</p>
 
 <p>If you always allocate using <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>, <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, then you don't need to use it because allocator knows
 exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</p>
 
 <p>If you also allocate using <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a> or <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, exact type of such allocations is not known, so allocator must be
 conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you
 always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image
 Granularity and so make allocations faster and more optimal.</p>
 </li>
 <li><a href="#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT"><code>POOL_CREATE_LINEAR_ALGORITHM_BIT</code></a> - 
 Enables alternative, linear allocation algorithm in this pool.
 
 <p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from
 allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less
 memory for metadata.</p>
 
 <p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack.</p>
 </li>
 <li><a href="#VMA_POOL_CREATE_ALGORITHM_MASK"><code>POOL_CREATE_ALGORITHM_MASK</code></a> - Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_POOL_CREATE_ALGORITHM_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT">
<h3>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>. <code>VmaDefragmentationFlagBits</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</code></a> - 
 Use simple but fast algorithm for defragmentation.
 
 <p>May not achieve best results but will require least time to compute and least allocations to copy.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</code></a> - 
 Default defragmentation algorithm, applied also when no <code>ALGORITHM</code> flag is specified.
 
 <p>Offers a balance between defragmentation quality and the amount of allocations and bytes that need to be moved.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a> - 
 Perform full defragmentation of memory.
 
 <p>Can result in notably more time to compute and allocations to copy, but will achieve best memory packing.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</code></a> - 
 Use the most roboust algorithm at the cost of time to compute and number of copies to make.
 
 <p>Only available when <code>bufferImageGranularity</code> is greater than 1, since it aims to reduce alignment issues between different types of
 resources. Otherwise falls back to same behavior as <a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK"><code>DEFRAGMENTATION_FLAG_ALGORITHM_MASK</code></a> - A bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT">
<h3>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>. <code>VmaDefragmentationFlagBits</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</code></a> - 
 Use simple but fast algorithm for defragmentation.
 
 <p>May not achieve best results but will require least time to compute and least allocations to copy.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</code></a> - 
 Default defragmentation algorithm, applied also when no <code>ALGORITHM</code> flag is specified.
 
 <p>Offers a balance between defragmentation quality and the amount of allocations and bytes that need to be moved.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a> - 
 Perform full defragmentation of memory.
 
 <p>Can result in notably more time to compute and allocations to copy, but will achieve best memory packing.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</code></a> - 
 Use the most roboust algorithm at the cost of time to compute and number of copies to make.
 
 <p>Only available when <code>bufferImageGranularity</code> is greater than 1, since it aims to reduce alignment issues between different types of
 resources. Otherwise falls back to same behavior as <a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK"><code>DEFRAGMENTATION_FLAG_ALGORITHM_MASK</code></a> - A bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT">
<h3>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>. <code>VmaDefragmentationFlagBits</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</code></a> - 
 Use simple but fast algorithm for defragmentation.
 
 <p>May not achieve best results but will require least time to compute and least allocations to copy.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</code></a> - 
 Default defragmentation algorithm, applied also when no <code>ALGORITHM</code> flag is specified.
 
 <p>Offers a balance between defragmentation quality and the amount of allocations and bytes that need to be moved.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a> - 
 Perform full defragmentation of memory.
 
 <p>Can result in notably more time to compute and allocations to copy, but will achieve best memory packing.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</code></a> - 
 Use the most roboust algorithm at the cost of time to compute and number of copies to make.
 
 <p>Only available when <code>bufferImageGranularity</code> is greater than 1, since it aims to reduce alignment issues between different types of
 resources. Otherwise falls back to same behavior as <a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK"><code>DEFRAGMENTATION_FLAG_ALGORITHM_MASK</code></a> - A bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT">
<h3>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>. <code>VmaDefragmentationFlagBits</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</code></a> - 
 Use simple but fast algorithm for defragmentation.
 
 <p>May not achieve best results but will require least time to compute and least allocations to copy.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</code></a> - 
 Default defragmentation algorithm, applied also when no <code>ALGORITHM</code> flag is specified.
 
 <p>Offers a balance between defragmentation quality and the amount of allocations and bytes that need to be moved.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a> - 
 Perform full defragmentation of memory.
 
 <p>Can result in notably more time to compute and allocations to copy, but will achieve best memory packing.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</code></a> - 
 Use the most roboust algorithm at the cost of time to compute and number of copies to make.
 
 <p>Only available when <code>bufferImageGranularity</code> is greater than 1, since it aims to reduce alignment issues between different types of
 resources. Otherwise falls back to same behavior as <a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK"><code>DEFRAGMENTATION_FLAG_ALGORITHM_MASK</code></a> - A bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK">
<h3>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</span></div>
<div class="block">Flags to be passed as <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma"><code>VmaDefragmentationInfo</code></a><code>::flags</code>. <code>VmaDefragmentationFlagBits</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</code></a> - 
 Use simple but fast algorithm for defragmentation.
 
 <p>May not achieve best results but will require least time to compute and least allocations to copy.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</code></a> - 
 Default defragmentation algorithm, applied also when no <code>ALGORITHM</code> flag is specified.
 
 <p>Offers a balance between defragmentation quality and the amount of allocations and bytes that need to be moved.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a> - 
 Perform full defragmentation of memory.
 
 <p>Can result in notably more time to compute and allocations to copy, but will achieve best memory packing.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</code></a> - 
 Use the most roboust algorithm at the cost of time to compute and number of copies to make.
 
 <p>Only available when <code>bufferImageGranularity</code> is greater than 1, since it aims to reduce alignment issues between different types of
 resources. Otherwise falls back to same behavior as <a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT"><code>DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</code></a>.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK"><code>DEFRAGMENTATION_FLAG_ALGORITHM_MASK</code></a> - A bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY">
<h3>VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</span></div>
<div class="block">VmaDefragmentationMoveOperation
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY"><code>DEFRAGMENTATION_MOVE_OPERATION_COPY</code></a> - 
 Buffer/image has been recreated at <code>dstTmpAllocation</code>, data has been copied, old buffer/image has been destroyed. <code>srcAllocation</code>
 should be changed to point to the new place. This is the default value set by <a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>BeginDefragmentationPass</code></a>.
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE"><code>DEFRAGMENTATION_MOVE_OPERATION_IGNORE</code></a> - 
 Set this value if you cannot move the allocation.
 
 <p>New place reserved at <code>dstTmpAllocation</code> will be freed. <code>srcAllocation</code> will remain unchanged.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY"><code>DEFRAGMENTATION_MOVE_OPERATION_DESTROY</code></a> - 
 Set this value if you decide to abandon the allocation and you destroyed the buffer/image.
 
 <p>New place reserved at <code>dstTmpAllocation</code> will be freed, along with <code>srcAllocation</code>, which will be destroyed.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE">
<h3>VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</span></div>
<div class="block">VmaDefragmentationMoveOperation
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY"><code>DEFRAGMENTATION_MOVE_OPERATION_COPY</code></a> - 
 Buffer/image has been recreated at <code>dstTmpAllocation</code>, data has been copied, old buffer/image has been destroyed. <code>srcAllocation</code>
 should be changed to point to the new place. This is the default value set by <a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>BeginDefragmentationPass</code></a>.
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE"><code>DEFRAGMENTATION_MOVE_OPERATION_IGNORE</code></a> - 
 Set this value if you cannot move the allocation.
 
 <p>New place reserved at <code>dstTmpAllocation</code> will be freed. <code>srcAllocation</code> will remain unchanged.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY"><code>DEFRAGMENTATION_MOVE_OPERATION_DESTROY</code></a> - 
 Set this value if you decide to abandon the allocation and you destroyed the buffer/image.
 
 <p>New place reserved at <code>dstTmpAllocation</code> will be freed, along with <code>srcAllocation</code>, which will be destroyed.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY">
<h3>VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</span></div>
<div class="block">VmaDefragmentationMoveOperation
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY"><code>DEFRAGMENTATION_MOVE_OPERATION_COPY</code></a> - 
 Buffer/image has been recreated at <code>dstTmpAllocation</code>, data has been copied, old buffer/image has been destroyed. <code>srcAllocation</code>
 should be changed to point to the new place. This is the default value set by <a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>BeginDefragmentationPass</code></a>.
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE"><code>DEFRAGMENTATION_MOVE_OPERATION_IGNORE</code></a> - 
 Set this value if you cannot move the allocation.
 
 <p>New place reserved at <code>dstTmpAllocation</code> will be freed. <code>srcAllocation</code> will remain unchanged.</p>
 </li>
 <li><a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY"><code>DEFRAGMENTATION_MOVE_OPERATION_DESTROY</code></a> - 
 Set this value if you decide to abandon the allocation and you destroyed the buffer/image.
 
 <p>New place reserved at <code>dstTmpAllocation</code> will be freed, along with <code>srcAllocation</code>, which will be destroyed.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT">
<h3>VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaVirtualBlockCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualBlockCreateInfo</code></a><code>::flags</code>. (<code>VmaVirtualBlockCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a> - 
 Enables alternative, linear allocation algorithm in this virtual block.
 
 <p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from
 allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less
 memory for metadata.</p>
 
 <p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK"><code>VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</code></a> - Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK">
<h3>VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</span></div>
<div class="block">Flags to be passed as <a href="VmaVirtualBlockCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualBlockCreateInfo</code></a><code>::flags</code>. (<code>VmaVirtualBlockCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a> - 
 Enables alternative, linear allocation algorithm in this virtual block.
 
 <p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from
 allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less
 memory for metadata.</p>
 
 <p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK"><code>VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</code></a> - Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT">
<h3>VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaVirtualAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for virtual blocks created with <a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - Allocation strategy that tries to minimize memory usage.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - Allocation strategy that tries to minimize allocation time.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</code></a> - 
 A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.
 
 <p>These stategy flags are binary compatible with equivalent flags in <code>VmaAllocationCreateFlagBits</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT">
<h3>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaVirtualAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for virtual blocks created with <a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - Allocation strategy that tries to minimize memory usage.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - Allocation strategy that tries to minimize allocation time.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</code></a> - 
 A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.
 
 <p>These stategy flags are binary compatible with equivalent flags in <code>VmaAllocationCreateFlagBits</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT">
<h3>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaVirtualAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for virtual blocks created with <a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - Allocation strategy that tries to minimize memory usage.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - Allocation strategy that tries to minimize allocation time.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</code></a> - 
 A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.
 
 <p>These stategy flags are binary compatible with equivalent flags in <code>VmaAllocationCreateFlagBits</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT">
<h3>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</span></div>
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaVirtualAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for virtual blocks created with <a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - Allocation strategy that tries to minimize memory usage.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - Allocation strategy that tries to minimize allocation time.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</code></a> - 
 A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.
 
 <p>These stategy flags are binary compatible with equivalent flags in <code>VmaAllocationCreateFlagBits</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK">
<h3>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</span></div>
<div class="block">Flags to be passed as <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaVirtualAllocationCreateInfo</code></a><code>::flags</code>. (<code>VmaVirtualAllocationCreateFlagBits</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT"><code>VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</code></a> - 
 Allocation will be created from upper stack in a double stack pool.
 
 <p>This flag is only allowed for virtual blocks created with <a href="#VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT"><code>VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</code></a> flag.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</code></a> - Allocation strategy that tries to minimize memory usage.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</code></a> - Allocation strategy that tries to minimize allocation time.</li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</code></a> - 
 Allocation strategy that chooses always the lowest offset in available space.
 
 <p>This is not the most efficient strategy but achieves highly packed data.</p>
 </li>
 <li><a href="#VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK"><code>VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</code></a> - 
 A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags.
 
 <p>These stategy flags are binary compatible with equivalent flags in <code>VmaAllocationCreateFlagBits</code>.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../constant-values.html#org.lwjgl.util.vma.Vma.VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="nvmaCreateAllocator(long,long)">
<h3>nvmaCreateAllocator</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateAllocator</span><wbr><span class="parameters">(long&nbsp;pCreateInfo,
 long&nbsp;pAllocator)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateAllocator</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateAllocator(org.lwjgl.util.vma.VmaAllocatorCreateInfo,org.lwjgl.PointerBuffer)">
<h3>vmaCreateAllocator</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateAllocator</span><wbr><span class="parameters">(<a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocatorCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocator)</span></div>
<div class="block">Creates Allocator object.
 
 <p>LWJGL: Use <a href="VmaVulkanFunctions.html" title="class in org.lwjgl.util.vma"><code>VmaVulkanFunctions</code></a><code>::set(VkInstance, VkDevice)</code> to populate the <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::pVulkanFunctions</code> struct.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaDestroyAllocator(long)">
<h3>nvmaDestroyAllocator</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaDestroyAllocator</span><wbr><span class="parameters">(long&nbsp;allocator)</span></div>
<div class="block">Unsafe version of: <a href="#vmaDestroyAllocator(long)"><code>DestroyAllocator</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaDestroyAllocator(long)">
<h3>vmaDestroyAllocator</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaDestroyAllocator</span><wbr><span class="parameters">(long&nbsp;allocator)</span></div>
<div class="block">Destroys allocator object.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetAllocatorInfo(long,long)">
<h3>nvmaGetAllocatorInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetAllocatorInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pAllocatorInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetAllocatorInfo(long,org.lwjgl.util.vma.VmaAllocatorInfo)"><code>GetAllocatorInfo</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetAllocatorInfo(long,org.lwjgl.util.vma.VmaAllocatorInfo)">
<h3>vmaGetAllocatorInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetAllocatorInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="VmaAllocatorInfo.html" title="class in org.lwjgl.util.vma">VmaAllocatorInfo</a>&nbsp;pAllocatorInfo)</span></div>
<div class="block">Returns information about existing <code>VmaAllocator</code> object - handle to Vulkan device etc.
 
 <p>It might be useful if you want to keep just the <code>VmaAllocator</code> handle and fetch other required handles to <code>VkPhysicalDevice</code>,
 <code>VkDevice</code> etc. every time using this function.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetPhysicalDeviceProperties(long,long)">
<h3>nvmaGetPhysicalDeviceProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetPhysicalDeviceProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;ppPhysicalDeviceProperties)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)"><code>GetPhysicalDeviceProperties</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetPhysicalDeviceProperties(long,org.lwjgl.PointerBuffer)">
<h3>vmaGetPhysicalDeviceProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetPhysicalDeviceProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceProperties)</span></div>
<div class="block"><code>PhysicalDeviceProperties</code> are fetched from <code>physicalDevice</code> by the allocator. You can access it here, without fetching it again on your
 own.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetMemoryProperties(long,long)">
<h3>nvmaGetMemoryProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetMemoryProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;ppPhysicalDeviceMemoryProperties)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)"><code>GetMemoryProperties</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)">
<h3>vmaGetMemoryProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetMemoryProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppPhysicalDeviceMemoryProperties)</span></div>
<div class="block"><code>PhysicalDeviceMemoryProperties</code> are fetched from <code>physicalDevice</code> by the allocator. You can access it here, without fetching it again on
 your own.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetMemoryTypeProperties(long,int,long)">
<h3>nvmaGetMemoryTypeProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetMemoryTypeProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;memoryTypeIndex,
 long&nbsp;pFlags)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)"><code>GetMemoryTypeProperties</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetMemoryTypeProperties(long,int,java.nio.IntBuffer)">
<h3>vmaGetMemoryTypeProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetMemoryTypeProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;memoryTypeIndex,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pFlags)</span></div>
<div class="block">Given Memory Type Index, returns Property Flags of this memory type.
 
 <p>This is just a convenience function. Same information can be obtained using <a href="#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)"><code>GetMemoryProperties</code></a>.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaSetCurrentFrameIndex(long,int)">
<h3>nvmaSetCurrentFrameIndex</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaSetCurrentFrameIndex</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;frameIndex)</span></div>
<div class="block">Unsafe version of: <a href="#vmaSetCurrentFrameIndex(long,int)"><code>SetCurrentFrameIndex</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaSetCurrentFrameIndex(long,int)">
<h3>vmaSetCurrentFrameIndex</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaSetCurrentFrameIndex</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;frameIndex)</span></div>
<div class="block">Sets index of the current frame.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaCalculateStatistics(long,long)">
<h3>nvmaCalculateStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaCalculateStatistics</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pStats)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)"><code>CalculateStatistics</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)">
<h3>vmaCalculateStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaCalculateStatistics</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="VmaTotalStatistics.html" title="class in org.lwjgl.util.vma">VmaTotalStatistics</a>&nbsp;pStats)</span></div>
<div class="block">Retrieves statistics from current state of the Allocator.
 
 <p>This function is called "calculate" not "get" because it has to traverse all internal data structures, so it may be quite slow. Use it for debugging
 purposes. For faster but more brief statistics suitable to be called every frame or every allocation, use <a href="#vmaGetHeapBudgets(long,org.lwjgl.util.vma.VmaBudget.Buffer)"><code>GetHeapBudgets</code></a>.</p>
 
 <p>Note that when using allocator from multiple threads, returned information may immediately become outdated.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetHeapBudgets(long,long)">
<h3>nvmaGetHeapBudgets</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetHeapBudgets</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pBudget)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetHeapBudgets(long,org.lwjgl.util.vma.VmaBudget.Buffer)"><code>GetHeapBudgets</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetHeapBudgets(long,org.lwjgl.util.vma.VmaBudget.Buffer)">
<h3>vmaGetHeapBudgets</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetHeapBudgets</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="VmaBudget.Buffer.html" title="class in org.lwjgl.util.vma">VmaBudget.Buffer</a>&nbsp;pBudget)</span></div>
<div class="block">Retrieves information about current memory usage and budget for all memory heaps.
 
 <p>This function is called "get" not "calculate" because it is very fast, suitable to be called every frame or every allocation. For more detailed
 statistics use <a href="#vmaCalculateStatistics(long,org.lwjgl.util.vma.VmaTotalStatistics)"><code>CalculateStatistics</code></a>.</p>
 
 <p>Note that when using allocator from multiple threads, returned information may immediately become outdated.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pBudget</code> - must point to array with number of elements at least equal to number of memory heaps in physical device used</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaFindMemoryTypeIndex(long,int,long,long)">
<h3>nvmaFindMemoryTypeIndex</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaFindMemoryTypeIndex</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;memoryTypeBits,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pMemoryTypeIndex)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndex</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFindMemoryTypeIndex(long,int,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">
<h3>vmaFindMemoryTypeIndex</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaFindMemoryTypeIndex</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;memoryTypeBits,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMemoryTypeIndex)</span></div>
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>memoryTypeBits</code> and <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.
 
 <p>This algorithm tries to find a memory type that:</p>
 
 <ul>
 <li>Is allowed by <code>memoryTypeBits</code>.</li>
 <li>Contains all the flags from <code>pAllocationCreateInfo-&gt;requiredFlags</code>.</li>
 <li>Matches intended usage.</li>
 <li>Has as many flags from <code>pAllocationCreateInfo-&gt;preferredFlags</code> as possible.</li>
 </ul></div>
<dl class="notes">
<dt>Returns:</dt>
<dd><code>VK_ERROR_FEATURE_NOT_PRESENT</code> if not found.
         
         <p>Receiving such result from this function or any other allocating function probably means that your device doesn't support any memory type with
         requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout
         (<code>OPTIMAL</code> versus LINEAR) or mip level count.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaFindMemoryTypeIndexForBufferInfo(long,long,long,long)">
<h3>nvmaFindMemoryTypeIndexForBufferInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaFindMemoryTypeIndexForBufferInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pMemoryTypeIndex)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForBufferInfo</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFindMemoryTypeIndexForBufferInfo(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">
<h3>vmaFindMemoryTypeIndexForBufferInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaFindMemoryTypeIndexForBufferInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMemoryTypeIndex)</span></div>
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkBufferCreateInfo</code> and <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.
 
 <p>It can be useful e.g. to determine value to be used as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::memoryTypeIndex</code>. It internally creates a temporary, dummy buffer
 that never has memory bound.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaFindMemoryTypeIndexForImageInfo(long,long,long,long)">
<h3>nvmaFindMemoryTypeIndexForImageInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaFindMemoryTypeIndexForImageInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pMemoryTypeIndex)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)"><code>FindMemoryTypeIndexForImageInfo</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFindMemoryTypeIndexForImageInfo(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.IntBuffer)">
<h3>vmaFindMemoryTypeIndexForImageInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaFindMemoryTypeIndexForImageInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMemoryTypeIndex)</span></div>
<div class="block">Helps to find <code>memoryTypeIndex</code>, given <code>VkImageCreateInfo</code> and <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocationCreateInfo</code></a>.
 
 <p>It can be useful e.g. to determine value to be used as <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaPoolCreateInfo</code></a><code>::memoryTypeIndex</code>. It internally creates a temporary, dummy image
 that never has memory bound.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaCreatePool(long,long,long)">
<h3>nvmaCreatePool</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreatePool</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pCreateInfo,
 long&nbsp;pPool)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)"><code>CreatePool</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreatePool(long,org.lwjgl.util.vma.VmaPoolCreateInfo,org.lwjgl.PointerBuffer)">
<h3>vmaCreatePool</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreatePool</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="VmaPoolCreateInfo.html" title="class in org.lwjgl.util.vma">VmaPoolCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pPool)</span></div>
<div class="block">Allocates Vulkan device memory and creates <code>VmaPool</code> object.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>pCreateInfo</code> - parameters of pool to create</dd>
<dd><code>pPool</code> - handle to created pool</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaDestroyPool(long,long)">
<h3>nvmaDestroyPool</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaDestroyPool</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool)</span></div>
<div class="block">Unsafe version of: <a href="#vmaDestroyPool(long,long)"><code>DestroyPool</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaDestroyPool(long,long)">
<h3>vmaDestroyPool</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaDestroyPool</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool)</span></div>
<div class="block">Destroys <code>VmaPool</code> object and frees Vulkan device memory.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetPoolStatistics(long,long,long)">
<h3>nvmaGetPoolStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetPoolStatistics</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;pPoolStats)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetPoolStatistics(long,long,org.lwjgl.util.vma.VmaStatistics)"><code>GetPoolStatistics</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetPoolStatistics(long,long,org.lwjgl.util.vma.VmaStatistics)">
<h3>vmaGetPoolStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetPoolStatistics</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="VmaStatistics.html" title="class in org.lwjgl.util.vma">VmaStatistics</a>&nbsp;pPoolStats)</span></div>
<div class="block">Retrieves statistics of existing VmaPool object.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>pool</code> - pool object</dd>
<dd><code>pPoolStats</code> - statistics of specified pool</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCalculatePoolStatistics(long,long,long)">
<h3>nvmaCalculatePoolStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaCalculatePoolStatistics</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;pPoolStats)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCalculatePoolStatistics(long,long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculatePoolStatistics</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCalculatePoolStatistics(long,long,org.lwjgl.util.vma.VmaDetailedStatistics)">
<h3>vmaCalculatePoolStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaCalculatePoolStatistics</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="VmaDetailedStatistics.html" title="class in org.lwjgl.util.vma">VmaDetailedStatistics</a>&nbsp;pPoolStats)</span></div>
<div class="block">Retrieves detailed statistics of existing <code>VmaPool</code> object.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>pool</code> - pool object</dd>
<dd><code>pPoolStats</code> - statistics of specified pool</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCheckPoolCorruption(long,long)">
<h3>nvmaCheckPoolCorruption</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCheckPoolCorruption</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCheckPoolCorruption(long,long)"><code>CheckPoolCorruption</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCheckPoolCorruption(long,long)">
<h3>vmaCheckPoolCorruption</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCheckPoolCorruption</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool)</span></div>
<div class="block">Checks magic number in margins around all allocations in given memory pool in search for corruptions.
 
 <p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to
 nonzero and the pool is created in memory type that is <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>.</p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>possible return values:
         
         <ul>
         <li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for specified pool.</li>
         <li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
         <li><code>VK_ERROR_UNKNOWN</code> - corruption detection has been performed and found memory corruptions around one of the allocations.
         <code>VMA_ASSERT</code> is also fired in that case.</li>
         <li>Other value: Error returned by Vulkan, e.g. memory mapping failure.</li>
         </ul></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaGetPoolName(long,long,long)">
<h3>nvmaGetPoolName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetPoolName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;ppName)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetPoolName(long,long,org.lwjgl.PointerBuffer)"><code>GetPoolName</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetPoolName(long,long,org.lwjgl.PointerBuffer)">
<h3>vmaGetPoolName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetPoolName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppName)</span></div>
<div class="block">Retrieves name of a custom pool.
 
 <p>After the call <code>ppName</code> is either null or points to an internally-owned null-terminated string containing name of the pool that was previously
 set. The pointer becomes invalid when the pool is destroyed or its name is changed using <a href="#vmaSetPoolName(long,long,java.nio.ByteBuffer)"><code>SetPoolName</code></a>.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaSetPoolName(long,long,long)">
<h3>nvmaSetPoolName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaSetPoolName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 long&nbsp;pName)</span></div>
<div class="block">Unsafe version of: <a href="#vmaSetPoolName(long,long,java.nio.ByteBuffer)"><code>SetPoolName</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaSetPoolName(long,long,java.nio.ByteBuffer)">
<h3>vmaSetPoolName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaSetPoolName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pName)</span></div>
<div class="block">Sets name of a custom pool.
 
 <p><code>pName</code> can be either null or pointer to a null-terminated string with new name for the pool. Function makes internal copy of the string, so it
 can be changed or freed immediately after this call.</p></div>
</section>
</li>
<li>
<section class="detail" id="vmaSetPoolName(long,long,java.lang.CharSequence)">
<h3>vmaSetPoolName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaSetPoolName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pool,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pName)</span></div>
<div class="block">Sets name of a custom pool.
 
 <p><code>pName</code> can be either null or pointer to a null-terminated string with new name for the pool. Function makes internal copy of the string, so it
 can be changed or freed immediately after this call.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaAllocateMemory(long,long,long,long,long)">
<h3>nvmaAllocateMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaAllocateMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pVkMemoryRequirements,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<h3>vmaAllocateMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaAllocateMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 @Nullable
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">General purpose memory allocation.
 
 <p>You should free the memory using <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> or <a href="#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a>.</p>
 
 <p>It is recommended to use <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>, <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a> instead whenever possible.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pAllocation</code> - handle to allocated memory</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaAllocateMemoryPages(long,long,long,long,long,long)">
<h3>nvmaAllocateMemoryPages</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaAllocateMemoryPages</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pVkMemoryRequirements,
 long&nbsp;pCreateInfo,
 long&nbsp;allocationCount,
 long&nbsp;pAllocations,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocationCount</code> - number of allocations to make</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)">
<h3>vmaAllocateMemoryPages</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaAllocateMemoryPages</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../vulkan/VkMemoryRequirements.html" title="class in org.lwjgl.vulkan">VkMemoryRequirements</a>&nbsp;pVkMemoryRequirements,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations,
 @Nullable
 <a href="VmaAllocationInfo.Buffer.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo.Buffer</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">General purpose memory allocation for multiple allocation objects at once.
 
 <p>You should free the memory using <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> or <a href="#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a>.</p>
 
 <p>Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation
 function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>
 <code>allocationCount</code> times.</p>
 
 <p>All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations
 already made within this function call are also freed, so that when returned result is not <code>VK_SUCCESS</code>, <code>pAllocation</code> array is always
 entirely filled with <code>VK_NULL_HANDLE</code>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>pVkMemoryRequirements</code> - memory requirements for each allocation</dd>
<dd><code>pCreateInfo</code> - creation parameters for each allocation</dd>
<dd><code>pAllocations</code> - pointer to array that will be filled with handles to created allocations</dd>
<dd><code>pAllocationInfo</code> - pointer to array that will be filled with parameters of created allocations. Optional.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaAllocateMemoryForBuffer(long,long,long,long,long)">
<h3>nvmaAllocateMemoryForBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaAllocateMemoryForBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;buffer,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<h3>vmaAllocateMemoryForBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaAllocateMemoryForBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;buffer,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 @Nullable
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">Allocates memory suitable for given <code>VkBuffer</code>.
 
 <p>It only creates <code>VmaAllocation</code>. To bind the memory to the buffer, use <a href="#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a>.</p>
 
 <p>This is a special-purpose function. In most cases you should use <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>.</p>
 
 <p>You must free the allocation using <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> when no longer needed.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pAllocation</code> - handle to allocated memory</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaAllocateMemoryForImage(long,long,long,long,long)">
<h3>nvmaAllocateMemoryForImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaAllocateMemoryForImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;image,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<h3>vmaAllocateMemoryForImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaAllocateMemoryForImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;image,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 @Nullable
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">Allocates memory suitable for given <code>VkImage</code>.
 
 <p>It only creates <code>VmaAllocation</code>. To bind the memory to the buffer, use <a href="#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a>.</p>
 
 <p>This is a special-purpose function. In most cases you should use <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>.</p>
 
 <p>You must free the allocation using <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> when no longer needed.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pAllocation</code> - handle to allocated memory</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaFreeMemory(long,long)">
<h3>nvmaFreeMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaFreeMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFreeMemory(long,long)">
<h3>vmaFreeMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaFreeMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation)</span></div>
<div class="block">Frees memory previously allocated using <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, <a href="#vmaAllocateMemoryForBuffer(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForBuffer</code></a>, or <a href="#vmaAllocateMemoryForImage(long,long,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemoryForImage</code></a>.
 
 <p>Passing <code>VK_NULL_HANDLE</code> as <code>allocation</code> is valid. Such function call is just skipped.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaFreeMemoryPages(long,long,long)">
<h3>nvmaFreeMemoryPages</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaFreeMemoryPages</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocationCount,
 long&nbsp;pAllocations)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)"><code>FreeMemoryPages</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFreeMemoryPages(long,org.lwjgl.PointerBuffer)">
<h3>vmaFreeMemoryPages</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaFreeMemoryPages</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocations)</span></div>
<div class="block">Frees memory and destroys multiple allocations.
 
 <p>Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free
 memory and destroy allocations made using e.g. <a href="#vmaAllocateMemory(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>AllocateMemory</code></a>, <a href="#vmaAllocateMemoryPages(long,org.lwjgl.vulkan.VkMemoryRequirements,org.lwjgl.util.vma.VmaAllocationCreateInfo,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo.Buffer)"><code>AllocateMemoryPages</code></a> and other functions. It may be internally optimized to be more
 efficient than calling <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a> <code>allocationCount</code> times.</p>
 
 <p>Allocations in <code>pAllocations</code> array can come from any memory pools and types. Passing <code>VK_NULL_HANDLE</code> as elements of <code>pAllocations</code>
 array is valid. Such entries are just skipped.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetAllocationInfo(long,long,long)">
<h3>nvmaGetAllocationInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetAllocationInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)">
<h3>vmaGetAllocationInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetAllocationInfo</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">Returns current information about specified allocation.
 
 <p>Current parameters of given allocation are returned in <code>pAllocationInfo</code>.</p>
 
 <p>Although this function doesn't lock any mutex, so it should be quite efficient, you should avoid calling it too often. You can retrieve same
 <code>VmaAllocationInfo</code> structure while creating your resource, from function <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>, <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a>. You can remember it if you are sure
 parameters don't change (e.g. due to defragmentation).</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaSetAllocationUserData(long,long,long)">
<h3>nvmaSetAllocationUserData</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaSetAllocationUserData</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pUserData)</span></div>
<div class="block">Unsafe version of: <a href="#vmaSetAllocationUserData(long,long,long)"><code>SetAllocationUserData</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaSetAllocationUserData(long,long,long)">
<h3>vmaSetAllocationUserData</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaSetAllocationUserData</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pUserData)</span></div>
<div class="block">Sets <code>pUserData</code> in given allocation to new value.
 
 <p>The value of pointer <code>pUserData</code> is copied to allocation's <code>pUserData</code>. It is opaque, so you can use it however you want - e.g. as a
 pointer, ordinal number or some handle to you own data.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaSetAllocationName(long,long,long)">
<h3>nvmaSetAllocationName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaSetAllocationName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pName)</span></div>
<div class="block">Unsafe version of: <a href="#vmaSetAllocationName(long,long,java.nio.ByteBuffer)"><code>SetAllocationName</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaSetAllocationName(long,long,java.nio.ByteBuffer)">
<h3>vmaSetAllocationName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaSetAllocationName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pName)</span></div>
<div class="block">Sets <code>pName</code> in given allocation to new value.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pName</code> - must be either null, or pointer to a null-terminated string.
              
              <p>The function makes local copy of the string and sets it as allocation's <code>pName</code>. String passed as <code>pName</code> doesn't need to be valid for
              whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation's <code>pName</code> is freed from memory.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="vmaSetAllocationName(long,long,java.lang.CharSequence)">
<h3>vmaSetAllocationName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaSetAllocationName</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pName)</span></div>
<div class="block">Sets <code>pName</code> in given allocation to new value.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pName</code> - must be either null, or pointer to a null-terminated string.
              
              <p>The function makes local copy of the string and sets it as allocation's <code>pName</code>. String passed as <code>pName</code> doesn't need to be valid for
              whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation's <code>pName</code> is freed from memory.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaGetAllocationMemoryProperties(long,long,long)">
<h3>nvmaGetAllocationMemoryProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetAllocationMemoryProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pFlags)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)"><code>GetAllocationMemoryProperties</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetAllocationMemoryProperties(long,long,java.nio.IntBuffer)">
<h3>vmaGetAllocationMemoryProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetAllocationMemoryProperties</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pFlags)</span></div>
<div class="block">Given an allocation, returns Property Flags of its memory type.
 
 <p>This is just a convenience function. Same information can be obtained using <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a> + <a href="#vmaGetMemoryProperties(long,org.lwjgl.PointerBuffer)"><code>GetMemoryProperties</code></a>.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaMapMemory(long,long,long)">
<h3>nvmaMapMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaMapMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;ppData)</span></div>
<div class="block">Unsafe version of: <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaMapMemory(long,long,org.lwjgl.PointerBuffer)">
<h3>vmaMapMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaMapMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppData)</span></div>
<div class="block">Maps memory represented by given allocation and returns pointer to it.
 
 <p>Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, <code>*ppData</code> contains pointer to first byte of this
 memory.</p>
 
 <p>If the allocation is part of a bigger <code>VkDeviceMemory</code> block, returned pointer is correctly offsetted to the beginning of region assigned to this
 particular allocation. Unlike the result of <code>vkMapMemory</code>, it points to the allocation, not to the beginning of the whole block. You should not
 add <code>VmaAllocationInfo::offset</code> to it!</p>
 
 <p>Mapping is internally reference-counted and synchronized, so despite raw Vulkan function <code>vkMapMemory()</code> cannot be used to map same block of
 <code>VkDeviceMemory</code> multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan
 memory will be mapped on first mapping and unmapped on last unmapping.</p>
 
 <p>If the function succeeded, you must call <a href="#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a> to unmap the allocation when mapping is no longer needed or before freeing the allocation, at
 the latest.</p>
 
 <p>It also safe to call this function multiple times on the same allocation. You must call <code>vmaUnmapMemory()</code> same number of times as you called
 <code>vmaMapMemory()</code>.</p>
 
 <p>It is also safe to call this function on allocation created with <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag. Its memory stays mapped all the time. You must
 still call <code>vmaUnmapMemory()</code> same number of times as you called <code>vmaMapMemory()</code>. You must not call <code>vmaUnmapMemory()</code> additional
 time to free the "0-th" mapping made automatically due to <a href="#VMA_ALLOCATION_CREATE_MAPPED_BIT"><code>ALLOCATION_CREATE_MAPPED_BIT</code></a> flag.</p>
 
 <p>This function fails when used on allocation made in memory type that is not <code>HOST_VISIBLE</code>.</p>
 
 <p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you
 also need to use <a href="#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a> / <a href="#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a>, as required by Vulkan specification.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaUnmapMemory(long,long)">
<h3>nvmaUnmapMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaUnmapMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation)</span></div>
<div class="block">Unsafe version of: <a href="#vmaUnmapMemory(long,long)"><code>UnmapMemory</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaUnmapMemory(long,long)">
<h3>vmaUnmapMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaUnmapMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation)</span></div>
<div class="block">Unmaps memory represented by given allocation, mapped previously using <a href="#vmaMapMemory(long,long,org.lwjgl.PointerBuffer)"><code>MapMemory</code></a>.
 
 <p>For details, see description of <code>vmaMapMemory()</code>.</p>
 
 <p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you
 also need to use <a href="#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a> / <a href="#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a>, as required by Vulkan specification.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaFlushAllocation(long,long,long,long)">
<h3>nvmaFlushAllocation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaFlushAllocation</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFlushAllocation(long,long,long,long)">
<h3>vmaFlushAllocation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaFlushAllocation</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</span></div>
<div class="block">Flushes memory of given allocation.
 
 <p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called after writing to a mapped
 memory for memory types that are not <code>HOST_COHERENT</code>. Unmap operation doesn't do that automatically.</p>
 
 <ul>
 <li><code>offset</code> must be relative to the beginning of allocation.</li>
 <li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
 <li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
 <li>If <code>size</code> is 0, this call is ignored.</li>
 <li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
 </ul>
 
 <p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and
 <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaInvalidateAllocation(long,long,long,long)">
<h3>nvmaInvalidateAllocation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaInvalidateAllocation</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</span></div>
<div class="block">Unsafe version of: <a href="#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaInvalidateAllocation(long,long,long,long)">
<h3>vmaInvalidateAllocation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaInvalidateAllocation</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;offset,
 long&nbsp;size)</span></div>
<div class="block">Invalidates memory of given allocation.
 
 <p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called before reading from a
 mapped memory for memory types that are not <code>HOST_COHERENT</code>. Map operation doesn't do that automatically.</p>
 
 <ul>
 <li><code>offset</code> must be relative to the beginning of allocation.</li>
 <li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
 <li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
 <li>If <code>size</code> is 0, this call is ignored.</li>
 <li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
 </ul>
 
 <p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and
 <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p>
 
 <p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaFlushAllocations(long,int,long,long,long)">
<h3>nvmaFlushAllocations</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaFlushAllocations</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;allocationCount,
 long&nbsp;allocations,
 long&nbsp;offsets,
 long&nbsp;sizes)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFlushAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)"><code>FlushAllocations</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFlushAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)">
<h3>vmaFlushAllocations</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaFlushAllocations</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;allocations,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;offsets,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;sizes)</span></div>
<div class="block">Flushes memory of given set of allocations.
 
 <p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a href="#vmaFlushAllocation(long,long,long,long)"><code>FlushAllocation</code></a>.</p>
 
 <p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>offsets</code> - If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero.</dd>
<dd><code>sizes</code> - If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaInvalidateAllocations(long,int,long,long,long)">
<h3>nvmaInvalidateAllocations</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaInvalidateAllocations</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;allocationCount,
 long&nbsp;allocations,
 long&nbsp;offsets,
 long&nbsp;sizes)</span></div>
<div class="block">Unsafe version of: <a href="#vmaInvalidateAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)"><code>InvalidateAllocations</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaInvalidateAllocations(long,org.lwjgl.PointerBuffer,java.nio.LongBuffer,java.nio.LongBuffer)">
<h3>vmaInvalidateAllocations</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaInvalidateAllocations</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;allocations,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;offsets,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;sizes)</span></div>
<div class="block">Invalidates memory of given set of allocations.
 
 <p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a href="#vmaInvalidateAllocation(long,long,long,long)"><code>InvalidateAllocation</code></a>.</p>
 
 <p>This function returns the <code>VkResult</code> from <code>vkInvalidateMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>offsets</code> - if not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets
                are zero.</dd>
<dd><code>sizes</code> - if not null, it must point to an array of sizes of regions to flush in respective allocations. Null means <code>VK_WHOLE_SIZE</code> for all
                allocations.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCheckCorruption(long,int)">
<h3>nvmaCheckCorruption</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCheckCorruption</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;memoryTypeBits)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCheckCorruption(long,int)"><code>CheckCorruption</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCheckCorruption(long,int)">
<h3>vmaCheckCorruption</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCheckCorruption</span><wbr><span class="parameters">(long&nbsp;allocator,
 int&nbsp;memoryTypeBits)</span></div>
<div class="block">Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.
 
 <p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to
 nonzero and only for memory types that are <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>memoryTypeBits</code> - bit mask, where each bit set means that a memory type with that index should be checked</dd>
<dt>Returns:</dt>
<dd>possible return values:
         
         <ul>
         <li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for any of specified memory types.</li>
         <li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
         <li><code>VK_ERROR_UNKNOWN</code> - corruption detection has been performed and found memory corruptions around one of the allocations.
         <code>VMA_ASSERT</code> is also fired in that case.</li>
         <li>Other value: Error returned by Vulkan, e.g. memory mapping failure.</li>
         </ul></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaBeginDefragmentation(long,long,long)">
<h3>nvmaBeginDefragmentation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaBeginDefragmentation</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pInfo,
 long&nbsp;pContext)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)"><code>BeginDefragmentation</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)">
<h3>vmaBeginDefragmentation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaBeginDefragmentation</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="VmaDefragmentationInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationInfo</a>&nbsp;pInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pContext)</span></div>
<div class="block">Begins defragmentation process.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>pInfo</code> - structure filled with parameters of defragmentation</dd>
<dd><code>pContext</code> - context object that must be passed to <a href="#vmaEndDefragmentation(long,long,org.lwjgl.util.vma.VmaDefragmentationStats)"><code>EndDefragmentation</code></a> to finish defragmentation</dd>
<dt>Returns:</dt>
<dd><code>VK_SUCCESS</code> if defragmentation can begin. <code>VK_ERROR_FEATURE_NOT_PRESENT</code> if defragmentation is not supported.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaEndDefragmentation(long,long,long)">
<h3>nvmaEndDefragmentation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaEndDefragmentation</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;context,
 long&nbsp;pStats)</span></div>
<div class="block">Unsafe version of: <a href="#vmaEndDefragmentation(long,long,org.lwjgl.util.vma.VmaDefragmentationStats)"><code>EndDefragmentation</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaEndDefragmentation(long,long,org.lwjgl.util.vma.VmaDefragmentationStats)">
<h3>vmaEndDefragmentation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaEndDefragmentation</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;context,
 @Nullable
 <a href="VmaDefragmentationStats.html" title="class in org.lwjgl.util.vma">VmaDefragmentationStats</a>&nbsp;pStats)</span></div>
<div class="block">Ends defragmentation process.
 
 <p>Use this function to finish defragmentation started by <a href="#vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)"><code>BeginDefragmentation</code></a>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>context</code> - context object that has been created by <a href="#vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)"><code>BeginDefragmentation</code></a></dd>
<dd><code>pStats</code> - optional stats for the defragmentation. Can be null.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaBeginDefragmentationPass(long,long,long)">
<h3>nvmaBeginDefragmentationPass</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaBeginDefragmentationPass</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;context,
 long&nbsp;pInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>BeginDefragmentationPass</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)">
<h3>vmaBeginDefragmentationPass</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaBeginDefragmentationPass</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;context,
 <a href="VmaDefragmentationPassMoveInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationPassMoveInfo</a>&nbsp;pInfo)</span></div>
<div class="block">Starts single defragmentation pass.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>context</code> - context object that has been created by <a href="#vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)"><code>BeginDefragmentation</code></a></dd>
<dd><code>pInfo</code> - computed information for current pass</dd>
<dt>Returns:</dt>
<dd><code>VK_SUCCESS</code> if no more moves are possible. Then you can omit call to <a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>EndDefragmentationPass</code></a> and simply end whole defragmentation.
         <code>VK_INCOMPLETE</code> if there are pending moves returned in <code>pPassInfo</code>. You need to perform them, call <code>vmaEndDefragmentationPass()</code>, and
         then preferably try another pass with <code>vmaBeginDefragmentationPass()</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaEndDefragmentationPass(long,long,long)">
<h3>nvmaEndDefragmentationPass</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaEndDefragmentationPass</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;context,
 long&nbsp;pPassInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>EndDefragmentationPass</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaEndDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)">
<h3>vmaEndDefragmentationPass</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaEndDefragmentationPass</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;context,
 <a href="VmaDefragmentationPassMoveInfo.html" title="class in org.lwjgl.util.vma">VmaDefragmentationPassMoveInfo</a>&nbsp;pPassInfo)</span></div>
<div class="block">Ends single defragmentation pass.
 
 <p>Ends incremental defragmentation pass and commits all defragmentation moves from <code>pPassInfo</code>.
 After this call:</p>
 
 <ul>
 <li>Allocations at <code>pPassInfo[i].srcAllocation</code> that had <code>pPassInfo[i].operation ==</code> <a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY"><code>DEFRAGMENTATION_MOVE_OPERATION_COPY</code></a> (which is the
 default) will be pointing to the new destination place.</li>
 <li>Allocation at <code>pPassInfo[i].srcAllocation</code> that had <code>pPassInfo[i].operation ==</code> <a href="#VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY"><code>DEFRAGMENTATION_MOVE_OPERATION_DESTROY</code></a> will be freed.</li>
 </ul>
 
 <p>If no more moves are possible you can end whole defragmentation.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator object</dd>
<dd><code>context</code> - context object that has been created by <a href="#vmaBeginDefragmentation(long,org.lwjgl.util.vma.VmaDefragmentationInfo,org.lwjgl.PointerBuffer)"><code>BeginDefragmentation</code></a></dd>
<dd><code>pPassInfo</code> - computed information for current pass filled by <a href="#vmaBeginDefragmentationPass(long,long,org.lwjgl.util.vma.VmaDefragmentationPassMoveInfo)"><code>BeginDefragmentationPass</code></a> and possibly modified by you</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaBindBufferMemory(long,long,long)">
<h3>nvmaBindBufferMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaBindBufferMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;buffer)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBindBufferMemory(long,long,long)">
<h3>vmaBindBufferMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaBindBufferMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;buffer)</span></div>
<div class="block">Binds buffer to allocation.
 
 <p>Binds specified buffer to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If
 you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard
 <code>vkBindBufferMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations,
 calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
 
 <p>It is recommended to use function <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> instead of this one.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaBindBufferMemory2(long,long,long,long,long)">
<h3>nvmaBindBufferMemory2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaBindBufferMemory2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;buffer,
 long&nbsp;pNext)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBindBufferMemory2(long,long,long,long,long)"><code>BindBufferMemory2</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBindBufferMemory2(long,long,long,long,long)">
<h3>vmaBindBufferMemory2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaBindBufferMemory2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;buffer,
 long&nbsp;pNext)</span></div>
<div class="block">Binds buffer to allocation with additional parameters.
 
 <p>This function is similar to <a href="#vmaBindBufferMemory(long,long,long)"><code>BindBufferMemory</code></a>, but it provides additional parameters.</p>
 
 <p>If <code>pNext</code> is not null, <code>VmaAllocator</code> object must have been created with <a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> flag or with
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion &gt;= VK_API_VERSION_1_1</code>. Otherwise the call fails.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocationLocalOffset</code> - additional offset to be added while binding, relative to the beginning of the <code>allocation</code>. Normally it should be 0.</dd>
<dd><code>pNext</code> - a chain of structures to be attached to <code>VkBindBufferMemoryInfoKHR</code> structure used internally. Normally it should be <code>null</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaBindImageMemory(long,long,long)">
<h3>nvmaBindImageMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaBindImageMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;image)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBindImageMemory(long,long,long)">
<h3>vmaBindImageMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaBindImageMemory</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;image)</span></div>
<div class="block">Binds image to allocation.
 
 <p>Binds specified image to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If
 you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard
 <code>vkBindImageMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations,
 calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
 
 <p>It is recommended to use function vmaCreateImage() instead of this one.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaBindImageMemory2(long,long,long,long,long)">
<h3>nvmaBindImageMemory2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaBindImageMemory2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;image,
 long&nbsp;pNext)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBindImageMemory2(long,long,long,long,long)"><code>BindImageMemory2</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBindImageMemory2(long,long,long,long,long)">
<h3>vmaBindImageMemory2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaBindImageMemory2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;image,
 long&nbsp;pNext)</span></div>
<div class="block">Binds image to allocation with additional parameters.
 
 <p>This function is similar to <a href="#vmaBindImageMemory(long,long,long)"><code>BindImageMemory</code></a>, but it provides additional parameters.</p>
 
 <p>If <code>pNext</code> is not null, <code>VmaAllocator</code> object must have been created with <a href="#VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT"><code>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</code></a> flag or with
 <a href="VmaAllocatorCreateInfo.html" title="class in org.lwjgl.util.vma"><code>VmaAllocatorCreateInfo</code></a><code>::vulkanApiVersion &gt;= VK_API_VERSION_1_1</code>. Otherwise the call fails.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocationLocalOffset</code> - additional offset to be added while binding, relative to the beginning of the <code>allocation</code>. Normally it should be 0.</dd>
<dd><code>pNext</code> - a chain of structures to be attached to <code>VkBindImageMemoryInfoKHR</code> structure used internally. Normally it should be null.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateBuffer(long,long,long,long,long,long)">
<h3>nvmaCreateBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pBuffer,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<h3>vmaCreateBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 @Nullable
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">Creates a new <code>VkBuffer</code>, allocates and binds memory for it.
 
 <p>This function automatically:</p>
 
 <ul>
 <li>Creates buffer.</li>
 <li>Allocates appropriate memory for it.</li>
 <li>Binds the buffer with the memory.</li>
 </ul>
 
 <p>If any of these operations fail, buffer and allocation are not created, returned value is negative error code, <code>*pBuffer</code> and
 <code>*pAllocation</code> are null.</p>
 
 <p>If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function <a href="#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>
 or separately, using <code>vkDestroyBuffer()</code> and <a href="#vmaFreeMemory(long,long)"><code>FreeMemory</code></a>.</p>
 
 <p>If <a href="#VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT"><code>ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</code></a> flag was used, <code>VK_KHR_dedicated_allocation</code> extension is used internally to query driver
 whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible
 (<a href="#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT"><code>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</code></a> is not used), it creates dedicated allocation for this buffer, just like when using
 <a href="#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"><code>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</code></a>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>This function creates a new <code>VkBuffer</code>. Sub-allocation of parts of one large buffer, although recommended as a good practice, is out of scope of
 this library and could be implemented by the user as a higher-level logic on top of VMA.</p>
 </div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pBuffer</code> - buffer that was created</dd>
<dd><code>pAllocation</code> - allocation that was created</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateBufferWithAlignment(long,long,long,long,long,long,long)">
<h3>nvmaCreateBufferWithAlignment</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateBufferWithAlignment</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;minAlignment,
 long&nbsp;pBuffer,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateBufferWithAlignment(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,long,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBufferWithAlignment</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateBufferWithAlignment(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,long,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<h3>vmaCreateBufferWithAlignment</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateBufferWithAlignment</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 long&nbsp;minAlignment,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 @Nullable
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">Similar to <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a> but provides additional parameter <code>minAlignment</code> which allows to specify custom, minimum alignment to be used when
 placing the buffer inside a larger memory block, which may be needed e.g. for interop with OpenGL.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>minAlignment</code> - custom, minimum alignment to be used when placing the buffer inside a larger memory block</dd>
<dd><code>pBuffer</code> - buffer that was created</dd>
<dd><code>pAllocation</code> - allocation that was created</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateAliasingBuffer(long,long,long,long)">
<h3>nvmaCreateAliasingBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateAliasingBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pBuffer)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingBuffer(long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateAliasingBuffer(long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)">
<h3>vmaCreateAliasingBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateAliasingBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer)</span></div>
<div class="block">Creates a new <code>VkBuffer</code>, binds already created memory for it.
 
 <p>This function automatically:</p>
 
 <ul>
 <li>Creates buffer.</li>
 <li>Binds the buffer with the supplied memory.</li>
 </ul>
 
 <p>If any of these operations fail, buffer is not created, returned value is negative error code and <code>*pBuffer</code> is null.</p>
 
 <p>If the function succeeded, you must destroy the buffer when you no longer need it using <code>vkDestroyBuffer()</code>. If you want to also destroy the
 corresponding allocation you can use convenience function <a href="#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>.</p>
 
 <p>Note: There is a new version of this function augmented with parameter <code>allocationLocalOffset</code> - see <a href="#vmaCreateAliasingBuffer2(long,long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer2</code></a>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator</dd>
<dd><code>allocation</code> - allocation that provides memory to be used for binding new buffer to it</dd>
<dd><code>pBuffer</code> - buffer that was created</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateAliasingBuffer2(long,long,long,long,long)">
<h3>nvmaCreateAliasingBuffer2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateAliasingBuffer2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;pBufferCreateInfo,
 long&nbsp;pBuffer)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingBuffer2(long,long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer2</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateAliasingBuffer2(long,long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)">
<h3>vmaCreateAliasingBuffer2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateAliasingBuffer2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 <a href="../../vulkan/VkBufferCreateInfo.html" title="class in org.lwjgl.vulkan">VkBufferCreateInfo</a>&nbsp;pBufferCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pBuffer)</span></div>
<div class="block">Creates a new <code>VkBuffer</code>, binds already created memory for it.
 
 <p>This function automatically:</p>
 
 <ul>
 <li>Creates buffer.</li>
 <li>Binds the buffer with the supplied memory.</li>
 </ul>
 
 <p>If any of these operations fail, buffer is not created, returned value is negative error code and <code>*pBuffer</code> is null.</p>
 
 <p>If the function succeeded, you must destroy the buffer when you no longer need it using <code>vkDestroyBuffer()</code>. If you want to also destroy the
 corresponding allocation you can use convenience function <a href="#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a>.</p>
 
 <p>Note: This is a new version of the function augmented with parameter <code>allocationLocalOffset</code>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>allocator</code> - allocator</dd>
<dd><code>allocation</code> - allocation that provides memory to be used for binding new buffer to it</dd>
<dd><code>allocationLocalOffset</code> - additional offset to be added while binding, relative to the beginning of the allocation. Normally it should be 0.</dd>
<dd><code>pBuffer</code> - buffer that was created</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaDestroyBuffer(long,long,long)">
<h3>nvmaDestroyBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaDestroyBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;buffer,
 long&nbsp;allocation)</span></div>
<div class="block">Unsafe version of: <a href="#vmaDestroyBuffer(long,long,long)"><code>DestroyBuffer</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaDestroyBuffer(long,long,long)">
<h3>vmaDestroyBuffer</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaDestroyBuffer</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;buffer,
 long&nbsp;allocation)</span></div>
<div class="block">Destroys Vulkan buffer and frees allocated memory.
 
 <p>This is just a convenience function equivalent to:</p>
 
 <pre><code>
 vkDestroyBuffer(device, buffer, allocationCallbacks);
 vmaFreeMemory(allocator, allocation);</code></pre>
 
 <p>It is safe to pass null as buffer and/or allocation.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateImage(long,long,long,long,long,long)">
<h3>nvmaCreateImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pAllocationCreateInfo,
 long&nbsp;pImage,
 long&nbsp;pAllocation,
 long&nbsp;pAllocationInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateImage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateImage(long,org.lwjgl.vulkan.VkImageCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)">
<h3>vmaCreateImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="VmaAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationCreateInfo</a>&nbsp;pAllocationCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pImage,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 @Nullable
 <a href="VmaAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaAllocationInfo</a>&nbsp;pAllocationInfo)</span></div>
<div class="block">Function similar to <a href="#vmaCreateBuffer(long,org.lwjgl.vulkan.VkBufferCreateInfo,org.lwjgl.util.vma.VmaAllocationCreateInfo,java.nio.LongBuffer,org.lwjgl.PointerBuffer,org.lwjgl.util.vma.VmaAllocationInfo)"><code>CreateBuffer</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pImage</code> - image that was created</dd>
<dd><code>pAllocation</code> - allocation that was created</dd>
<dd><code>pAllocationInfo</code> - information about allocated memory. Optional. It can be later fetched using function <a href="#vmaGetAllocationInfo(long,long,org.lwjgl.util.vma.VmaAllocationInfo)"><code>GetAllocationInfo</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateAliasingImage(long,long,long,long)">
<h3>nvmaCreateAliasingImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateAliasingImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pImage)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingImage(long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingImage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateAliasingImage(long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)">
<h3>vmaCreateAliasingImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateAliasingImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pImage)</span></div>
<div class="block">Function similar to <a href="#vmaCreateAliasingBuffer(long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer</code></a> but for images.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateAliasingImage2(long,long,long,long,long)">
<h3>nvmaCreateAliasingImage2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateAliasingImage2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 long&nbsp;pImageCreateInfo,
 long&nbsp;pImage)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateAliasingImage2(long,long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingImage2</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateAliasingImage2(long,long,long,org.lwjgl.vulkan.VkImageCreateInfo,java.nio.LongBuffer)">
<h3>vmaCreateAliasingImage2</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateAliasingImage2</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;allocation,
 long&nbsp;allocationLocalOffset,
 <a href="../../vulkan/VkImageCreateInfo.html" title="class in org.lwjgl.vulkan">VkImageCreateInfo</a>&nbsp;pImageCreateInfo,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pImage)</span></div>
<div class="block">Function similar to <a href="#vmaCreateAliasingBuffer2(long,long,long,org.lwjgl.vulkan.VkBufferCreateInfo,java.nio.LongBuffer)"><code>CreateAliasingBuffer2</code></a> but for images.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaDestroyImage(long,long,long)">
<h3>nvmaDestroyImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaDestroyImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;image,
 long&nbsp;allocation)</span></div>
<div class="block">Unsafe version of: <a href="#vmaDestroyImage(long,long,long)"><code>DestroyImage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaDestroyImage(long,long,long)">
<h3>vmaDestroyImage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaDestroyImage</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;image,
 long&nbsp;allocation)</span></div>
<div class="block">Destroys Vulkan image and frees allocated memory.
 
 <p>This is just a convenience function equivalent to:</p>
 
 <pre><code>
 vkDestroyImage(device, image, allocationCallbacks);
 vmaFreeMemory(allocator, allocation);</code></pre>
 
 <p>It is safe to pass null as image and/or allocation.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaCreateVirtualBlock(long,long)">
<h3>nvmaCreateVirtualBlock</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaCreateVirtualBlock</span><wbr><span class="parameters">(long&nbsp;pCreateInfo,
 long&nbsp;pVirtualBlock)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCreateVirtualBlock(org.lwjgl.util.vma.VmaVirtualBlockCreateInfo,org.lwjgl.PointerBuffer)"><code>CreateVirtualBlock</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCreateVirtualBlock(org.lwjgl.util.vma.VmaVirtualBlockCreateInfo,org.lwjgl.PointerBuffer)">
<h3>vmaCreateVirtualBlock</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaCreateVirtualBlock</span><wbr><span class="parameters">(<a href="VmaVirtualBlockCreateInfo.html" title="class in org.lwjgl.util.vma">VmaVirtualBlockCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pVirtualBlock)</span></div>
<div class="block">Creates new <code>VmaVirtualBlock</code> object.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pCreateInfo</code> - parameters for creation</dd>
<dd><code>pVirtualBlock</code> - returned virtual block object or <code>NULL</code> if creation failed</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaDestroyVirtualBlock(long)">
<h3>nvmaDestroyVirtualBlock</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaDestroyVirtualBlock</span><wbr><span class="parameters">(long&nbsp;virtualBlock)</span></div>
<div class="block">Unsafe version of: <a href="#vmaDestroyVirtualBlock(long)"><code>DestroyVirtualBlock</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaDestroyVirtualBlock(long)">
<h3>vmaDestroyVirtualBlock</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaDestroyVirtualBlock</span><wbr><span class="parameters">(long&nbsp;virtualBlock)</span></div>
<div class="block">Destroys <code>VmaVirtualBlock</code> object.
 
 <p>Please note that you should consciously handle virtual allocations that could remain unfreed in the block. You should either free them individually
 using <a href="#vmaVirtualFree(long,long)"><code>VirtualFree</code></a> or call <a href="#vmaClearVirtualBlock(long)"><code>ClearVirtualBlock</code></a> if you are sure this is what you want. If you do neither, an assert is called.</p>
 
 <p>If you keep pointers to some additional metadata associated with your virtual allocations in their <code>pUserData</code>, don't forget to free them.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaIsVirtualBlockEmpty(long)">
<h3>nvmaIsVirtualBlockEmpty</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaIsVirtualBlockEmpty</span><wbr><span class="parameters">(long&nbsp;virtualBlock)</span></div>
<div class="block">Unsafe version of: <a href="#vmaIsVirtualBlockEmpty(long)"><code>IsVirtualBlockEmpty</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaIsVirtualBlockEmpty(long)">
<h3>vmaIsVirtualBlockEmpty</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">vmaIsVirtualBlockEmpty</span><wbr><span class="parameters">(long&nbsp;virtualBlock)</span></div>
<div class="block">Returns true of the <code>VmaVirtualBlock</code> is empty - contains 0 virtual allocations and has all its space available for new allocations.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetVirtualAllocationInfo(long,long,long)">
<h3>nvmaGetVirtualAllocationInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetVirtualAllocationInfo</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 long&nbsp;pVirtualAllocInfo)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetVirtualAllocationInfo(long,long,org.lwjgl.util.vma.VmaVirtualAllocationInfo)"><code>GetVirtualAllocationInfo</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetVirtualAllocationInfo(long,long,org.lwjgl.util.vma.VmaVirtualAllocationInfo)">
<h3>vmaGetVirtualAllocationInfo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetVirtualAllocationInfo</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 <a href="VmaVirtualAllocationInfo.html" title="class in org.lwjgl.util.vma">VmaVirtualAllocationInfo</a>&nbsp;pVirtualAllocInfo)</span></div>
<div class="block">Returns information about a specific virtual allocation within a virtual block, like its size and <code>pUserData</code> pointer.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaVirtualAllocate(long,long,long,long)">
<h3>nvmaVirtualAllocate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nvmaVirtualAllocate</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;pCreateInfo,
 long&nbsp;pAllocation,
 long&nbsp;pOffset)</span></div>
<div class="block">Unsafe version of: <a href="#vmaVirtualAllocate(long,org.lwjgl.util.vma.VmaVirtualAllocationCreateInfo,org.lwjgl.PointerBuffer,java.nio.LongBuffer)"><code>VirtualAllocate</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaVirtualAllocate(long,org.lwjgl.util.vma.VmaVirtualAllocationCreateInfo,org.lwjgl.PointerBuffer,java.nio.LongBuffer)">
<h3>vmaVirtualAllocate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">vmaVirtualAllocate</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 <a href="VmaVirtualAllocationCreateInfo.html" title="class in org.lwjgl.util.vma">VmaVirtualAllocationCreateInfo</a>&nbsp;pCreateInfo,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pAllocation,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/LongBuffer.html" title="class or interface in java.nio" class="external-link">LongBuffer</a>&nbsp;pOffset)</span></div>
<div class="block">Allocates new virtual allocation inside given <code>VmaVirtualBlock</code>.
 
 <p>If the allocation fails due to not enough free space available, <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> is returned (despite the function doesn't ever
 allocate actual GPU memory). <code>pAllocation</code> is then set to <code>VK_NULL_HANDLE</code> and <code>pOffset</code>, if not null, it set to <code>UINT64_MAX</code>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>virtualBlock</code> - virtual block</dd>
<dd><code>pCreateInfo</code> - parameters for the allocation</dd>
<dd><code>pOffset</code> - returned offset of the new allocation. Optional, can be null.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaVirtualFree(long,long)">
<h3>nvmaVirtualFree</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaVirtualFree</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;allocation)</span></div>
<div class="block">Unsafe version of: <a href="#vmaVirtualFree(long,long)"><code>VirtualFree</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaVirtualFree(long,long)">
<h3>vmaVirtualFree</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaVirtualFree</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;allocation)</span></div>
<div class="block">Frees virtual allocation inside given <code>VmaVirtualBlock</code>.
 
 <p>It is correct to call this function with <code>allocation == VK_NULL_HANDLE</code> - it does nothing.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaClearVirtualBlock(long)">
<h3>nvmaClearVirtualBlock</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaClearVirtualBlock</span><wbr><span class="parameters">(long&nbsp;virtualBlock)</span></div>
<div class="block">Unsafe version of: <a href="#vmaClearVirtualBlock(long)"><code>ClearVirtualBlock</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaClearVirtualBlock(long)">
<h3>vmaClearVirtualBlock</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaClearVirtualBlock</span><wbr><span class="parameters">(long&nbsp;virtualBlock)</span></div>
<div class="block">Frees all virtual allocations inside given <code>VmaVirtualBlock</code>.
 
 <p>You must either call this function or free each virtual allocation individually with <a href="#vmaVirtualFree(long,long)"><code>VirtualFree</code></a> before destroying a virtual block. Otherwise, an
 assert is called.</p>
 
 <p>If you keep pointer to some additional metadata associated with your virtual allocation in its <code>pUserData</code>, don't forget to free it as well.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaSetVirtualAllocationUserData(long,long,long)">
<h3>nvmaSetVirtualAllocationUserData</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaSetVirtualAllocationUserData</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 long&nbsp;pUserData)</span></div>
<div class="block">Unsafe version of: <a href="#vmaSetVirtualAllocationUserData(long,long,long)"><code>SetVirtualAllocationUserData</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaSetVirtualAllocationUserData(long,long,long)">
<h3>vmaSetVirtualAllocationUserData</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaSetVirtualAllocationUserData</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;allocation,
 long&nbsp;pUserData)</span></div>
<div class="block">Changes custom pointer associated with given virtual allocation.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaGetVirtualBlockStatistics(long,long)">
<h3>nvmaGetVirtualBlockStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaGetVirtualBlockStatistics</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;pStats)</span></div>
<div class="block">Unsafe version of: <a href="#vmaGetVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaStatistics)"><code>GetVirtualBlockStatistics</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaGetVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaStatistics)">
<h3>vmaGetVirtualBlockStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaGetVirtualBlockStatistics</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 <a href="VmaStatistics.html" title="class in org.lwjgl.util.vma">VmaStatistics</a>&nbsp;pStats)</span></div>
<div class="block">Calculates and returns statistics about virtual allocations and memory usage in given <code>VmaVirtualBlock</code>.
 
 <p>This function is fast to call. For more detailed statistics, see <a href="#vmaCalculateVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculateVirtualBlockStatistics</code></a>.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaCalculateVirtualBlockStatistics(long,long)">
<h3>nvmaCalculateVirtualBlockStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaCalculateVirtualBlockStatistics</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;pStats)</span></div>
<div class="block">Unsafe version of: <a href="#vmaCalculateVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculateVirtualBlockStatistics</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaCalculateVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaDetailedStatistics)">
<h3>vmaCalculateVirtualBlockStatistics</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaCalculateVirtualBlockStatistics</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 <a href="VmaDetailedStatistics.html" title="class in org.lwjgl.util.vma">VmaDetailedStatistics</a>&nbsp;pStats)</span></div>
<div class="block">Calculates and returns detailed statistics about virtual allocations and memory usage in given <code>VmaVirtualBlock</code>.
 
 <p>This function is slow to call. Use for debugging purposes. For less detailed statistics, see <a href="#vmaGetVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaStatistics)"><code>GetVirtualBlockStatistics</code></a>.</p></div>
</section>
</li>
<li>
<section class="detail" id="nvmaBuildVirtualBlockStatsString(long,long,int)">
<h3>nvmaBuildVirtualBlockStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaBuildVirtualBlockStatsString</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;ppStatsString,
 int&nbsp;detailedMap)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBuildVirtualBlockStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildVirtualBlockStatsString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBuildVirtualBlockStatsString(long,org.lwjgl.PointerBuffer,boolean)">
<h3>vmaBuildVirtualBlockStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaBuildVirtualBlockStatsString</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppStatsString,
 boolean&nbsp;detailedMap)</span></div>
<div class="block">Builds and returns a null-terminated string in JSON format with information about given <code>VmaVirtualBlock</code>.
 
 <p>Returned string must be freed using <a href="#vmaFreeVirtualBlockStatsString(long,java.nio.ByteBuffer)"><code>FreeVirtualBlockStatsString</code></a>.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>virtualBlock</code> - virtual block</dd>
<dd><code>ppStatsString</code> - returned string</dd>
<dd><code>detailedMap</code> - pass <code>VK_FALSE</code> to only obtain statistics as returned by <a href="#vmaCalculateVirtualBlockStatistics(long,org.lwjgl.util.vma.VmaDetailedStatistics)"><code>CalculateVirtualBlockStatistics</code></a>. Pass <code>VK_TRUE</code> to also obtain full list of
                      allocations and free spaces.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaFreeVirtualBlockStatsString(long,long)">
<h3>nvmaFreeVirtualBlockStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaFreeVirtualBlockStatsString</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 long&nbsp;pStatsString)</span></div>
<div class="block">Unsafe version of: <a href="#vmaFreeVirtualBlockStatsString(long,java.nio.ByteBuffer)"><code>FreeVirtualBlockStatsString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaFreeVirtualBlockStatsString(long,java.nio.ByteBuffer)">
<h3>vmaFreeVirtualBlockStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaFreeVirtualBlockStatsString</span><wbr><span class="parameters">(long&nbsp;virtualBlock,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pStatsString)</span></div>
<div class="block">Frees a string returned by <a href="#vmaBuildVirtualBlockStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildVirtualBlockStatsString</code></a>.</div>
</section>
</li>
<li>
<section class="detail" id="nvmaBuildStatsString(long,long,int)">
<h3>nvmaBuildStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaBuildStatsString</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;ppStatsString,
 int&nbsp;detailedMap)</span></div>
<div class="block">Unsafe version of: <a href="#vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)"><code>BuildStatsString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="vmaBuildStatsString(long,org.lwjgl.PointerBuffer,boolean)">
<h3>vmaBuildStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaBuildStatsString</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="../../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;ppStatsString,
 boolean&nbsp;detailedMap)</span></div>
<div class="block">Builds and returns statistics as a null-terminated string in JSON format.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>ppStatsString</code> - must be freed using <a href="#vmaFreeStatsString(long,java.nio.ByteBuffer)"><code>FreeStatsString</code></a> function</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nvmaFreeStatsString(long,long)">
<h3>nvmaFreeStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nvmaFreeStatsString</span><wbr><span class="parameters">(long&nbsp;allocator,
 long&nbsp;pStatsString)</span></div>
</section>
</li>
<li>
<section class="detail" id="vmaFreeStatsString(long,java.nio.ByteBuffer)">
<h3>vmaFreeStatsString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">vmaFreeStatsString</span><wbr><span class="parameters">(long&nbsp;allocator,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pStatsString)</span></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</div>
</div>
</body>
</html>
