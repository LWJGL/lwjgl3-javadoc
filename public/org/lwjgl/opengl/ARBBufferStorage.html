<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) -->
<title>ARBBufferStorage (LWJGL 3.3.2-snapshot)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.lwjgl.opengl, class: ARBBufferStorage">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li><a href="#field-summary">Field</a></li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.lwjgl.opengl</a></div>
<h1 title="Class ARBBufferStorage" class="title">Class ARBBufferStorage</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.lwjgl.opengl.ARBBufferStorage</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">ARBBufferStorage</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Native bindings to the <a target="_blank" href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_buffer_storage.txt">ARB_buffer_storage</a> extension.
 
 <p>OpenGL has long supported buffer objects as a means of storing data that may be used to source vertex attributes, pixel data for textures, uniforms and
 other elements. In un-extended GL, buffer data stores are mutable - that is, they may be de-allocated or resized while they are in use. The
 <a href="ARBTextureStorage.html" title="class in org.lwjgl.opengl"><code>ARB_texture_storage</code></a> extension added immutable storage for texture object (and was subsequently incorporated into OpenGL 4.2). This extension
 further applies the concept of immutable storage to buffer objects. If an implementation is aware of a buffer's immutability, it may be able to make
 certain assumptions or apply particular optimizations in order to increase performance or reliability.</p>
 
 <p>Furthermore, this extension allows applications to pass additional information about a requested allocation to the implementation which it may use to
 select memory heaps, caching behavior or allocation strategies.</p>
 
 <p>Finally, this extension introduces the concept of persistent client mappings of buffer objects, which allow clients to retain pointers to a buffer's
 data store returned as the result of a mapping, and to issue drawing commands while those mappings are in place.</p>
 
 <p>Promoted to core in <a href="GL44.html" title="class in org.lwjgl.opengl"><code>OpenGL 4.4</code></a>.</p></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#GL_BUFFER_IMMUTABLE_STORAGE" class="member-name-link">GL_BUFFER_IMMUTABLE_STORAGE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Accepted by the <code>pname</code> parameter of <code>GetBufferParameter&amp;#123;i|i64&amp;#125;v</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#GL_BUFFER_STORAGE_FLAGS" class="member-name-link">GL_BUFFER_STORAGE_FLAGS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Accepted by the <code>pname</code> parameter of <code>GetBufferParameter&amp;#123;i|i64&amp;#125;v</code>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT" class="member-name-link">GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Accepted by the <code>barriers</code> parameter of <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#GL_CLIENT_STORAGE_BIT" class="member-name-link">GL_CLIENT_STORAGE_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#GL_DYNAMIC_STORAGE_BIT" class="member-name-link">GL_DYNAMIC_STORAGE_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#GL_MAP_COHERENT_BIT" class="member-name-link">GL_MAP_COHERENT_BIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#GL_MAP_PERSISTENT_BIT" class="member-name-link">GL_MAP_PERSISTENT_BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,double%5B%5D,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 double[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,float%5B%5D,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 float[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,int%5B%5D,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 int[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,long,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 long&nbsp;size,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates the data store of a buffer object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,short%5B%5D,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 short[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,java.nio.ByteBuffer,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates the data store of a buffer object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,java.nio.DoubleBuffer,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/DoubleBuffer.html" title="class or interface in java.nio" class="external-link">DoubleBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates the data store of a buffer object.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,java.nio.FloatBuffer,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates the data store of a buffer object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,java.nio.IntBuffer,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates the data store of a buffer object.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glBufferStorage(int,java.nio.ShortBuffer,int)" class="member-name-link">glBufferStorage</a><wbr>(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ShortBuffer.html" title="class or interface in java.nio" class="external-link">ShortBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates the data store of a buffer object.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,double%5B%5D,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 double[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,float%5B%5D,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 float[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,int%5B%5D,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 int[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,long,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 long&nbsp;size,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,short%5B%5D,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 short[]&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,java.nio.ByteBuffer,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,java.nio.DoubleBuffer,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/DoubleBuffer.html" title="class or interface in java.nio" class="external-link">DoubleBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,java.nio.FloatBuffer,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,java.nio.IntBuffer,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#glNamedBufferStorageEXT(int,java.nio.ShortBuffer,int)" class="member-name-link">glNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ShortBuffer.html" title="class or interface in java.nio" class="external-link">ShortBuffer</a>&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nglBufferStorage(int,long,long,int)" class="member-name-link">nglBufferStorage</a><wbr>(int&nbsp;target,
 long&nbsp;size,
 long&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#nglNamedBufferStorageEXT(int,long,long,int)" class="member-name-link">nglNamedBufferStorageEXT</a><wbr>(int&nbsp;buffer,
 long&nbsp;size,
 long&nbsp;data,
 int&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="GL_MAP_PERSISTENT_BIT">
<h3>GL_MAP_PERSISTENT_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">GL_MAP_PERSISTENT_BIT</span></div>
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.opengl.ARBBufferStorage.GL_MAP_PERSISTENT_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="GL_MAP_COHERENT_BIT">
<h3>GL_MAP_COHERENT_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">GL_MAP_COHERENT_BIT</span></div>
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.opengl.ARBBufferStorage.GL_MAP_COHERENT_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="GL_DYNAMIC_STORAGE_BIT">
<h3>GL_DYNAMIC_STORAGE_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">GL_DYNAMIC_STORAGE_BIT</span></div>
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.opengl.ARBBufferStorage.GL_DYNAMIC_STORAGE_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="GL_CLIENT_STORAGE_BIT">
<h3>GL_CLIENT_STORAGE_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">GL_CLIENT_STORAGE_BIT</span></div>
<div class="block">Accepted in the <code>flags</code> parameter of <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a> and <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.opengl.ARBBufferStorage.GL_CLIENT_STORAGE_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="GL_BUFFER_IMMUTABLE_STORAGE">
<h3>GL_BUFFER_IMMUTABLE_STORAGE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">GL_BUFFER_IMMUTABLE_STORAGE</span></div>
<div class="block">Accepted by the <code>pname</code> parameter of <code>GetBufferParameter&amp;#123;i|i64&amp;#125;v</code>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.opengl.ARBBufferStorage.GL_BUFFER_IMMUTABLE_STORAGE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="GL_BUFFER_STORAGE_FLAGS">
<h3>GL_BUFFER_STORAGE_FLAGS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">GL_BUFFER_STORAGE_FLAGS</span></div>
<div class="block">Accepted by the <code>pname</code> parameter of <code>GetBufferParameter&amp;#123;i|i64&amp;#125;v</code>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.opengl.ARBBufferStorage.GL_BUFFER_STORAGE_FLAGS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT">
<h3>GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT</span></div>
<div class="block">Accepted by the <code>barriers</code> parameter of <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a>.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.opengl.ARBBufferStorage.GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="nglBufferStorage(int,long,long,int)">
<h3>nglBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nglBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 long&nbsp;size,
 long&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Unsafe version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>size</code> - the size of the data store in basic machine units</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,long,int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 long&nbsp;size,
 int&nbsp;flags)</span></div>
<div class="block">Creates the data store of a buffer object.
 
 <p>The data store of the buffer object bound to <code>target</code> is allocated as a result of a call to this function and cannot be de-allocated until the
 buffer is deleted with a call to <a href="GL15C.html#glDeleteBuffers(java.nio.IntBuffer)"><code>DeleteBuffers</code></a>. Such a store may not be re-allocated through further calls to <code>BufferStorage</code>
 or <a href="GL15C.html#glBufferData(int,long,int)"><code>BufferData</code></a>.</p>
 
 <p><code>BufferStorage</code> deletes any existing data store. If any portion of the buffer object is mapped in the current context or any context current to
 another thread, it is as though <a href="GL15C.html#glUnmapBuffer(int)"><code>UnmapBuffer</code></a> is executed in each such context prior to deleting the existing data store.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the buffer object target. One of:<br><table><tr><td><a href="GL15.html#GL_ARRAY_BUFFER"><code>ARRAY_BUFFER</code></a></td><td><a href="GL15.html#GL_ELEMENT_ARRAY_BUFFER"><code>ELEMENT_ARRAY_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_PACK_BUFFER"><code>PIXEL_PACK_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_UNPACK_BUFFER"><code>PIXEL_UNPACK_BUFFER</code></a></td></tr><tr><td><a href="GL30.html#GL_TRANSFORM_FEEDBACK_BUFFER"><code>TRANSFORM_FEEDBACK_BUFFER</code></a></td><td><a href="GL31.html#GL_UNIFORM_BUFFER"><code>UNIFORM_BUFFER</code></a></td><td><a href="GL31.html#GL_TEXTURE_BUFFER"><code>TEXTURE_BUFFER</code></a></td><td><a href="GL31.html#GL_COPY_READ_BUFFER"><code>COPY_READ_BUFFER</code></a></td></tr><tr><td><a href="GL31.html#GL_COPY_WRITE_BUFFER"><code>COPY_WRITE_BUFFER</code></a></td><td><a href="GL40.html#GL_DRAW_INDIRECT_BUFFER"><code>DRAW_INDIRECT_BUFFER</code></a></td><td><a href="GL42.html#GL_ATOMIC_COUNTER_BUFFER"><code>ATOMIC_COUNTER_BUFFER</code></a></td><td><a href="GL43.html#GL_DISPATCH_INDIRECT_BUFFER"><code>DISPATCH_INDIRECT_BUFFER</code></a></td></tr><tr><td><a href="GL43.html#GL_SHADER_STORAGE_BUFFER"><code>SHADER_STORAGE_BUFFER</code></a></td><td><a href="ARBIndirectParameters.html#GL_PARAMETER_BUFFER_ARB"><code>PARAMETER_BUFFER_ARB</code></a></td></tr></table></dd>
<dd><code>size</code> - the size of the data store in basic machine units</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="GL44C.html#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,java.nio.ByteBuffer,int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Creates the data store of a buffer object.
 
 <p>The data store of the buffer object bound to <code>target</code> is allocated as a result of a call to this function and cannot be de-allocated until the
 buffer is deleted with a call to <a href="GL15C.html#glDeleteBuffers(java.nio.IntBuffer)"><code>DeleteBuffers</code></a>. Such a store may not be re-allocated through further calls to <code>BufferStorage</code>
 or <a href="GL15C.html#glBufferData(int,long,int)"><code>BufferData</code></a>.</p>
 
 <p><code>BufferStorage</code> deletes any existing data store. If any portion of the buffer object is mapped in the current context or any context current to
 another thread, it is as though <a href="GL15C.html#glUnmapBuffer(int)"><code>UnmapBuffer</code></a> is executed in each such context prior to deleting the existing data store.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the buffer object target. One of:<br><table><tr><td><a href="GL15.html#GL_ARRAY_BUFFER"><code>ARRAY_BUFFER</code></a></td><td><a href="GL15.html#GL_ELEMENT_ARRAY_BUFFER"><code>ELEMENT_ARRAY_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_PACK_BUFFER"><code>PIXEL_PACK_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_UNPACK_BUFFER"><code>PIXEL_UNPACK_BUFFER</code></a></td></tr><tr><td><a href="GL30.html#GL_TRANSFORM_FEEDBACK_BUFFER"><code>TRANSFORM_FEEDBACK_BUFFER</code></a></td><td><a href="GL31.html#GL_UNIFORM_BUFFER"><code>UNIFORM_BUFFER</code></a></td><td><a href="GL31.html#GL_TEXTURE_BUFFER"><code>TEXTURE_BUFFER</code></a></td><td><a href="GL31.html#GL_COPY_READ_BUFFER"><code>COPY_READ_BUFFER</code></a></td></tr><tr><td><a href="GL31.html#GL_COPY_WRITE_BUFFER"><code>COPY_WRITE_BUFFER</code></a></td><td><a href="GL40.html#GL_DRAW_INDIRECT_BUFFER"><code>DRAW_INDIRECT_BUFFER</code></a></td><td><a href="GL42.html#GL_ATOMIC_COUNTER_BUFFER"><code>ATOMIC_COUNTER_BUFFER</code></a></td><td><a href="GL43.html#GL_DISPATCH_INDIRECT_BUFFER"><code>DISPATCH_INDIRECT_BUFFER</code></a></td></tr><tr><td><a href="GL43.html#GL_SHADER_STORAGE_BUFFER"><code>SHADER_STORAGE_BUFFER</code></a></td><td><a href="ARBIndirectParameters.html#GL_PARAMETER_BUFFER_ARB"><code>PARAMETER_BUFFER_ARB</code></a></td></tr></table></dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="GL44C.html#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,java.nio.ShortBuffer,int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ShortBuffer.html" title="class or interface in java.nio" class="external-link">ShortBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Creates the data store of a buffer object.
 
 <p>The data store of the buffer object bound to <code>target</code> is allocated as a result of a call to this function and cannot be de-allocated until the
 buffer is deleted with a call to <a href="GL15C.html#glDeleteBuffers(java.nio.IntBuffer)"><code>DeleteBuffers</code></a>. Such a store may not be re-allocated through further calls to <code>BufferStorage</code>
 or <a href="GL15C.html#glBufferData(int,long,int)"><code>BufferData</code></a>.</p>
 
 <p><code>BufferStorage</code> deletes any existing data store. If any portion of the buffer object is mapped in the current context or any context current to
 another thread, it is as though <a href="GL15C.html#glUnmapBuffer(int)"><code>UnmapBuffer</code></a> is executed in each such context prior to deleting the existing data store.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the buffer object target. One of:<br><table><tr><td><a href="GL15.html#GL_ARRAY_BUFFER"><code>ARRAY_BUFFER</code></a></td><td><a href="GL15.html#GL_ELEMENT_ARRAY_BUFFER"><code>ELEMENT_ARRAY_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_PACK_BUFFER"><code>PIXEL_PACK_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_UNPACK_BUFFER"><code>PIXEL_UNPACK_BUFFER</code></a></td></tr><tr><td><a href="GL30.html#GL_TRANSFORM_FEEDBACK_BUFFER"><code>TRANSFORM_FEEDBACK_BUFFER</code></a></td><td><a href="GL31.html#GL_UNIFORM_BUFFER"><code>UNIFORM_BUFFER</code></a></td><td><a href="GL31.html#GL_TEXTURE_BUFFER"><code>TEXTURE_BUFFER</code></a></td><td><a href="GL31.html#GL_COPY_READ_BUFFER"><code>COPY_READ_BUFFER</code></a></td></tr><tr><td><a href="GL31.html#GL_COPY_WRITE_BUFFER"><code>COPY_WRITE_BUFFER</code></a></td><td><a href="GL40.html#GL_DRAW_INDIRECT_BUFFER"><code>DRAW_INDIRECT_BUFFER</code></a></td><td><a href="GL42.html#GL_ATOMIC_COUNTER_BUFFER"><code>ATOMIC_COUNTER_BUFFER</code></a></td><td><a href="GL43.html#GL_DISPATCH_INDIRECT_BUFFER"><code>DISPATCH_INDIRECT_BUFFER</code></a></td></tr><tr><td><a href="GL43.html#GL_SHADER_STORAGE_BUFFER"><code>SHADER_STORAGE_BUFFER</code></a></td><td><a href="ARBIndirectParameters.html#GL_PARAMETER_BUFFER_ARB"><code>PARAMETER_BUFFER_ARB</code></a></td></tr></table></dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="GL44C.html#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,java.nio.IntBuffer,int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Creates the data store of a buffer object.
 
 <p>The data store of the buffer object bound to <code>target</code> is allocated as a result of a call to this function and cannot be de-allocated until the
 buffer is deleted with a call to <a href="GL15C.html#glDeleteBuffers(java.nio.IntBuffer)"><code>DeleteBuffers</code></a>. Such a store may not be re-allocated through further calls to <code>BufferStorage</code>
 or <a href="GL15C.html#glBufferData(int,long,int)"><code>BufferData</code></a>.</p>
 
 <p><code>BufferStorage</code> deletes any existing data store. If any portion of the buffer object is mapped in the current context or any context current to
 another thread, it is as though <a href="GL15C.html#glUnmapBuffer(int)"><code>UnmapBuffer</code></a> is executed in each such context prior to deleting the existing data store.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the buffer object target. One of:<br><table><tr><td><a href="GL15.html#GL_ARRAY_BUFFER"><code>ARRAY_BUFFER</code></a></td><td><a href="GL15.html#GL_ELEMENT_ARRAY_BUFFER"><code>ELEMENT_ARRAY_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_PACK_BUFFER"><code>PIXEL_PACK_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_UNPACK_BUFFER"><code>PIXEL_UNPACK_BUFFER</code></a></td></tr><tr><td><a href="GL30.html#GL_TRANSFORM_FEEDBACK_BUFFER"><code>TRANSFORM_FEEDBACK_BUFFER</code></a></td><td><a href="GL31.html#GL_UNIFORM_BUFFER"><code>UNIFORM_BUFFER</code></a></td><td><a href="GL31.html#GL_TEXTURE_BUFFER"><code>TEXTURE_BUFFER</code></a></td><td><a href="GL31.html#GL_COPY_READ_BUFFER"><code>COPY_READ_BUFFER</code></a></td></tr><tr><td><a href="GL31.html#GL_COPY_WRITE_BUFFER"><code>COPY_WRITE_BUFFER</code></a></td><td><a href="GL40.html#GL_DRAW_INDIRECT_BUFFER"><code>DRAW_INDIRECT_BUFFER</code></a></td><td><a href="GL42.html#GL_ATOMIC_COUNTER_BUFFER"><code>ATOMIC_COUNTER_BUFFER</code></a></td><td><a href="GL43.html#GL_DISPATCH_INDIRECT_BUFFER"><code>DISPATCH_INDIRECT_BUFFER</code></a></td></tr><tr><td><a href="GL43.html#GL_SHADER_STORAGE_BUFFER"><code>SHADER_STORAGE_BUFFER</code></a></td><td><a href="ARBIndirectParameters.html#GL_PARAMETER_BUFFER_ARB"><code>PARAMETER_BUFFER_ARB</code></a></td></tr></table></dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="GL44C.html#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,java.nio.FloatBuffer,int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Creates the data store of a buffer object.
 
 <p>The data store of the buffer object bound to <code>target</code> is allocated as a result of a call to this function and cannot be de-allocated until the
 buffer is deleted with a call to <a href="GL15C.html#glDeleteBuffers(java.nio.IntBuffer)"><code>DeleteBuffers</code></a>. Such a store may not be re-allocated through further calls to <code>BufferStorage</code>
 or <a href="GL15C.html#glBufferData(int,long,int)"><code>BufferData</code></a>.</p>
 
 <p><code>BufferStorage</code> deletes any existing data store. If any portion of the buffer object is mapped in the current context or any context current to
 another thread, it is as though <a href="GL15C.html#glUnmapBuffer(int)"><code>UnmapBuffer</code></a> is executed in each such context prior to deleting the existing data store.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the buffer object target. One of:<br><table><tr><td><a href="GL15.html#GL_ARRAY_BUFFER"><code>ARRAY_BUFFER</code></a></td><td><a href="GL15.html#GL_ELEMENT_ARRAY_BUFFER"><code>ELEMENT_ARRAY_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_PACK_BUFFER"><code>PIXEL_PACK_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_UNPACK_BUFFER"><code>PIXEL_UNPACK_BUFFER</code></a></td></tr><tr><td><a href="GL30.html#GL_TRANSFORM_FEEDBACK_BUFFER"><code>TRANSFORM_FEEDBACK_BUFFER</code></a></td><td><a href="GL31.html#GL_UNIFORM_BUFFER"><code>UNIFORM_BUFFER</code></a></td><td><a href="GL31.html#GL_TEXTURE_BUFFER"><code>TEXTURE_BUFFER</code></a></td><td><a href="GL31.html#GL_COPY_READ_BUFFER"><code>COPY_READ_BUFFER</code></a></td></tr><tr><td><a href="GL31.html#GL_COPY_WRITE_BUFFER"><code>COPY_WRITE_BUFFER</code></a></td><td><a href="GL40.html#GL_DRAW_INDIRECT_BUFFER"><code>DRAW_INDIRECT_BUFFER</code></a></td><td><a href="GL42.html#GL_ATOMIC_COUNTER_BUFFER"><code>ATOMIC_COUNTER_BUFFER</code></a></td><td><a href="GL43.html#GL_DISPATCH_INDIRECT_BUFFER"><code>DISPATCH_INDIRECT_BUFFER</code></a></td></tr><tr><td><a href="GL43.html#GL_SHADER_STORAGE_BUFFER"><code>SHADER_STORAGE_BUFFER</code></a></td><td><a href="ARBIndirectParameters.html#GL_PARAMETER_BUFFER_ARB"><code>PARAMETER_BUFFER_ARB</code></a></td></tr></table></dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="GL44C.html#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,java.nio.DoubleBuffer,int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/DoubleBuffer.html" title="class or interface in java.nio" class="external-link">DoubleBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Creates the data store of a buffer object.
 
 <p>The data store of the buffer object bound to <code>target</code> is allocated as a result of a call to this function and cannot be de-allocated until the
 buffer is deleted with a call to <a href="GL15C.html#glDeleteBuffers(java.nio.IntBuffer)"><code>DeleteBuffers</code></a>. Such a store may not be re-allocated through further calls to <code>BufferStorage</code>
 or <a href="GL15C.html#glBufferData(int,long,int)"><code>BufferData</code></a>.</p>
 
 <p><code>BufferStorage</code> deletes any existing data store. If any portion of the buffer object is mapped in the current context or any context current to
 another thread, it is as though <a href="GL15C.html#glUnmapBuffer(int)"><code>UnmapBuffer</code></a> is executed in each such context prior to deleting the existing data store.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the buffer object target. One of:<br><table><tr><td><a href="GL15.html#GL_ARRAY_BUFFER"><code>ARRAY_BUFFER</code></a></td><td><a href="GL15.html#GL_ELEMENT_ARRAY_BUFFER"><code>ELEMENT_ARRAY_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_PACK_BUFFER"><code>PIXEL_PACK_BUFFER</code></a></td><td><a href="GL21.html#GL_PIXEL_UNPACK_BUFFER"><code>PIXEL_UNPACK_BUFFER</code></a></td></tr><tr><td><a href="GL30.html#GL_TRANSFORM_FEEDBACK_BUFFER"><code>TRANSFORM_FEEDBACK_BUFFER</code></a></td><td><a href="GL31.html#GL_UNIFORM_BUFFER"><code>UNIFORM_BUFFER</code></a></td><td><a href="GL31.html#GL_TEXTURE_BUFFER"><code>TEXTURE_BUFFER</code></a></td><td><a href="GL31.html#GL_COPY_READ_BUFFER"><code>COPY_READ_BUFFER</code></a></td></tr><tr><td><a href="GL31.html#GL_COPY_WRITE_BUFFER"><code>COPY_WRITE_BUFFER</code></a></td><td><a href="GL40.html#GL_DRAW_INDIRECT_BUFFER"><code>DRAW_INDIRECT_BUFFER</code></a></td><td><a href="GL42.html#GL_ATOMIC_COUNTER_BUFFER"><code>ATOMIC_COUNTER_BUFFER</code></a></td><td><a href="GL43.html#GL_DISPATCH_INDIRECT_BUFFER"><code>DISPATCH_INDIRECT_BUFFER</code></a></td></tr><tr><td><a href="GL43.html#GL_SHADER_STORAGE_BUFFER"><code>SHADER_STORAGE_BUFFER</code></a></td><td><a href="ARBIndirectParameters.html#GL_PARAMETER_BUFFER_ARB"><code>PARAMETER_BUFFER_ARB</code></a></td></tr></table></dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="GL44C.html#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="GL44C.html#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="GL44C.html#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="GL44C.html#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="GL44C.html#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nglNamedBufferStorageEXT(int,long,long,int)">
<h3>nglNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">nglNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 long&nbsp;size,
 long&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Unsafe version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>size</code> - the size of the data store in basic machine units</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,long,int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 long&nbsp;size,
 int&nbsp;flags)</span></div>
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - the buffer object</dd>
<dd><code>size</code> - the size of the data store in basic machine units</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,java.nio.ByteBuffer,int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - the buffer object</dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,java.nio.ShortBuffer,int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ShortBuffer.html" title="class or interface in java.nio" class="external-link">ShortBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - the buffer object</dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,java.nio.IntBuffer,int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - the buffer object</dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,java.nio.FloatBuffer,int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - the buffer object</dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,java.nio.DoubleBuffer,int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/DoubleBuffer.html" title="class or interface in java.nio" class="external-link">DoubleBuffer</a>&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Behaves similarly to <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a>, except that the buffer whose storage is to be defined is specified by <code>buffer</code> rather than by the current
 binding to <code>target</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - the buffer object</dd>
<dd><code>data</code> - the address in client memory of the data that should be used to initialize the buffer's data store. If <code>data</code> is <code>NULL</code>, the data store of the
               buffer is created, but contains undefined data. Otherwise, <code>data</code> should point to an array of at least <code>size</code> basic machine units.</dd>
<dd><code>flags</code> - the bitwise <code>OR</code> of flags describing the intended usage of the buffer object's data store by the application. Valid flags and their meanings
               are as follows:
               
               <ul>
               <li><a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a> &ndash; The contents of the data store may be updated after creation through calls to
               <a href="GL15C.html#glBufferSubData(int,long,java.nio.ByteBuffer)"><code>BufferSubData</code></a>. If this bit is not set, the buffer content may not be directly updated by the client. The <code>data</code>
               argument may be used to specify the initial content of the buffer's data store regardless of the presence of the <a href="#GL_DYNAMIC_STORAGE_BIT"><code>DYNAMIC_STORAGE_BIT</code></a>.
               Regardless of the presence of this bit, buffers may always be updated with server-side calls such as <a href="GL31C.html#glCopyBufferSubData(int,int,long,long,long)"><code>CopyBufferSubData</code></a> and
               <a href="GL43C.html#glClearBufferSubData(int,int,long,long,int,int,java.nio.ByteBuffer)"><code>ClearBufferSubData</code></a>.</li>
               <li><a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for read access and a pointer in the client's address space
               obtained that may be read from.</li>
               <li><a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a> &ndash; The buffer's data store may be mapped by the client for write access and a pointer in the client's address
               space obtained that may be written to.</li>
               <li><a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a> &ndash; The client may request that the server read from or write to the buffer while it is mapped. The client's
               pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.</li>
               <li><a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> &ndash; Shared access to buffers that are simultaneously mapped for client access and are used by the server will be
               coherent, so long as that mapping is performed using MapBufferRange. That is, data written to the store by either the client or server will be
               immediately visible to the other with no further action taken by the application. In particular:
               
               <ul>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the client performs a write followed by a call to the <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> command with
               the <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the client performs a write, then in subsequent commands the server will see the writes.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is not set and the server performs a write, the application must call <a href="GL42C.html#glMemoryBarrier(int)"><code>MemoryBarrier</code></a> with the
               <a href="#GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT"><code>CLIENT_MAPPED_BUFFER_BARRIER_BIT</code></a> set and then call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or
               <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               <li>If <code>MAP_COHERENT_BIT</code> is set and the server does a write, the app must call <a href="GL32C.html#glFenceSync(int,int)"><code>FenceSync</code></a> with
               <a href="GL32.html#GL_SYNC_GPU_COMMANDS_COMPLETE"><code>SYNC_GPU_COMMANDS_COMPLETE</code></a> (or <a href="GL11C.html#glFinish()"><code>Finish</code></a>). Then the CPU will see the writes after the sync is complete.</li>
               </ul></li>
               <li><a href="#GL_CLIENT_STORAGE_BIT"><code>CLIENT_STORAGE_BIT</code></a> &ndash; When all other criteria for the buffer storage allocation are met, this bit may be used by an
               implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.</li>
               </ul>
               
               <p>If <code>flags</code> contains <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>, it must also contain at least one of <a href="GL30.html#GL_MAP_READ_BIT"><code>MAP_READ_BIT</code></a> or <a href="GL30.html#GL_MAP_WRITE_BIT"><code>MAP_WRITE_BIT</code></a>.</p>
               
               <p>It is an error to specify <a href="#GL_MAP_COHERENT_BIT"><code>MAP_COHERENT_BIT</code></a> without also specifying <a href="#GL_MAP_PERSISTENT_BIT"><code>MAP_PERSISTENT_BIT</code></a>.</p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,short[],int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 short[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,int[],int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 int[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,float[],int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 float[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="glBufferStorage(int,double[],int)">
<h3>glBufferStorage</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glBufferStorage</span><wbr><span class="parameters">(int&nbsp;target,
 double[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glBufferStorage(int,long,int)"><code>BufferStorage</code></a></div>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,short[],int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 short[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,int[],int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 int[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,float[],int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 float[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</section>
</li>
<li>
<section class="detail" id="glNamedBufferStorageEXT(int,double[],int)">
<h3>glNamedBufferStorageEXT</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">glNamedBufferStorageEXT</span><wbr><span class="parameters">(int&nbsp;buffer,
 double[]&nbsp;data,
 int&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#glNamedBufferStorageEXT(int,long,int)"><code>NamedBufferStorageEXT</code></a></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</div>
</div>
</body>
</html>
