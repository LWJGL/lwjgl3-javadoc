<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (19) -->
<title>Assimp (LWJGL 3.3.2-snapshot)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.lwjgl.assimp, class: Assimp">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li><a href="#field-summary">Field</a></li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.lwjgl.assimp</a></div>
<h1 title="Class Assimp" class="title">Class Assimp</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.lwjgl.assimp.Assimp</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">Assimp</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Contains bindings to the <a target="_blank" href="http://www.assimp.org/">Assimp</a> library.
 
 <h3>General Features</h3>
 
 <ul>
 <li>Written in portable, ISO-compliant C++</li>
 <li>Easily configurable and customizable</li>
 <li>Core interface / API is provided for both C++ and C</li>
 <li>Command-line interface to perform common operations (i.e. quick file stats, convert models, extract embedded textures) from the shell</li>
 <li>Imports bones, vertex weights and animations (i.e. skinning, skeletal animations)</li>
 <li>Loads multiple UV and vertex color channels (current limit is 8)</li>
 <li>Works well with UNICODE input files</li>
 <li>Supports complex multi-layer materials</li>
 <li>Supports embedded textures, both compressed (e.g. PNG) or just raw color data</li>
 <li>No external dependencies except boost (zlib and irrxml are also needed, but they're included in the repository so you don't need to bother). And there's even a workaround to compile Assimp without boost - with some minor limitations.</li>
 <li>Due to its export interface, Assimp serves as general-purpose 3D model converter</li>
 </ul>
 
 <h3>Import Formats</h3>
 
 <p>COMMON INTERCHANGE FORMATS (An asterisk indicates limited support)</p>
 
 <ul>
 <li>Autodesk ( .fbx )</li>
 <li>Collada ( .dae )</li>
 <li>glTF ( .gltf, .glb )</li>
 <li>Blender 3D ( .blend )</li>
 <li>3ds Max 3DS ( .3ds )</li>
 <li>3ds Max ASE ( .ase )</li>
 <li>Wavefront Object ( .obj )</li>
 <li>Industry Foundation Classes (IFC/Step) ( .ifc )</li>
 <li>XGL ( .xgl,.zgl )</li>
 <li>Stanford Polygon Library ( .ply )</li>
 <li>*AutoCAD DXF ( .dxf )</li>
 <li>LightWave ( .lwo )</li>
 <li>LightWave Scene ( .lws )</li>
 <li>Modo ( .lxo )</li>
 <li>Stereolithography ( .stl )</li>
 <li>DirectX X ( .x )</li>
 <li>AC3D ( .ac )</li>
 <li>Milkshape 3D ( .ms3d )</li>
 <li>* TrueSpace ( .cob,.scn )</li>
 <li>*OpenGEX ( .ogex )</li>
 <li>*X3D ( .x3d )</li>
 <li>*3MF ( .3mf )</li>
 </ul>
 
 <p>MOTION CAPTURE FORMATS</p>
 
 <ul>
 <li>Biovision BVH ( .bvh )</li>
 <li>* CharacterStudio Motion ( .csm )</li>
 </ul>
 
 <p>GRAPHICS ENGINE FORMATS</p>
 
 <ul>
 <li>Ogre XML ( .xml )</li>
 <li>Irrlicht Mesh ( .irrmesh )</li>
 <li>* Irrlicht Scene ( .irr )</li>
 </ul>
 
 <p>GAME FILE FORMATS</p>
 
 <ul>
 <li>Quake I ( .mdl )</li>
 <li>Quake II ( .md2 )</li>
 <li>Quake III Mesh ( .md3 )</li>
 <li>Quake III Map/BSP ( .pk3 )</li>
 <li>* Return to Castle Wolfenstein ( .mdc )</li>
 <li>Doom 3 ( .md5* )</li>
 <li>*Valve Model ( .smd,.vta )</li>
 <li>*Open Game Engine Exchange ( .ogex )</li>
 <li>*Unreal ( .3d )</li>
 </ul>
 
 <p>OTHER FILE FORMATS</p>
 
 <ul>
 <li>BlitzBasic 3D ( .b3d )</li>
 <li>Quick3D ( .q3d,.q3s )</li>
 <li>Neutral File Format ( .nff )</li>
 <li>Sense8 WorldToolKit ( .nff )</li>
 <li>Object File Format ( .off )</li>
 <li>PovRAY Raw ( .raw )</li>
 <li>Terragen Terrain ( .ter )</li>
 <li>3D GameStudio (3DGS) ( .mdl )</li>
 <li>3D GameStudio (3DGS) Terrain ( .hmp )</li>
 <li>Izware Nendo ( .ndo )</li>
 </ul>
 
 <h3>Export Formats</h3>
 
 <p>COMMON INTERCHANGE FORMATS</p>
 
 <ul>
 <li>Collada ( .dae )</li>
 <li>Wavefront Object ( .obj )</li>
 <li>Stereolithography ( .stl )</li>
 <li>Stanford Polygon Library ( .ply )</li>
 </ul>
 
 <h3>Post-processing</h3>
 
 <p>REAL TIME RENDERING</p>
 
 <ul>
 <li>Improve vertex cache locality</li>
 <li>Convert from right-handed to left-handed space</li>
 <li>Limit weights affecting a single vertex</li>
 <li>Split meshes to avoid exceeding bone count limits</li>
 <li>Triangulate arbitrary polygons</li>
 <li>Join identical vertices, optimize indexing</li>
 <li>Find degenerate polygons</li>
 <li>Split large meshes to overcome GPU limitations (i.e. vertex count)</li>
 </ul>
 
 <p>VERTEX DATA</p>
 
 <ul>
 <li>Compute "hard" per-face normal vectors</li>
 <li>Compute "smooth" per-vertex normal vectors</li>
 <li>Compute tangents and bitangents</li>
 </ul>
 
 <p>SCENEGRAPH</p>
 
 <ul>
 <li>Collapse the scene graph, transform everything to world coordinates</li>
 <li>Optimize meshes &amp; nodes for fewer drawcalls</li>
 </ul>
 
 <p>OTHER</p>
 
 <ul>
 <li>Validate the output structure to ensure maximum data integrity</li>
 <li>Remove unrequired materials, effectively detect and merge duplicates</li>
 <li>Try to correct face winding</li>
 <li>Drop dummy bones introduced somewhere in your content pipeline</li>
 </ul></div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final class&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="Assimp.Functions.html" class="type-name-link" title="class in org.lwjgl.assimp">Assimp.Functions</a></code></div>
<div class="col-last even-row-color">
<div class="block">Contains the function pointers loaded from the assimp <a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system"><code>SharedLibrary</code></a>.</div>
</div>
</div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE" class="member-name-link">_AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE" class="member-name-link">_AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_GLTF_MAPPINGID_BASE" class="member-name-link">_AI_MATKEY_GLTF_MAPPINGID_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_GLTF_MAPPINGNAME_BASE" class="member-name-link">_AI_MATKEY_GLTF_MAPPINGNAME_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_GLTF_SCALE_BASE" class="member-name-link">_AI_MATKEY_GLTF_SCALE_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_GLTF_STRENGTH_BASE" class="member-name-link">_AI_MATKEY_GLTF_STRENGTH_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_MAPPING_BASE" class="member-name-link">_AI_MATKEY_MAPPING_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_MAPPINGMODE_U_BASE" class="member-name-link">_AI_MATKEY_MAPPINGMODE_U_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_MAPPINGMODE_V_BASE" class="member-name-link">_AI_MATKEY_MAPPINGMODE_V_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_OBJ_BUMPMULT_BASE" class="member-name-link">_AI_MATKEY_OBJ_BUMPMULT_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_TEXBLEND_BASE" class="member-name-link">_AI_MATKEY_TEXBLEND_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_TEXFLAGS_BASE" class="member-name-link">_AI_MATKEY_TEXFLAGS_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_TEXMAP_AXIS_BASE" class="member-name-link">_AI_MATKEY_TEXMAP_AXIS_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_TEXOP_BASE" class="member-name-link">_AI_MATKEY_TEXOP_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_TEXTURE_BASE" class="member-name-link">_AI_MATKEY_TEXTURE_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#_AI_MATKEY_UVTRANSFORM_BASE" class="member-name-link">_AI_MATKEY_UVTRANSFORM_BASE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#_AI_MATKEY_UVWSRC_BASE" class="member-name-link">_AI_MATKEY_UVWSRC_BASE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_AIMETADATA" class="member-name-link">AI_AIMETADATA</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_AISTRING" class="member-name-link">AI_AISTRING</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_AIVECTOR3D" class="member-name-link">AI_AIVECTOR3D</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_BOOL" class="member-name-link">AI_BOOL</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT" class="member-name-link">AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies whether the Android JNI asset extraction is supported.</div>
</div>
<div class="col-first even-row-color"><code>static final float</code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_APP_SCALE_DEFAULT" class="member-name-link">AI_CONFIG_APP_SCALE_DEFAULT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default value for configuration properties.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_APP_SCALE_KEY" class="member-name-link">AI_CONFIG_APP_SCALE_KEY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies an application key factor for scale.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_EXPORT_BLOB_NAME" class="member-name-link">AI_CONFIG_EXPORT_BLOB_NAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Specifies the blob name, assimp uses for exporting.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS" class="member-name-link">AI_CONFIG_EXPORT_POINT_CLOUDS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies whether the assimp export shall be able to export point clouds.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_EXPORT_XFILE_64BIT" class="member-name-link">AI_CONFIG_EXPORT_XFILE_64BIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Specifies the xfile use double for real values of float.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_FAVOUR_SPEED" class="member-name-link">AI_CONFIG_FAVOUR_SPEED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">A hint to assimp to favour speed against import quality.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_FBX_CONVERT_TO_M" class="member-name-link">AI_CONFIG_FBX_CONVERT_TO_M</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the FBX importer shall convert the unit from cm to m.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER" class="member-name-link">AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Will enable the skeleton structo to store bone data.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_GLOB_MEASURE_TIME" class="member-name-link">AI_CONFIG_GLOB_MEASURE_TIME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enables time measurements.</div>
</div>
<div class="col-first odd-row-color"><code>static final float</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT" class="member-name-link">AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Default value for configuration properties.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY" class="member-name-link">AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Specifies a global key factor for scale.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION" class="member-name-link">AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures whether the AC loader evaluates subdivision surfaces (indicated by the presence of the 'subdiv' attribute in the file).</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL" class="member-name-link">AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</a></code></div>
<div class="col-last even-row-color">
<div class="block">Configures the AC loader to collect all surfaces which have the "Backface cull" flag set in separate meshes.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS" class="member-name-link">AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the ASE loader to always reconstruct normal vectors basing on the smoothing groups loaded from the file.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION" class="member-name-link">AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Specifies whether the Collada loader will ignore the provided up direction.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES" class="member-name-link">AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies whether the Collada loader should use Collada names.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING" class="member-name-link">AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the fbx importer will use the legacy embedded texture naming.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES" class="member-name-link">AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies whether the importer will drop empty animation curves or animation curves which match the bind pose transformation over their entire defined
 range.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS" class="member-name-link">AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the fbx importer will preserve pivot points for transformations (as extra nodes).</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the fbx importer will merge all geometry layers present in the source file or take only the first.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the fbx importer will read all materials present in the source file or take only the referenced materials.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the fbx importer will read animations.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_CAMERAS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the fbx importer will read cameras.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_LIGHTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the fbx importer will read light sources.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_MATERIALS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the fbx importer will read materials.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_TEXTURES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the fbx importer will read embedded textures.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS" class="member-name-link">AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the fbx importer will read weights.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE" class="member-name-link">AI_CONFIG_IMPORT_FBX_STRICT_MODE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the fbx importer will act in strict mode in which only FBX 2013 is supported and any other sub formats are rejected.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME" class="member-name-link">AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set the vertex animation keyframe to be imported.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION" class="member-name-link">AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies whether the IFC loader will use its own, custom triangulation algorithm to triangulate wall and floor meshes.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION" class="member-name-link">AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set the tessellation for IFC cylindrical shapes.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS" class="member-name-link">AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies whether the IFC loader skips over shape representations of type 'Curve2D'.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS" class="member-name-link">AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Specifies whether the IFC loader skips over IfcSpace elements.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE" class="member-name-link">AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Sets the tessellation conic angle for IFC smoothing curves.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS" class="member-name-link">AI_CONFIG_IMPORT_IRR_ANIM_FPS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the output frame rate of the IRR loader.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY" class="member-name-link">AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the LWO loader to load just one layer from the model.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END" class="member-name-link">AI_CONFIG_IMPORT_LWS_ANIM_END</a></code></div>
<div class="col-last even-row-color">
<div class="block">End of the imported time range.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START" class="member-name-link">AI_CONFIG_IMPORT_LWS_ANIM_START</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the begin of the time range for which the LWS loader evaluates animations and computes <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a>'s.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME" class="member-name-link">AI_CONFIG_IMPORT_MD2_KEYFRAME</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART" class="member-name-link">AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the M3D loader to detect and process multi-part Quake player models.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME" class="member-name-link">AI_CONFIG_IMPORT_MD3_KEYFRAME</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS" class="member-name-link">AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specify if to try load Quake 3 shader files.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC" class="member-name-link">AI_CONFIG_IMPORT_MD3_SHADER_SRC</a></code></div>
<div class="col-last even-row-color">
<div class="block">Specify the Quake 3 shader file to be used for a particular MD3 file.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME" class="member-name-link">AI_CONFIG_IMPORT_MD3_SKIN_NAME</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Tells the MD3 loader which skin files to load.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD" class="member-name-link">AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</a></code></div>
<div class="col-last even-row-color">
<div class="block">Configures the MD5 loader to not load the MD5ANIM file for a MD5MESH file automatically.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME" class="member-name-link">AI_CONFIG_IMPORT_MDC_KEYFRAME</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP" class="member-name-link">AI_CONFIG_IMPORT_MDL_COLORMAP</a></code></div>
<div class="col-last even-row-color">
<div class="block">Sets the colormap (= palette) to be used to decode embedded textures in MDL (Quake or 3DGS) files.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the MDL (HL1) importer will read animation events.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the MDL (HL1) importer will read animations.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the MDL (HL1) importer will read attachments info.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the MDL (HL1) importer will read blend controllers.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the MDL (HL1) importer will read bone controllers info.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the MDL (HL1) importer will read hitboxes info.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the MDL (HL1) importer will read miscellaneous global model info.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS" class="member-name-link">AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set whether the MDL (HL1) importer will read sequence transition graph.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME" class="member-name-link">AI_CONFIG_IMPORT_MDL_KEYFRAME</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES" class="member-name-link">AI_CONFIG_IMPORT_NO_SKELETON_MESHES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Global setting to disable generation of skeleton dummy meshes</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE" class="member-name-link">AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Ogre Importer will try to find referenced materials from this file.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME" class="member-name-link">AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Ogre Importer detect the texture usage from its filename.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES" class="member-name-link">AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set whether the importer shall not remove empty bones.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER" class="member-name-link">AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</a></code></div>
<div class="col-last even-row-color">
<div class="block">Importers which parse JSON may use this to obtain a pointer to a <code>rapidjson::IRemoteSchemaDocumentProvider</code>.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME" class="member-name-link">AI_CONFIG_IMPORT_SMD_KEYFRAME</a></code></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST" class="member-name-link">AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</a></code></div>
<div class="col-last even-row-color">
<div class="block">Smd load multiple animations.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS" class="member-name-link">AI_CONFIG_IMPORT_TER_MAKE_UVS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the terragen import plugin to compute uv's for terrains, if not given.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME" class="member-name-link">AI_CONFIG_IMPORT_UNREAL_KEYFRAME</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE" class="member-name-link">AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies the maximum angle that may be between two vertex tangents that their tangents and bi-tangents are smoothed.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX" class="member-name-link">AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</a></code></div>
<div class="col-last even-row-color">
<div class="block">Source UV channel for tangent space computation.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE" class="member-name-link">AI_CONFIG_PP_DB_ALL_OR_NONE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Require all bones qualify for deboning before removing any.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_DB_THRESHOLD" class="member-name-link">AI_CONFIG_PP_DB_THRESHOLD</a></code></div>
<div class="col-last even-row-color">
<div class="block">Lower the deboning threshold in order to remove more bones.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_FD_CHECKAREA" class="member-name-link">AI_CONFIG_PP_FD_CHECKAREA</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> to check the area of a triangle to be greater than e-6.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_FD_REMOVE" class="member-name-link">AI_CONFIG_PP_FD_REMOVE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Configures the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> step to remove degenerated primitives from the import - immediately.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY" class="member-name-link">AI_CONFIG_PP_FID_ANIM_ACCURACY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Input parameter to the <a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> step: Specifies the floating-point accuracy for animation values.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS" class="member-name-link">AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Input parameter to the <a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> step: Set to true to ignore texture coordinates.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE" class="member-name-link">AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies the maximum angle that may be between two face normals at the same vertex position that their are smoothed together.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE" class="member-name-link">AI_CONFIG_PP_ICL_PTCACHE_SIZE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set the size of the post-transform vertex cache to optimize the vertices for.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS" class="member-name-link">AI_CONFIG_PP_LBW_MAX_WEIGHTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set the maximum number of bones affecting a single vertex.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST" class="member-name-link">AI_CONFIG_PP_OG_EXCLUDE_LIST</a></code></div>
<div class="col-last even-row-color">
<div class="block">Configures the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to preserve nodes matching a name in a given list.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION" class="member-name-link">AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to use a users defined matrix as the scene root node transformation before transforming vertices.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY" class="member-name-link">AI_CONFIG_PP_PTV_KEEP_HIERARCHY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to keep the scene hierarchy.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_PTV_NORMALIZE" class="member-name-link">AI_CONFIG_PP_PTV_NORMALIZE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to normalize all vertex components into the <code>[-1,1]</code> range.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION" class="member-name-link">AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to use a users defined matrix as the scene root node transformation before transforming vertices.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST" class="member-name-link">AI_CONFIG_PP_RRM_EXCLUDE_LIST</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Configures the <a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> step to keep materials matching a name in a given list.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_RVC_FLAGS" class="member-name-link">AI_CONFIG_PP_RVC_FLAGS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Input parameter to the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step: Specifies the parts of the data structure to be removed.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_SBBC_MAX_BONES" class="member-name-link">AI_CONFIG_PP_SBBC_MAX_BONES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Maximum bone count per mesh for the <a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> step.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_SBP_REMOVE" class="member-name-link">AI_CONFIG_PP_SBP_REMOVE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Input parameter to the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> step: Specifies which primitive types are removed by the step.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT" class="member-name-link">AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Set the maximum number of triangles in a mesh.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT" class="member-name-link">AI_CONFIG_PP_SLM_VERTEX_LIMIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Set the maximum number of vertices in a mesh.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_CONFIG_PP_TUV_EVALUATE" class="member-name-link">AI_CONFIG_PP_TUV_EVALUATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Input parameter to the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step: Specifies which UV transformations are evaluated.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS" class="member-name-link">AI_CONFIG_UNREAL_HANDLE_FLAGS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Configures the UNREAL 3D loader to separate faces with different surface flags (e.g.</div>
</div>
<div class="col-first odd-row-color"><code>static final float</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_DEBONE_THRESHOLD" class="member-name-link">AI_DEBONE_THRESHOLD</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Default value for configuration properties.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_DEFAULT_MATERIAL_NAME" class="member-name-link">AI_DEFAULT_MATERIAL_NAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Name for default materials (2nd is used if meshes have UV coords)</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_DOUBLE" class="member-name-link">AI_DOUBLE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first even-row-color"><code>static final float</code></div>
<div class="col-second even-row-color"><code><a href="#ai_epsilon" class="member-name-link">ai_epsilon</a></code></div>
<div class="col-last even-row-color">
<div class="block">Numerical limits.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_FALSE" class="member-name-link">AI_FALSE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean constants</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_FLOAT" class="member-name-link">AI_FLOAT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION" class="member-name-link">AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Default values for configuration properties.</div>
</div>
<div class="col-first even-row-color"><code>static final float</code></div>
<div class="col-second even-row-color"><code><a href="#AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE" class="member-name-link">AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default value for configuration properties.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_INT32" class="member-name-link">AI_INT32</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_LBW_MAX_WEIGHTS" class="member-name-link">AI_LBW_MAX_WEIGHTS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default values for configuration properties.</div>
</div>
<div class="col-first odd-row-color"><code>static final double</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATH_HALF_PI" class="member-name-link">AI_MATH_HALF_PI</a></code></div>
<div class="col-last odd-row-color">
<div class="block">This is PI.</div>
</div>
<div class="col-first even-row-color"><code>static final float</code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATH_HALF_PI_F" class="member-name-link">AI_MATH_HALF_PI_F</a></code></div>
<div class="col-last even-row-color">
<div class="block">This is PI.</div>
</div>
<div class="col-first odd-row-color"><code>static final double</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATH_PI" class="member-name-link">AI_MATH_PI</a></code></div>
<div class="col-last odd-row-color">
<div class="block">This is PI.</div>
</div>
<div class="col-first even-row-color"><code>static final float</code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATH_PI_F" class="member-name-link">AI_MATH_PI_F</a></code></div>
<div class="col-last even-row-color">
<div class="block">This is PI.</div>
</div>
<div class="col-first odd-row-color"><code>static final double</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATH_TWO_PI" class="member-name-link">AI_MATH_TWO_PI</a></code></div>
<div class="col-last odd-row-color">
<div class="block">This is PI.</div>
</div>
<div class="col-first even-row-color"><code>static final float</code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATH_TWO_PI_F" class="member-name-link">AI_MATH_TWO_PI_F</a></code></div>
<div class="col-last even-row-color">
<div class="block">This is PI.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_ANISOTROPY_FACTOR" class="member-name-link">AI_MATKEY_ANISOTROPY_FACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_BASE_COLOR" class="member-name-link">AI_MATKEY_BASE_COLOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_BLEND_FUNC" class="member-name-link">AI_MATKEY_BLEND_FUNC</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_BUMPSCALING" class="member-name-link">AI_MATKEY_BUMPSCALING</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_CLEARCOAT_FACTOR" class="member-name-link">AI_MATKEY_CLEARCOAT_FACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR" class="member-name-link">AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_COLOR_AMBIENT" class="member-name-link">AI_MATKEY_COLOR_AMBIENT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_COLOR_DIFFUSE" class="member-name-link">AI_MATKEY_COLOR_DIFFUSE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_COLOR_EMISSIVE" class="member-name-link">AI_MATKEY_COLOR_EMISSIVE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_COLOR_REFLECTIVE" class="member-name-link">AI_MATKEY_COLOR_REFLECTIVE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_COLOR_SPECULAR" class="member-name-link">AI_MATKEY_COLOR_SPECULAR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_COLOR_TRANSPARENT" class="member-name-link">AI_MATKEY_COLOR_TRANSPARENT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_EMISSIVE_INTENSITY" class="member-name-link">AI_MATKEY_EMISSIVE_INTENSITY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_ENABLE_WIREFRAME" class="member-name-link">AI_MATKEY_ENABLE_WIREFRAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_GLOBAL_BACKGROUND_IMAGE" class="member-name-link">AI_MATKEY_GLOBAL_BACKGROUND_IMAGE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_GLOBAL_SHADERLANG" class="member-name-link">AI_MATKEY_GLOBAL_SHADERLANG</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_GLOSSINESS_FACTOR" class="member-name-link">AI_MATKEY_GLOSSINESS_FACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_GLTF_ALPHACUTOFF" class="member-name-link">AI_MATKEY_GLTF_ALPHACUTOFF</a></code></div>
<div class="col-last even-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_GLTF_ALPHAMODE" class="member-name-link">AI_MATKEY_GLTF_ALPHAMODE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">PBR Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE" class="member-name-link">AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE</a></code></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_METALLIC_FACTOR" class="member-name-link">AI_MATKEY_METALLIC_FACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_NAME" class="member-name-link">AI_MATKEY_NAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_OBJ_ILLUM" class="member-name-link">AI_MATKEY_OBJ_ILLUM</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_OPACITY" class="member-name-link">AI_MATKEY_OPACITY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_REFLECTIVITY" class="member-name-link">AI_MATKEY_REFLECTIVITY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_REFRACTI" class="member-name-link">AI_MATKEY_REFRACTI</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_ROUGHNESS_FACTOR" class="member-name-link">AI_MATKEY_ROUGHNESS_FACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_SHADER_COMPUTE" class="member-name-link">AI_MATKEY_SHADER_COMPUTE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_SHADER_FRAGMENT" class="member-name-link">AI_MATKEY_SHADER_FRAGMENT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_SHADER_GEO" class="member-name-link">AI_MATKEY_SHADER_GEO</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_SHADER_PRIMITIVE" class="member-name-link">AI_MATKEY_SHADER_PRIMITIVE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_SHADER_TESSELATION" class="member-name-link">AI_MATKEY_SHADER_TESSELATION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_SHADER_VERTEX" class="member-name-link">AI_MATKEY_SHADER_VERTEX</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_SHADING_MODEL" class="member-name-link">AI_MATKEY_SHADING_MODEL</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_SHEEN_COLOR_FACTOR" class="member-name-link">AI_MATKEY_SHEEN_COLOR_FACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_SHEEN_ROUGHNESS_FACTOR" class="member-name-link">AI_MATKEY_SHEEN_ROUGHNESS_FACTOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_SHININESS" class="member-name-link">AI_MATKEY_SHININESS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_SHININESS_STRENGTH" class="member-name-link">AI_MATKEY_SHININESS_STRENGTH</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_SPECULAR_FACTOR" class="member-name-link">AI_MATKEY_SPECULAR_FACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_TRANSMISSION_FACTOR" class="member-name-link">AI_MATKEY_TRANSMISSION_FACTOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_TRANSPARENCYFACTOR" class="member-name-link">AI_MATKEY_TRANSPARENCYFACTOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_TWOSIDED" class="member-name-link">AI_MATKEY_TWOSIDED</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_USE_AO_MAP" class="member-name-link">AI_MATKEY_USE_AO_MAP</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_USE_COLOR_MAP" class="member-name-link">AI_MATKEY_USE_COLOR_MAP</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_USE_EMISSIVE_MAP" class="member-name-link">AI_MATKEY_USE_EMISSIVE_MAP</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_USE_METALLIC_MAP" class="member-name-link">AI_MATKEY_USE_METALLIC_MAP</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_USE_ROUGHNESS_MAP" class="member-name-link">AI_MATKEY_USE_ROUGHNESS_MAP</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_VOLUME_ATTENUATION_COLOR" class="member-name-link">AI_MATKEY_VOLUME_ATTENUATION_COLOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MATKEY_VOLUME_ATTENUATION_DISTANCE" class="member-name-link">AI_MATKEY_VOLUME_ATTENUATION_DISTANCE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_MATKEY_VOLUME_THICKNESS_FACTOR" class="member-name-link">AI_MATKEY_VOLUME_THICKNESS_FACTOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Material keys</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MAX_BONE_WEIGHTS" class="member-name-link">AI_MAX_BONE_WEIGHTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Maximum number of indices per face (polygon).</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_MAX_FACE_INDICES" class="member-name-link">AI_MAX_FACE_INDICES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Maximum number of indices per face (polygon).</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MAX_FACES" class="member-name-link">AI_MAX_FACES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Maximum number of faces per mesh.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_MAX_NUMBER_OF_COLOR_SETS" class="member-name-link">AI_MAX_NUMBER_OF_COLOR_SETS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Supported number of vertex color sets per mesh.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_MAX_NUMBER_OF_TEXTURECOORDS" class="member-name-link">AI_MAX_NUMBER_OF_TEXTURECOORDS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Supported number of texture coord sets (UV(W) channels) per mesh.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_MAX_VERTICES" class="member-name-link">AI_MAX_VERTICES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Maximum number of vertices per mesh.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_META_MAX" class="member-name-link">AI_META_MAX</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_METADATA_SOURCE_COPYRIGHT" class="member-name-link">AI_METADATA_SOURCE_COPYRIGHT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Scene metadata holding the source asset copyright statement, if available.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_METADATA_SOURCE_FORMAT" class="member-name-link">AI_METADATA_SOURCE_FORMAT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Scene metadata holding the name of the importer which loaded the source asset.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#AI_METADATA_SOURCE_FORMAT_VERSION" class="member-name-link">AI_METADATA_SOURCE_FORMAT_VERSION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Scene metadata holding the version of the source asset as a string, if available.</div>
</div>
<div class="col-first odd-row-color"><code>static final <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color"><code><a href="#AI_METADATA_SOURCE_GENERATOR" class="member-name-link">AI_METADATA_SOURCE_GENERATOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Scene metadata holding the name of the software which generated the source asset, if available.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_SBBC_DEFAULT_MAX_BONES" class="member-name-link">AI_SBBC_DEFAULT_MAX_BONES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default values for configuration properties.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_SCENE_FLAGS_INCOMPLETE" class="member-name-link">AI_SCENE_FLAGS_INCOMPLETE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Specifies that the scene data structure that was imported is not complete.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_SCENE_FLAGS_NON_VERBOSE_FORMAT" class="member-name-link">AI_SCENE_FLAGS_NON_VERBOSE_FORMAT</a></code></div>
<div class="col-last even-row-color">
<div class="block">This flag is currently only set by the aiProcess_JoinIdenticalVertices step.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_SCENE_FLAGS_TERRAIN" class="member-name-link">AI_SCENE_FLAGS_TERRAIN</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Denotes pure height-map terrain data.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_SCENE_FLAGS_VALIDATED" class="member-name-link">AI_SCENE_FLAGS_VALIDATED</a></code></div>
<div class="col-last even-row-color">
<div class="block">This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
 if the validation is successful.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_SCENE_FLAGS_VALIDATION_WARNING" class="member-name-link">AI_SCENE_FLAGS_VALIDATION_WARNING</a></code></div>
<div class="col-last odd-row-color">
<div class="block">This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
 if the validation is successful but some issues have been found.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_SLM_DEFAULT_MAX_TRIANGLES" class="member-name-link">AI_SLM_DEFAULT_MAX_TRIANGLES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default values for configuration properties.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_SLM_DEFAULT_MAX_VERTICES" class="member-name-link">AI_SLM_DEFAULT_MAX_VERTICES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Default values for configuration properties.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_TRUE" class="member-name-link">AI_TRUE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean constants</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_UINT64" class="member-name-link">AI_UINT64</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enum used to distinguish data types.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_UVTRAFO_ALL" class="member-name-link">AI_UVTRAFO_ALL</a></code></div>
<div class="col-last even-row-color">
<div class="block">UVCoord Transforms</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_UVTRAFO_ROTATION" class="member-name-link">AI_UVTRAFO_ROTATION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">UVCoord Transforms</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#AI_UVTRAFO_SCALING" class="member-name-link">AI_UVTRAFO_SCALING</a></code></div>
<div class="col-last even-row-color">
<div class="block">UVCoord Transforms</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#AI_UVTRAFO_TRANSLATION" class="member-name-link">AI_UVTRAFO_TRANSLATION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">UVCoord Transforms</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiAnimBehaviour_CONSTANT" class="member-name-link">aiAnimBehaviour_CONSTANT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how an animation channel behaves outside the defined time range.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiAnimBehaviour_DEFAULT" class="member-name-link">aiAnimBehaviour_DEFAULT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how an animation channel behaves outside the defined time range.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiAnimBehaviour_LINEAR" class="member-name-link">aiAnimBehaviour_LINEAR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how an animation channel behaves outside the defined time range.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiAnimBehaviour_REPEAT" class="member-name-link">aiAnimBehaviour_REPEAT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how an animation channel behaves outside the defined time range.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiBlendMode_Additive" class="member-name-link">aiBlendMode_Additive</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines alpha-blend flags.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiBlendMode_Default" class="member-name-link">aiBlendMode_Default</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines alpha-blend flags.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiComponent_ANIMATIONS" class="member-name-link">aiComponent_ANIMATIONS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiComponent_BONEWEIGHTS" class="member-name-link">aiComponent_BONEWEIGHTS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiComponent_CAMERAS" class="member-name-link">aiComponent_CAMERAS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiComponent_COLORS" class="member-name-link">aiComponent_COLORS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiComponent_LIGHTS" class="member-name-link">aiComponent_LIGHTS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiComponent_MATERIALS" class="member-name-link">aiComponent_MATERIALS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiComponent_MESHES" class="member-name-link">aiComponent_MESHES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiComponent_NORMALS" class="member-name-link">aiComponent_NORMALS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiComponent_TANGENTS_AND_BITANGENTS" class="member-name-link">aiComponent_TANGENTS_AND_BITANGENTS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiComponent_TEXCOORDS" class="member-name-link">aiComponent_TEXCOORDS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiComponent_TEXTURES" class="member-name-link">aiComponent_TEXTURES</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiDefaultLogStream_DEBUGGER" class="member-name-link">aiDefaultLogStream_DEBUGGER</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates predefined log streaming destinations.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiDefaultLogStream_FILE" class="member-name-link">aiDefaultLogStream_FILE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates predefined log streaming destinations.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiDefaultLogStream_STDERR" class="member-name-link">aiDefaultLogStream_STDERR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates predefined log streaming destinations.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiDefaultLogStream_STDOUT" class="member-name-link">aiDefaultLogStream_STDOUT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates predefined log streaming destinations.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiImporterFlags_Experimental" class="member-name-link">aiImporterFlags_Experimental</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiImporterFlags_LimitedSupport" class="member-name-link">aiImporterFlags_LimitedSupport</a></code></div>
<div class="col-last even-row-color">
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiImporterFlags_SupportBinaryFlavour" class="member-name-link">aiImporterFlags_SupportBinaryFlavour</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiImporterFlags_SupportCompressedFlavour" class="member-name-link">aiImporterFlags_SupportCompressedFlavour</a></code></div>
<div class="col-last even-row-color">
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiImporterFlags_SupportTextFlavour" class="member-name-link">aiImporterFlags_SupportTextFlavour</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiLightSource_AMBIENT" class="member-name-link">aiLightSource_AMBIENT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates all supported types of light sources.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiLightSource_AREA" class="member-name-link">aiLightSource_AREA</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates all supported types of light sources.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiLightSource_DIRECTIONAL" class="member-name-link">aiLightSource_DIRECTIONAL</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates all supported types of light sources.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiLightSource_POINT" class="member-name-link">aiLightSource_POINT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates all supported types of light sources.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiLightSource_SPOT" class="member-name-link">aiLightSource_SPOT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates all supported types of light sources.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiLightSource_UNDEFINED" class="member-name-link">aiLightSource_UNDEFINED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates all supported types of light sources.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiMorphingMethod_MORPH_NORMALIZED" class="member-name-link">aiMorphingMethod_MORPH_NORMALIZED</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates the methods of mesh morphing supported by Assimp.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiMorphingMethod_MORPH_RELATIVE" class="member-name-link">aiMorphingMethod_MORPH_RELATIVE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates the methods of mesh morphing supported by Assimp.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiMorphingMethod_VERTEX_BLEND" class="member-name-link">aiMorphingMethod_VERTEX_BLEND</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates the methods of mesh morphing supported by Assimp.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiOrigin_CUR" class="member-name-link">aiOrigin_CUR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Seek origins (for the virtual file system API).</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiOrigin_END" class="member-name-link">aiOrigin_END</a></code></div>
<div class="col-last even-row-color">
<div class="block">Seek origins (for the virtual file system API).</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiOrigin_SET" class="member-name-link">aiOrigin_SET</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Seek origins (for the virtual file system API).</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiPrimitiveType_LINE" class="member-name-link">aiPrimitiveType_LINE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates the types of geometric primitives supported by Assimp.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiPrimitiveType_NGONEncodingFlag" class="member-name-link">aiPrimitiveType_NGONEncodingFlag</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates the types of geometric primitives supported by Assimp.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiPrimitiveType_POINT" class="member-name-link">aiPrimitiveType_POINT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates the types of geometric primitives supported by Assimp.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiPrimitiveType_POLYGON" class="member-name-link">aiPrimitiveType_POLYGON</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Enumerates the types of geometric primitives supported by Assimp.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiPrimitiveType_TRIANGLE" class="member-name-link">aiPrimitiveType_TRIANGLE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Enumerates the types of geometric primitives supported by Assimp.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_CalcTangentSpace" class="member-name-link">aiProcess_CalcTangentSpace</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_ConvertToLeftHanded" class="member-name-link">aiProcess_ConvertToLeftHanded</a></code></div>
<div class="col-last even-row-color">
<div class="block">Process Presets</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_Debone" class="member-name-link">aiProcess_Debone</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_DropNormals" class="member-name-link">aiProcess_DropNormals</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_EmbedTextures" class="member-name-link">aiProcess_EmbedTextures</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_FindDegenerates" class="member-name-link">aiProcess_FindDegenerates</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_FindInstances" class="member-name-link">aiProcess_FindInstances</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_FindInvalidData" class="member-name-link">aiProcess_FindInvalidData</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_FixInfacingNormals" class="member-name-link">aiProcess_FixInfacingNormals</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_FlipUVs" class="member-name-link">aiProcess_FlipUVs</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_FlipWindingOrder" class="member-name-link">aiProcess_FlipWindingOrder</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_ForceGenNormals" class="member-name-link">aiProcess_ForceGenNormals</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_GenBoundingBoxes" class="member-name-link">aiProcess_GenBoundingBoxes</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_GenNormals" class="member-name-link">aiProcess_GenNormals</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_GenSmoothNormals" class="member-name-link">aiProcess_GenSmoothNormals</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_GenUVCoords" class="member-name-link">aiProcess_GenUVCoords</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_GlobalScale" class="member-name-link">aiProcess_GlobalScale</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_ImproveCacheLocality" class="member-name-link">aiProcess_ImproveCacheLocality</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_JoinIdenticalVertices" class="member-name-link">aiProcess_JoinIdenticalVertices</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_LimitBoneWeights" class="member-name-link">aiProcess_LimitBoneWeights</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_MakeLeftHanded" class="member-name-link">aiProcess_MakeLeftHanded</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_OptimizeGraph" class="member-name-link">aiProcess_OptimizeGraph</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_OptimizeMeshes" class="member-name-link">aiProcess_OptimizeMeshes</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_PopulateArmatureData" class="member-name-link">aiProcess_PopulateArmatureData</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_PreTransformVertices" class="member-name-link">aiProcess_PreTransformVertices</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_RemoveComponent" class="member-name-link">aiProcess_RemoveComponent</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_RemoveRedundantMaterials" class="member-name-link">aiProcess_RemoveRedundantMaterials</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_SortByPType" class="member-name-link">aiProcess_SortByPType</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_SplitByBoneCount" class="member-name-link">aiProcess_SplitByBoneCount</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_SplitLargeMeshes" class="member-name-link">aiProcess_SplitLargeMeshes</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_TransformUVCoords" class="member-name-link">aiProcess_TransformUVCoords</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcess_Triangulate" class="member-name-link">aiProcess_Triangulate</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcess_ValidateDataStructure" class="member-name-link">aiProcess_ValidateDataStructure</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the flags for all possible post processing steps.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcessPreset_TargetRealtime_Fast" class="member-name-link">aiProcessPreset_TargetRealtime_Fast</a></code></div>
<div class="col-last even-row-color">
<div class="block">Process Presets</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiProcessPreset_TargetRealtime_MaxQuality" class="member-name-link">aiProcessPreset_TargetRealtime_MaxQuality</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Process Presets</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiProcessPreset_TargetRealtime_Quality" class="member-name-link">aiProcessPreset_TargetRealtime_Quality</a></code></div>
<div class="col-last even-row-color">
<div class="block">Process Presets</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiPTI_Buffer" class="member-name-link">aiPTI_Buffer</a></code></div>
<div class="col-last odd-row-color">
<div class="block">A very primitive RTTI system for the contents of material properties.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiPTI_Double" class="member-name-link">aiPTI_Double</a></code></div>
<div class="col-last even-row-color">
<div class="block">A very primitive RTTI system for the contents of material properties.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiPTI_Float" class="member-name-link">aiPTI_Float</a></code></div>
<div class="col-last odd-row-color">
<div class="block">A very primitive RTTI system for the contents of material properties.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiPTI_Integer" class="member-name-link">aiPTI_Integer</a></code></div>
<div class="col-last even-row-color">
<div class="block">A very primitive RTTI system for the contents of material properties.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiPTI_String" class="member-name-link">aiPTI_String</a></code></div>
<div class="col-last odd-row-color">
<div class="block">A very primitive RTTI system for the contents of material properties.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiReturn_FAILURE" class="member-name-link">aiReturn_FAILURE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Standard return type for some library functions, rarely used.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiReturn_OUTOFMEMORY" class="member-name-link">aiReturn_OUTOFMEMORY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Standard return type for some library functions, rarely used.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiReturn_SUCCESS" class="member-name-link">aiReturn_SUCCESS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Standard return type for some library functions, rarely used.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiShadingMode_Blinn" class="member-name-link">aiShadingMode_Blinn</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiShadingMode_CookTorrance" class="member-name-link">aiShadingMode_CookTorrance</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiShadingMode_Flat" class="member-name-link">aiShadingMode_Flat</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiShadingMode_Fresnel" class="member-name-link">aiShadingMode_Fresnel</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiShadingMode_Gouraud" class="member-name-link">aiShadingMode_Gouraud</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiShadingMode_Minnaert" class="member-name-link">aiShadingMode_Minnaert</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiShadingMode_NoShading" class="member-name-link">aiShadingMode_NoShading</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiShadingMode_OrenNayar" class="member-name-link">aiShadingMode_OrenNayar</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiShadingMode_PBR_BRDF" class="member-name-link">aiShadingMode_PBR_BRDF</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiShadingMode_Phong" class="member-name-link">aiShadingMode_Phong</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiShadingMode_Toon" class="member-name-link">aiShadingMode_Toon</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiShadingMode_Unlit" class="member-name-link">aiShadingMode_Unlit</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines all shading models supported by the library.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureFlags_IgnoreAlpha" class="member-name-link">aiTextureFlags_IgnoreAlpha</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines some mixed flags for a particular texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureFlags_Invert" class="member-name-link">aiTextureFlags_Invert</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines some mixed flags for a particular texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureFlags_UseAlpha" class="member-name-link">aiTextureFlags_UseAlpha</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines some mixed flags for a particular texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureMapMode_Clamp" class="member-name-link">aiTextureMapMode_Clamp</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureMapMode_Decal" class="member-name-link">aiTextureMapMode_Decal</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureMapMode_Mirror" class="member-name-link">aiTextureMapMode_Mirror</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureMapMode_Wrap" class="member-name-link">aiTextureMapMode_Wrap</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureMapping_BOX" class="member-name-link">aiTextureMapping_BOX</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how the mapping coords for a texture are generated.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureMapping_CYLINDER" class="member-name-link">aiTextureMapping_CYLINDER</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how the mapping coords for a texture are generated.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureMapping_OTHER" class="member-name-link">aiTextureMapping_OTHER</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how the mapping coords for a texture are generated.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureMapping_PLANE" class="member-name-link">aiTextureMapping_PLANE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how the mapping coords for a texture are generated.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureMapping_SPHERE" class="member-name-link">aiTextureMapping_SPHERE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how the mapping coords for a texture are generated.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureMapping_UV" class="member-name-link">aiTextureMapping_UV</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how the mapping coords for a texture are generated.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureOp_Add" class="member-name-link">aiTextureOp_Add</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureOp_Divide" class="member-name-link">aiTextureOp_Divide</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureOp_Multiply" class="member-name-link">aiTextureOp_Multiply</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureOp_SignedAdd" class="member-name-link">aiTextureOp_SignedAdd</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureOp_SmoothAdd" class="member-name-link">aiTextureOp_SmoothAdd</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureOp_Subtract" class="member-name-link">aiTextureOp_Subtract</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_AMBIENT" class="member-name-link">aiTextureType_AMBIENT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_AMBIENT_OCCLUSION" class="member-name-link">aiTextureType_AMBIENT_OCCLUSION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_BASE_COLOR" class="member-name-link">aiTextureType_BASE_COLOR</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_CLEARCOAT" class="member-name-link">aiTextureType_CLEARCOAT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_DIFFUSE" class="member-name-link">aiTextureType_DIFFUSE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_DIFFUSE_ROUGHNESS" class="member-name-link">aiTextureType_DIFFUSE_ROUGHNESS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_DISPLACEMENT" class="member-name-link">aiTextureType_DISPLACEMENT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_EMISSION_COLOR" class="member-name-link">aiTextureType_EMISSION_COLOR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_EMISSIVE" class="member-name-link">aiTextureType_EMISSIVE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_HEIGHT" class="member-name-link">aiTextureType_HEIGHT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_LIGHTMAP" class="member-name-link">aiTextureType_LIGHTMAP</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_METALNESS" class="member-name-link">aiTextureType_METALNESS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_NONE" class="member-name-link">aiTextureType_NONE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_NORMAL_CAMERA" class="member-name-link">aiTextureType_NORMAL_CAMERA</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_NORMALS" class="member-name-link">aiTextureType_NORMALS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_OPACITY" class="member-name-link">aiTextureType_OPACITY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_REFLECTION" class="member-name-link">aiTextureType_REFLECTION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_SHEEN" class="member-name-link">aiTextureType_SHEEN</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_SHININESS" class="member-name-link">aiTextureType_SHININESS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_SPECULAR" class="member-name-link">aiTextureType_SPECULAR</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#aiTextureType_TRANSMISSION" class="member-name-link">aiTextureType_TRANSMISSION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#aiTextureType_UNKNOWN" class="member-name-link">aiTextureType_UNKNOWN</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Defines the purpose of a texture.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ASSIMP_CFLAGS_DEBUG" class="member-name-link">ASSIMP_CFLAGS_DEBUG</a></code></div>
<div class="col-last even-row-color">
<div class="block">Assimp was compiled as a debug build</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ASSIMP_CFLAGS_DOUBLE_SUPPORT" class="member-name-link">ASSIMP_CFLAGS_DOUBLE_SUPPORT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Assimp was compiled with <code>ASSIMP_DOUBLE_PRECISION</code> defined</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ASSIMP_CFLAGS_NOBOOST" class="member-name-link">ASSIMP_CFLAGS_NOBOOST</a></code></div>
<div class="col-last even-row-color">
<div class="block">Assimp was compiled with <code>ASSIMP_BUILD_BOOST_WORKAROUND</code> defined</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ASSIMP_CFLAGS_SHARED" class="member-name-link">ASSIMP_CFLAGS_SHARED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Assimp was compiled as a shared object (Windows: DLL)</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#ASSIMP_CFLAGS_SINGLETHREADED" class="member-name-link">ASSIMP_CFLAGS_SINGLETHREADED</a></code></div>
<div class="col-last even-row-color">
<div class="block">Assimp was compiled with <code>ASSIMP_BUILD_SINGLETHREADED</code> defined</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#ASSIMP_CFLAGS_STLPORT" class="member-name-link">ASSIMP_CFLAGS_STLPORT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Assimp was compiled against STLport</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MAXLEN" class="member-name-link">MAXLEN</a></code></div>
<div class="col-last even-row-color">
<div class="block">Maximum dimension for strings, ASSIMP strings are zero terminated.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#PP_ICL_PTCACHE_SIZE" class="member-name-link">PP_ICL_PTCACHE_SIZE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Default values for configuration properties.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#AI_DEG_TO_RAD(float)" class="member-name-link">AI_DEG_TO_RAD</a><wbr>(float&nbsp;x)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Tiny macro to convert from degrees to radians</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#AI_RAD_TO_DEG(float)" class="member-name-link">AI_RAD_TO_DEG</a><wbr>(float&nbsp;x)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Tiny macro to convert from radians to degrees</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)" class="member-name-link">aiApplyPostProcessing</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 int&nbsp;pFlags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Apply post-processing to an already-imported scene.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiAttachLogStream(org.lwjgl.assimp.AILogStream)" class="member-name-link">aiAttachLogStream</a><wbr>(<a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;stream)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Attach a custom log stream to the libraries' logging system.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiComponent_COLORSn(int)" class="member-name-link">aiComponent_COLORSn</a><wbr>(int&nbsp;n)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Remove a specific color channel 'n'</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiComponent_TEXCOORDSn(int)" class="member-name-link">aiComponent_TEXCOORDSn</a><wbr>(int&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Remove a specific UV channel 'n'</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiCopyScene(org.lwjgl.assimp.AIScene)" class="member-name-link">aiCopyScene</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a modifiable copy of a scene.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)" class="member-name-link">aiCopyScene</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a modifiable copy of a scene.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiCreatePropertyStore()" class="member-name-link">aiCreatePropertyStore</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create an empty property store.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiCreateQuaternionFromMatrix(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiCreateQuaternionFromMatrix</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;quat,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Construct a quaternion from a 3x3 rotation matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiDecomposeMatrix(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiDecomposeMatrix</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decompose a transformation matrix into its rotational, translational and scaling components.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiDetachAllLogStreams()" class="member-name-link">aiDetachAllLogStreams</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Detach all active log streams from the libraries' logging system.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiDetachLogStream(org.lwjgl.assimp.AILogStream)" class="member-name-link">aiDetachLogStream</a><wbr>(<a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;stream)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Detach a custom log stream from the libraries' logging system.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiEnableVerboseLogging(boolean)" class="member-name-link">aiEnableVerboseLogging</a><wbr>(boolean&nbsp;d)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Enable verbose logging.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiExportScene(org.lwjgl.assimp.AIScene,java.lang.CharSequence,java.lang.CharSequence,int)" class="member-name-link">aiExportScene</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFileName,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Exports the given scene to a chosen file format and writes the result file(s) to disk.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiExportScene(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,int)" class="member-name-link">aiExportScene</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFileName,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Exports the given scene to a chosen file format and writes the result file(s) to disk.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiExportSceneEx(org.lwjgl.assimp.AIScene,java.lang.CharSequence,java.lang.CharSequence,org.lwjgl.assimp.AIFileIO,int)" class="member-name-link">aiExportSceneEx</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFileName,
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pIO,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Exports the given scene to a chosen file format using custom IO logic supplied by you.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiExportSceneEx(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,org.lwjgl.assimp.AIFileIO,int)" class="member-name-link">aiExportSceneEx</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFileName,
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pIO,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Exports the given scene to a chosen file format using custom IO logic supplied by you.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIExportDataBlob.html" title="class in org.lwjgl.assimp">AIExportDataBlob</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.lang.CharSequence,int)" class="member-name-link">aiExportSceneToBlob</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFormatId,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Exports the given scene to a chosen file format.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIExportDataBlob.html" title="class in org.lwjgl.assimp">AIExportDataBlob</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)" class="member-name-link">aiExportSceneToBlob</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFormatId,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Exports the given scene to a chosen file format.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiFreeScene(org.lwjgl.assimp.AIScene)" class="member-name-link">aiFreeScene</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Frees a scene copy created using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetBranchName()" class="member-name-link">aiGetBranchName</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the branch name of the Assimp runtime.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetCompileFlags()" class="member-name-link">aiGetCompileFlags</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns assimp's compile flags.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetErrorString()" class="member-name-link">aiGetErrorString</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the error text of the last failed import process.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetExportFormatCount()" class="member-name-link">aiGetExportFormatCount</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the number of export file formats available in the current Assimp build.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIExportFormatDesc.html" title="class in org.lwjgl.assimp">AIExportFormatDesc</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetExportFormatDescription(long)" class="member-name-link">aiGetExportFormatDescription</a><wbr>(long&nbsp;pIndex)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a description of the nth export file format.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetExtensionList(org.lwjgl.assimp.AIString)" class="member-name-link">aiGetExtensionList</a><wbr>(<a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;szOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a list of all file extensions supported by ASSIMP.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp">AIImporterDesc</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetImporterDesc(java.lang.CharSequence)" class="member-name-link">aiGetImporterDesc</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;extension)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the Importer description for a given extension.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp">AIImporterDesc</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetImporterDesc(java.nio.ByteBuffer)" class="member-name-link">aiGetImporterDesc</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;extension)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the Importer description for a given extension.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetImportFormatCount()" class="member-name-link">aiGetImportFormatCount</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the number of import file formats available in the current Assimp build.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp">AIImporterDesc</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetImportFormatDescription(long)" class="member-name-link">aiGetImportFormatDescription</a><wbr>(long&nbsp;pIndex)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a description of the nth import file format.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetLegalString()" class="member-name-link">aiGetLegalString</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a string with legal copyright and licensing information about Assimp.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialColor(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.assimp.AIColor4D)" class="member-name-link">aiGetMaterialColor</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIColor4D.html" title="class in org.lwjgl.assimp">AIColor4D</a>&nbsp;pOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a color value with a specific key from a material.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialColor(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIColor4D)" class="member-name-link">aiGetMaterialColor</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIColor4D.html" title="class in org.lwjgl.assimp">AIColor4D</a>&nbsp;pOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a color value with a specific key from a material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,float%5B%5D,int%5B%5D)" class="member-name-link">aiGetMaterialFloatArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 float[]&nbsp;pOut,
 int[]&nbsp;pMax)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)"><code>GetMaterialFloatArray</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)" class="member-name-link">aiGetMaterialFloatArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;pOut,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve an array of float values with a specific key from the material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,float%5B%5D,int%5B%5D)" class="member-name-link">aiGetMaterialFloatArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 float[]&nbsp;pOut,
 int[]&nbsp;pMax)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)"><code>GetMaterialFloatArray</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)" class="member-name-link">aiGetMaterialFloatArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;pOut,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve an array of float values with a specific key from the material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,int%5B%5D,int%5B%5D)" class="member-name-link">aiGetMaterialIntegerArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 int[]&nbsp;pOut,
 int[]&nbsp;pMax)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialIntegerArray</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,java.nio.IntBuffer,java.nio.IntBuffer)" class="member-name-link">aiGetMaterialIntegerArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pOut,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve an array of integer values with a specific key from a material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,int%5B%5D,int%5B%5D)" class="member-name-link">aiGetMaterialIntegerArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 int[]&nbsp;pOut,
 int[]&nbsp;pMax)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialIntegerArray</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)" class="member-name-link">aiGetMaterialIntegerArray</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pOut,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve an array of integer values with a specific key from a material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.PointerBuffer)" class="member-name-link">aiGetMaterialProperty</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a material property with a specific key from the material.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,org.lwjgl.PointerBuffer)" class="member-name-link">aiGetMaterialProperty</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a material property with a specific key from the material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.PointerBuffer)" class="member-name-link">aiGetMaterialProperty</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a material property with a specific key from the material.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,org.lwjgl.PointerBuffer)" class="member-name-link">aiGetMaterialProperty</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a material property with a specific key from the material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialString(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.assimp.AIString)" class="member-name-link">aiGetMaterialString</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;pOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a string value with a specific key from a material.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialString(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIString)" class="member-name-link">aiGetMaterialString</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;pOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a string value with a specific key from a material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,int%5B%5D,int%5B%5D,float%5B%5D,int%5B%5D,int%5B%5D,int%5B%5D)" class="member-name-link">aiGetMaterialTexture</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;path,
 int[]&nbsp;mapping,
 int[]&nbsp;uvindex,
 float[]&nbsp;blend,
 int[]&nbsp;op,
 int[]&nbsp;mapmode,
 int[]&nbsp;flags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialTexture</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer)" class="member-name-link">aiGetMaterialTexture</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;path,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;mapping,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;uvindex,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;blend,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;op,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;mapmode,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Helper function to get all values pertaining to a particular
 texture slot from a material structure.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialTextureCount(org.lwjgl.assimp.AIMaterial,int)" class="member-name-link">aiGetMaterialTextureCount</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 int&nbsp;type)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the number of textures for a particular texture type.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialUVTransform(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.assimp.AIUVTransform)" class="member-name-link">aiGetMaterialUVTransform</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIUVTransform.html" title="class in org.lwjgl.assimp">AIUVTransform</a>&nbsp;pOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a UVTransform value with a specific key from a material.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMaterialUVTransform(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIUVTransform)" class="member-name-link">aiGetMaterialUVTransform</a><wbr>(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIUVTransform.html" title="class in org.lwjgl.assimp">AIUVTransform</a>&nbsp;pOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Retrieve a UVTransform value with a specific key from a material.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetMemoryRequirements(org.lwjgl.assimp.AIScene,org.lwjgl.assimp.AIMemoryInfo)" class="member-name-link">aiGetMemoryRequirements</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn,
 <a href="AIMemoryInfo.html" title="class in org.lwjgl.assimp">AIMemoryInfo</a>&nbsp;in)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the approximated storage required by an imported asset.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetPredefinedLogStream(int,java.lang.CharSequence,org.lwjgl.assimp.AILogStream)" class="member-name-link">aiGetPredefinedLogStream</a><wbr>(int&nbsp;pStreams,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;file,
 <a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;__result)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get one of the predefine log streams.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetPredefinedLogStream(int,java.nio.ByteBuffer,org.lwjgl.assimp.AILogStream)" class="member-name-link">aiGetPredefinedLogStream</a><wbr>(int&nbsp;pStreams,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;file,
 <a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;__result)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get one of the predefine log streams.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetVersionMajor()" class="member-name-link">aiGetVersionMajor</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the current major version number of Assimp.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetVersionMinor()" class="member-name-link">aiGetVersionMinor</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the current minor version number of Assimp.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetVersionPatch()" class="member-name-link">aiGetVersionPatch</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the current patch version number of Assimp.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiGetVersionRevision()" class="member-name-link">aiGetVersionRevision</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the repository revision of the Assimp runtime.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiIdentityMatrix3(org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiIdentityMatrix3</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 3x3 identity matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiIdentityMatrix4(org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiIdentityMatrix4</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 4x4 identity matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFile(java.lang.CharSequence,int)" class="member-name-link">aiImportFile</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFile,
 int&nbsp;pFlags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Reads the given file and returns its content.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFile(java.nio.ByteBuffer,int)" class="member-name-link">aiImportFile</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFile,
 int&nbsp;pFlags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Reads the given file and returns its content.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileEx(java.lang.CharSequence,int,org.lwjgl.assimp.AIFileIO)" class="member-name-link">aiImportFileEx</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFile,
 int&nbsp;pFlags,
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Reads the given file using user-defined I/O functions and returns its content.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)" class="member-name-link">aiImportFileEx</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFile,
 int&nbsp;pFlags,
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Reads the given file using user-defined I/O functions and returns its content.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileExWithProperties(java.lang.CharSequence,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)" class="member-name-link">aiImportFileExWithProperties</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFile,
 int&nbsp;pFlags,
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Same as <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a>, but adds an extra parameter containing importer settings.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileExWithProperties(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)" class="member-name-link">aiImportFileExWithProperties</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFile,
 int&nbsp;pFlags,
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Same as <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a>, but adds an extra parameter containing importer settings.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.lang.CharSequence)" class="member-name-link">aiImportFileFromMemory</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pHint)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Reads the given file from a given memory buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)" class="member-name-link">aiImportFileFromMemory</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pHint)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Reads the given file from a given memory buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileFromMemoryWithProperties(java.nio.ByteBuffer,int,java.lang.CharSequence,org.lwjgl.assimp.AIPropertyStore)" class="member-name-link">aiImportFileFromMemoryWithProperties</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pHint,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Same as <a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)"><code>ImportFileFromMemory</code></a>, but adds an extra parameter containing importer settings.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiImportFileFromMemoryWithProperties(java.nio.ByteBuffer,int,java.nio.ByteBuffer,org.lwjgl.assimp.AIPropertyStore)" class="member-name-link">aiImportFileFromMemoryWithProperties</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pHint,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Same as <a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)"><code>ImportFileFromMemory</code></a>, but adds an extra parameter containing importer settings.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiIsExtensionSupported(java.lang.CharSequence)" class="member-name-link">aiIsExtensionSupported</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szExtension)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns whether a given file extension is supported by ASSIMP.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiIsExtensionSupported(java.nio.ByteBuffer)" class="member-name-link">aiIsExtensionSupported</a><wbr>(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szExtension)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns whether a given file extension is supported by ASSIMP.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3AreEqual(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiMatrix3AreEqual</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;a,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 3x3 matrices are equal.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3AreEqualEpsilon(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3,float)" class="member-name-link">aiMatrix3AreEqualEpsilon</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;a,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 3x3 matrices are equal.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3Determinant(org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiMatrix3Determinant</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the determinant of a 3x3 matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3FromMatrix4(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiMatrix3FromMatrix4</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;dst,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Construct a 3x3 matrix from a 4x4 matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3FromQuaternion(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIQuaternion)" class="member-name-link">aiMatrix3FromQuaternion</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Construct a 3x3 matrix from a quaternion.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,float)" class="member-name-link">aiMatrix3FromRotationAroundAxis</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3FromTo(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix3FromTo</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;from,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;to)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a 3x3 matrix that rotates one vector to another vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3Inverse(org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiMatrix3Inverse</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Invert a 3x3 matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3RotationZ(org.lwjgl.assimp.AIMatrix3x3,float)" class="member-name-link">aiMatrix3RotationZ</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 3x3 rotation matrix around the Z axis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix3Translation(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiMatrix3Translation</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;translation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 3x3 translation matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4Add(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiMatrix4Add</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;dst,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Add 4x4 matrices.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4AreEqual(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiMatrix4AreEqual</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;a,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 4x4 matrices are equal.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4AreEqualEpsilon(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4,float)" class="member-name-link">aiMatrix4AreEqualEpsilon</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;a,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 4x4 matrices are equal.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,float%5B%5D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4DecomposeIntoScalingAxisAnglePosition</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float[]&nbsp;angle,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Array version of: <a href="#aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,java.nio.FloatBuffer,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeIntoScalingAxisAnglePosition</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,java.nio.FloatBuffer,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4DecomposeIntoScalingAxisAnglePosition</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;angle,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decompose a transformation matrix into its scaling, rotational split into an axis and rotational angle, and it's translational components.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4DecomposeIntoScalingEulerAnglesPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4DecomposeIntoScalingEulerAnglesPosition</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decompose a transformation matrix into its scaling, rotational as euler angles, and translational components.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4DecomposeNoScaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4DecomposeNoScaling</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decompose a transformation matrix into its rotational and translational components.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4Determinant(org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiMatrix4Determinant</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the determinant of a 4x4 matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4FromEulerAngles(org.lwjgl.assimp.AIMatrix4x4,float,float,float)" class="member-name-link">aiMatrix4FromEulerAngles</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Creates a 4x4 matrix from a set of euler angles.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4FromMatrix3(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiMatrix4FromMatrix3</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;dst,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Construct a 4x4 matrix from a 3x3 matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,float)" class="member-name-link">aiMatrix4FromRotationAroundAxis</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4FromScalingQuaternionPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4FromScalingQuaternionPosition</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Construct a 4x4 matrix from scaling, rotation and position.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4FromTo(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4FromTo</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;from,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;to)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a 4x4 matrix that rotates one vector to another vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4Inverse(org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiMatrix4Inverse</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Invert a 4x4 matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4IsIdentity(org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiMatrix4IsIdentity</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns true of the matrix is the identity matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4RotationX(org.lwjgl.assimp.AIMatrix4x4,float)" class="member-name-link">aiMatrix4RotationX</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 4x4 rotation matrix around the X axis.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4RotationY(org.lwjgl.assimp.AIMatrix4x4,float)" class="member-name-link">aiMatrix4RotationY</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 4x4 rotation matrix around the Y axis.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4RotationZ(org.lwjgl.assimp.AIMatrix4x4,float)" class="member-name-link">aiMatrix4RotationZ</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 4x4 rotation matrix around the Z axis.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4Scaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4Scaling</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 4x4 scaling matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMatrix4Translation(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiMatrix4Translation</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;translation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a 4x4 translation matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMultiplyMatrix3(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiMultiplyMatrix3</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;dst,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Multiply two 3x3 matrices.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiMultiplyMatrix4(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiMultiplyMatrix4</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;dst,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;src)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Multiply two 4x4 matrices.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionAreEqual(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)" class="member-name-link">aiQuaternionAreEqual</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;a,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if quaternions are equal.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionAreEqualEpsilon(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)" class="member-name-link">aiQuaternionAreEqualEpsilon</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;a,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if quaternions are equal using epsilon.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionConjugate(org.lwjgl.assimp.AIQuaternion)" class="member-name-link">aiQuaternionConjugate</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Compute quaternion conjugate.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionFromAxisAngle(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D,float)" class="member-name-link">aiQuaternionFromAxisAngle</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a Quaternion from an axis angle pair.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionFromEulerAngles(org.lwjgl.assimp.AIQuaternion,float,float,float)" class="member-name-link">aiQuaternionFromEulerAngles</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a Quaternion from euler angles.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionFromNormalizedQuaternion(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiQuaternionFromNormalizedQuaternion</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;normalized)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a Quaternion from a normalized quaternion stored in a 3D vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionInterpolate(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)" class="member-name-link">aiQuaternionInterpolate</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;dst,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;start,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;end,
 float&nbsp;factor)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Performs a spherical interpolation between two quaternions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionMultiply(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)" class="member-name-link">aiQuaternionMultiply</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;dst,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Multiply quaternions.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiQuaternionNormalize(org.lwjgl.assimp.AIQuaternion)" class="member-name-link">aiQuaternionNormalize</a><wbr>(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Normalize a quaternion.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiReleaseExportBlob(org.lwjgl.assimp.AIExportDataBlob)" class="member-name-link">aiReleaseExportBlob</a><wbr>(<a href="AIExportDataBlob.html" title="class in org.lwjgl.assimp">AIExportDataBlob</a>&nbsp;pData)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Releases the memory associated with the given exported data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiReleaseExportFormatDescription(org.lwjgl.assimp.AIExportFormatDesc)" class="member-name-link">aiReleaseExportFormatDescription</a><wbr>(<a href="AIExportFormatDesc.html" title="class in org.lwjgl.assimp">AIExportFormatDesc</a>&nbsp;desc)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Release a description of the nth export file format.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)" class="member-name-link">aiReleaseImport</a><wbr>(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Releases all resources associated with the given import process.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiReleasePropertyStore(org.lwjgl.assimp.AIPropertyStore)" class="member-name-link">aiReleasePropertyStore</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;p)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Delete a property store.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyFloat(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,float)" class="member-name-link">aiSetImportPropertyFloat</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 float&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set an floating-point property.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyFloat(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,float)" class="member-name-link">aiSetImportPropertyFloat</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 float&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set an floating-point property.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyInteger(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,int)" class="member-name-link">aiSetImportPropertyInteger</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 int&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set an integer property.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyInteger(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,int)" class="member-name-link">aiSetImportPropertyInteger</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 int&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set an integer property.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyMatrix(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiSetImportPropertyMatrix</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set a matrix property.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyMatrix(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiSetImportPropertyMatrix</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set a matrix property.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyString(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,org.lwjgl.assimp.AIString)" class="member-name-link">aiSetImportPropertyString</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set a string property.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiSetImportPropertyString(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIString)" class="member-name-link">aiSetImportPropertyString</a><wbr>(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Set a string property.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiTextureTypeToString(int)" class="member-name-link">aiTextureTypeToString</a><wbr>(int&nbsp;in)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get a string for a given <code>aiTextureType</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiTransformVecByMatrix3(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiTransformVecByMatrix3</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;vec,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Transform a vector by a 3x3 matrix</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiTransformVecByMatrix4(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiTransformVecByMatrix4</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;vec,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Transform a vector by a 4x4 matrix</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiTransposeMatrix3(org.lwjgl.assimp.AIMatrix3x3)" class="member-name-link">aiTransposeMatrix3</a><wbr>(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Transpose a 3x3 matrix.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiTransposeMatrix4(org.lwjgl.assimp.AIMatrix4x4)" class="member-name-link">aiTransposeMatrix4</a><wbr>(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Transpose a 4x4 matrix.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2Add(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2Add</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Add 2D vectors.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2AreEqual(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2AreEqual</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;a,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 2D vectors are equal.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2AreEqualEpsilon(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D,float)" class="member-name-link">aiVector2AreEqualEpsilon</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;a,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 2D vectors are equal using epsilon.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2DivideByScalar(org.lwjgl.assimp.AIVector2D,float)" class="member-name-link">aiVector2DivideByScalar</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Divide a 2D vector by a scalar.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2DivideByVector(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2DivideByVector</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Divide each component of a 2D vector by the components of another vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2DotProduct(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2DotProduct</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;a,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the dot product of 2D vectors.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2Length(org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2Length</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the length of a 2D vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2Negate(org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2Negate</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Negate a 2D vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2Normalize(org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2Normalize</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Normalize a 2D vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2Scale(org.lwjgl.assimp.AIVector2D,float)" class="member-name-link">aiVector2Scale</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Multiply a 2D vector by a scalar.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2SquareLength(org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2SquareLength</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the squared length of a 2D vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2Subtract(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2Subtract</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;src)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Subtract 2D vectors.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector2SymMul(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)" class="member-name-link">aiVector2SymMul</a><wbr>(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;other)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Multiply each component of a 2D vector with the components of another vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3Add(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3Add</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;src)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Add 3D vectors.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3AreEqual(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3AreEqual</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 3D vectors are equal.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3AreEqualEpsilon(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,float)" class="member-name-link">aiVector3AreEqualEpsilon</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if 3D vectors are equal using epsilon.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3CrossProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3CrossProduct</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get cross product of 3D vectors.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3DivideByScalar(org.lwjgl.assimp.AIVector3D,float)" class="member-name-link">aiVector3DivideByScalar</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Divide a 3D vector by a scalar.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3DivideByVector(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3DivideByVector</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Divide each component of a 3D vector by the components of another vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3DotProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3DotProduct</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the dot product of 3D vectors.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3Length(org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3Length</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the length of a 3D vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3LessThan(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3LessThan</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check if vector <code>a</code> is less than vector <code>b</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3Negate(org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3Negate</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Negate a 3D vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3Normalize(org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3Normalize</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Normalize a 3D vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3NormalizeSafe(org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3NormalizeSafe</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Check for division by zero and normalize a 3D vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3RotateByQuaternion(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion)" class="member-name-link">aiVector3RotateByQuaternion</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Rotate a 3D vector by a quaternion.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3Scale(org.lwjgl.assimp.AIVector3D,float)" class="member-name-link">aiVector3Scale</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Multiply a 3D vector by a scalar.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3SquareLength(org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3SquareLength</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Get the squared length of a 3D vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3Subtract(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3Subtract</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Subtract 3D vectors.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#aiVector3SymMul(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)" class="member-name-link">aiVector3SymMul</a><wbr>(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;other)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Multiply each component of a 3D vector with the components of another vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system">SharedLibrary</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#getDraco()" class="member-name-link">getDraco</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the Draco <a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system"><code>SharedLibrary</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system">SharedLibrary</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#getLibrary()" class="member-name-link">getLibrary</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the assimp <a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system"><code>SharedLibrary</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiApplyPostProcessing(long,int)" class="member-name-link">naiApplyPostProcessing</a><wbr>(long&nbsp;pScene,
 int&nbsp;pFlags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiAttachLogStream(long)" class="member-name-link">naiAttachLogStream</a><wbr>(long&nbsp;stream)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiAttachLogStream(org.lwjgl.assimp.AILogStream)"><code>AttachLogStream</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiCopyScene(long,long)" class="member-name-link">naiCopyScene</a><wbr>(long&nbsp;pIn,
 long&nbsp;pOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiCreatePropertyStore()" class="member-name-link">naiCreatePropertyStore</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiCreateQuaternionFromMatrix(long,long)" class="member-name-link">naiCreateQuaternionFromMatrix</a><wbr>(long&nbsp;quat,
 long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiCreateQuaternionFromMatrix(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIMatrix3x3)"><code>CreateQuaternionFromMatrix</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiDecomposeMatrix(long,long,long,long)" class="member-name-link">naiDecomposeMatrix</a><wbr>(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;rotation,
 long&nbsp;position)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiDecomposeMatrix(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>DecomposeMatrix</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiDetachLogStream(long)" class="member-name-link">naiDetachLogStream</a><wbr>(long&nbsp;stream)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiDetachLogStream(org.lwjgl.assimp.AILogStream)"><code>DetachLogStream</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiExportScene(long,long,long,int)" class="member-name-link">naiExportScene</a><wbr>(long&nbsp;pScene,
 long&nbsp;pFormatId,
 long&nbsp;pFileName,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiExportScene(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>ExportScene</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiExportSceneEx(long,long,long,long,int)" class="member-name-link">naiExportSceneEx</a><wbr>(long&nbsp;pScene,
 long&nbsp;pFormatId,
 long&nbsp;pFileName,
 long&nbsp;pIO,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiExportSceneEx(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,org.lwjgl.assimp.AIFileIO,int)"><code>ExportSceneEx</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiExportSceneToBlob(long,long,int)" class="member-name-link">naiExportSceneToBlob</a><wbr>(long&nbsp;pScene,
 long&nbsp;pFormatId,
 int&nbsp;pPreProcessing)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)"><code>ExportSceneToBlob</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiFreeScene(long)" class="member-name-link">naiFreeScene</a><wbr>(long&nbsp;pIn)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiFreeScene(org.lwjgl.assimp.AIScene)"><code>FreeScene</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetBranchName()" class="member-name-link">naiGetBranchName</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetBranchName()"><code>GetBranchName</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetErrorString()" class="member-name-link">naiGetErrorString</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetErrorString()"><code>GetErrorString</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetExportFormatDescription(long)" class="member-name-link">naiGetExportFormatDescription</a><wbr>(long&nbsp;pIndex)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetExtensionList(long)" class="member-name-link">naiGetExtensionList</a><wbr>(long&nbsp;szOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetExtensionList(org.lwjgl.assimp.AIString)"><code>GetExtensionList</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetImporterDesc(long)" class="member-name-link">naiGetImporterDesc</a><wbr>(long&nbsp;extension)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetImporterDesc(java.nio.ByteBuffer)"><code>GetImporterDesc</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetImportFormatDescription(long)" class="member-name-link">naiGetImportFormatDescription</a><wbr>(long&nbsp;pIndex)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetImportFormatDescription(long)"><code>GetImportFormatDescription</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetLegalString()" class="member-name-link">naiGetLegalString</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetLegalString()"><code>GetLegalString</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialColor(long,long,int,int,long)" class="member-name-link">naiGetMaterialColor</a><wbr>(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialColor(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIColor4D)"><code>GetMaterialColor</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialFloatArray(long,long,int,int,long,long)" class="member-name-link">naiGetMaterialFloatArray</a><wbr>(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut,
 long&nbsp;pMax)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)"><code>GetMaterialFloatArray</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialIntegerArray(long,long,int,int,long,long)" class="member-name-link">naiGetMaterialIntegerArray</a><wbr>(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut,
 long&nbsp;pMax)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialIntegerArray</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialProperty(long,long,int,int,long)" class="member-name-link">naiGetMaterialProperty</a><wbr>(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;mPropOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.PointerBuffer)"><code>GetMaterialProperty</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialString(long,long,int,int,long)" class="member-name-link">naiGetMaterialString</a><wbr>(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialString(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIString)"><code>GetMaterialString</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialTexture(long,int,int,long,long,long,long,long,long,long)" class="member-name-link">naiGetMaterialTexture</a><wbr>(long&nbsp;pMat,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;path,
 long&nbsp;mapping,
 long&nbsp;uvindex,
 long&nbsp;blend,
 long&nbsp;op,
 long&nbsp;mapmode,
 long&nbsp;flags)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialTexture</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialTextureCount(long,int)" class="member-name-link">naiGetMaterialTextureCount</a><wbr>(long&nbsp;pMat,
 int&nbsp;type)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialTextureCount(org.lwjgl.assimp.AIMaterial,int)"><code>GetMaterialTextureCount</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMaterialUVTransform(long,long,int,int,long)" class="member-name-link">naiGetMaterialUVTransform</a><wbr>(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMaterialUVTransform(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIUVTransform)"><code>GetMaterialUVTransform</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetMemoryRequirements(long,long)" class="member-name-link">naiGetMemoryRequirements</a><wbr>(long&nbsp;pIn,
 long&nbsp;in)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetMemoryRequirements(org.lwjgl.assimp.AIScene,org.lwjgl.assimp.AIMemoryInfo)"><code>GetMemoryRequirements</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiGetPredefinedLogStream(int,long,long)" class="member-name-link">naiGetPredefinedLogStream</a><wbr>(int&nbsp;pStreams,
 long&nbsp;file,
 long&nbsp;__result)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiGetPredefinedLogStream(int,java.nio.ByteBuffer,org.lwjgl.assimp.AILogStream)"><code>GetPredefinedLogStream</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiIdentityMatrix3(long)" class="member-name-link">naiIdentityMatrix3</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiIdentityMatrix3(org.lwjgl.assimp.AIMatrix3x3)"><code>IdentityMatrix3</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiIdentityMatrix4(long)" class="member-name-link">naiIdentityMatrix4</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiIdentityMatrix4(org.lwjgl.assimp.AIMatrix4x4)"><code>IdentityMatrix4</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiImportFile(long,int)" class="member-name-link">naiImportFile</a><wbr>(long&nbsp;pFile,
 int&nbsp;pFlags)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiImportFile(java.nio.ByteBuffer,int)"><code>ImportFile</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiImportFileEx(long,int,long)" class="member-name-link">naiImportFileEx</a><wbr>(long&nbsp;pFile,
 int&nbsp;pFlags,
 long&nbsp;pFS)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiImportFileExWithProperties(long,int,long,long)" class="member-name-link">naiImportFileExWithProperties</a><wbr>(long&nbsp;pFile,
 int&nbsp;pFlags,
 long&nbsp;pFS,
 long&nbsp;pProps)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiImportFileExWithProperties(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)"><code>ImportFileExWithProperties</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiImportFileFromMemory(long,int,int,long)" class="member-name-link">naiImportFileFromMemory</a><wbr>(long&nbsp;pBuffer,
 int&nbsp;pLength,
 int&nbsp;pFlags,
 long&nbsp;pHint)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)"><code>ImportFileFromMemory</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiImportFileFromMemoryWithProperties(long,int,int,long,long)" class="member-name-link">naiImportFileFromMemoryWithProperties</a><wbr>(long&nbsp;pBuffer,
 int&nbsp;pLength,
 int&nbsp;pFlags,
 long&nbsp;pHint,
 long&nbsp;pProps)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiImportFileFromMemoryWithProperties(java.nio.ByteBuffer,int,java.nio.ByteBuffer,org.lwjgl.assimp.AIPropertyStore)"><code>ImportFileFromMemoryWithProperties</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiIsExtensionSupported(long)" class="member-name-link">naiIsExtensionSupported</a><wbr>(long&nbsp;szExtension)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiIsExtensionSupported(java.nio.ByteBuffer)"><code>IsExtensionSupported</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3AreEqual(long,long)" class="member-name-link">naiMatrix3AreEqual</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3AreEqual(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix3AreEqual</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3AreEqualEpsilon(long,long,float)" class="member-name-link">naiMatrix3AreEqualEpsilon</a><wbr>(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3AreEqualEpsilon(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3,float)"><code>Matrix3AreEqualEpsilon</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3Determinant(long)" class="member-name-link">naiMatrix3Determinant</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3Determinant(org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix3Determinant</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3FromMatrix4(long,long)" class="member-name-link">naiMatrix3FromMatrix4</a><wbr>(long&nbsp;dst,
 long&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3FromMatrix4(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix3FromMatrix4</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3FromQuaternion(long,long)" class="member-name-link">naiMatrix3FromQuaternion</a><wbr>(long&nbsp;mat,
 long&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3FromQuaternion(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIQuaternion)"><code>Matrix3FromQuaternion</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3FromRotationAroundAxis(long,long,float)" class="member-name-link">naiMatrix3FromRotationAroundAxis</a><wbr>(long&nbsp;mat,
 long&nbsp;axis,
 float&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,float)"><code>Matrix3FromRotationAroundAxis</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3FromTo(long,long,long)" class="member-name-link">naiMatrix3FromTo</a><wbr>(long&nbsp;mat,
 long&nbsp;from,
 long&nbsp;to)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3FromTo(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Matrix3FromTo</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3Inverse(long)" class="member-name-link">naiMatrix3Inverse</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3Inverse(org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix3Inverse</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3RotationZ(long,float)" class="member-name-link">naiMatrix3RotationZ</a><wbr>(long&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3RotationZ(org.lwjgl.assimp.AIMatrix3x3,float)"><code>Matrix3RotationZ</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix3Translation(long,long)" class="member-name-link">naiMatrix3Translation</a><wbr>(long&nbsp;mat,
 long&nbsp;translation)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix3Translation(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector2D)"><code>Matrix3Translation</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4Add(long,long)" class="member-name-link">naiMatrix4Add</a><wbr>(long&nbsp;dst,
 long&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4Add(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4Add</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4AreEqual(long,long)" class="member-name-link">naiMatrix4AreEqual</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4AreEqual(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4AreEqual</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4AreEqualEpsilon(long,long,float)" class="member-name-link">naiMatrix4AreEqualEpsilon</a><wbr>(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4AreEqualEpsilon(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4AreEqualEpsilon</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4DecomposeIntoScalingAxisAnglePosition(long,long,long,long,long)" class="member-name-link">naiMatrix4DecomposeIntoScalingAxisAnglePosition</a><wbr>(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;axis,
 long&nbsp;angle,
 long&nbsp;position)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,java.nio.FloatBuffer,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeIntoScalingAxisAnglePosition</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4DecomposeIntoScalingEulerAnglesPosition(long,long,long,long)" class="member-name-link">naiMatrix4DecomposeIntoScalingEulerAnglesPosition</a><wbr>(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;rotation,
 long&nbsp;position)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4DecomposeIntoScalingEulerAnglesPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeIntoScalingEulerAnglesPosition</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4DecomposeNoScaling(long,long,long)" class="member-name-link">naiMatrix4DecomposeNoScaling</a><wbr>(long&nbsp;mat,
 long&nbsp;rotation,
 long&nbsp;position)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4DecomposeNoScaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeNoScaling</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4Determinant(long)" class="member-name-link">naiMatrix4Determinant</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4Determinant(org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4Determinant</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4FromEulerAngles(long,float,float,float)" class="member-name-link">naiMatrix4FromEulerAngles</a><wbr>(long&nbsp;mat,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4FromEulerAngles(org.lwjgl.assimp.AIMatrix4x4,float,float,float)"><code>Matrix4FromEulerAngles</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4FromMatrix3(long,long)" class="member-name-link">naiMatrix4FromMatrix3</a><wbr>(long&nbsp;dst,
 long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4FromMatrix3(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix4FromMatrix3</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4FromRotationAroundAxis(long,long,float)" class="member-name-link">naiMatrix4FromRotationAroundAxis</a><wbr>(long&nbsp;mat,
 long&nbsp;axis,
 float&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,float)"><code>Matrix4FromRotationAroundAxis</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4FromScalingQuaternionPosition(long,long,long,long)" class="member-name-link">naiMatrix4FromScalingQuaternionPosition</a><wbr>(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;rotation,
 long&nbsp;position)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4FromScalingQuaternionPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>Matrix4FromScalingQuaternionPosition</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4FromTo(long,long,long)" class="member-name-link">naiMatrix4FromTo</a><wbr>(long&nbsp;mat,
 long&nbsp;from,
 long&nbsp;to)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4FromTo(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Matrix4FromTo</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4Inverse(long)" class="member-name-link">naiMatrix4Inverse</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4Inverse(org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4Inverse</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4IsIdentity(long)" class="member-name-link">naiMatrix4IsIdentity</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4IsIdentity(org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4IsIdentity</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4RotationX(long,float)" class="member-name-link">naiMatrix4RotationX</a><wbr>(long&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4RotationX(org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4RotationX</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4RotationY(long,float)" class="member-name-link">naiMatrix4RotationY</a><wbr>(long&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4RotationY(org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4RotationY</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4RotationZ(long,float)" class="member-name-link">naiMatrix4RotationZ</a><wbr>(long&nbsp;mat,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4RotationZ(org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4RotationZ</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4Scaling(long,long)" class="member-name-link">naiMatrix4Scaling</a><wbr>(long&nbsp;mat,
 long&nbsp;scaling)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4Scaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)"><code>Matrix4Scaling</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMatrix4Translation(long,long)" class="member-name-link">naiMatrix4Translation</a><wbr>(long&nbsp;mat,
 long&nbsp;translation)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMatrix4Translation(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)"><code>Matrix4Translation</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMultiplyMatrix3(long,long)" class="member-name-link">naiMultiplyMatrix3</a><wbr>(long&nbsp;dst,
 long&nbsp;src)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMultiplyMatrix3(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)"><code>MultiplyMatrix3</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiMultiplyMatrix4(long,long)" class="member-name-link">naiMultiplyMatrix4</a><wbr>(long&nbsp;dst,
 long&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiMultiplyMatrix4(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)"><code>MultiplyMatrix4</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionAreEqual(long,long)" class="member-name-link">naiQuaternionAreEqual</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionAreEqual(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)"><code>QuaternionAreEqual</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionAreEqualEpsilon(long,long,float)" class="member-name-link">naiQuaternionAreEqualEpsilon</a><wbr>(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionAreEqualEpsilon(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)"><code>QuaternionAreEqualEpsilon</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionConjugate(long)" class="member-name-link">naiQuaternionConjugate</a><wbr>(long&nbsp;q)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionConjugate(org.lwjgl.assimp.AIQuaternion)"><code>QuaternionConjugate</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionFromAxisAngle(long,long,float)" class="member-name-link">naiQuaternionFromAxisAngle</a><wbr>(long&nbsp;q,
 long&nbsp;axis,
 float&nbsp;angle)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionFromAxisAngle(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D,float)"><code>QuaternionFromAxisAngle</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionFromEulerAngles(long,float,float,float)" class="member-name-link">naiQuaternionFromEulerAngles</a><wbr>(long&nbsp;q,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionFromEulerAngles(org.lwjgl.assimp.AIQuaternion,float,float,float)"><code>QuaternionFromEulerAngles</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionFromNormalizedQuaternion(long,long)" class="member-name-link">naiQuaternionFromNormalizedQuaternion</a><wbr>(long&nbsp;q,
 long&nbsp;normalized)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionFromNormalizedQuaternion(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>QuaternionFromNormalizedQuaternion</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionInterpolate(long,long,long,float)" class="member-name-link">naiQuaternionInterpolate</a><wbr>(long&nbsp;dst,
 long&nbsp;start,
 long&nbsp;end,
 float&nbsp;factor)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionInterpolate(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)"><code>QuaternionInterpolate</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionMultiply(long,long)" class="member-name-link">naiQuaternionMultiply</a><wbr>(long&nbsp;dst,
 long&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionMultiply(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)"><code>QuaternionMultiply</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiQuaternionNormalize(long)" class="member-name-link">naiQuaternionNormalize</a><wbr>(long&nbsp;q)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiQuaternionNormalize(org.lwjgl.assimp.AIQuaternion)"><code>QuaternionNormalize</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiReleaseExportBlob(long)" class="member-name-link">naiReleaseExportBlob</a><wbr>(long&nbsp;pData)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiReleaseExportBlob(org.lwjgl.assimp.AIExportDataBlob)"><code>ReleaseExportBlob</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiReleaseExportFormatDescription(long)" class="member-name-link">naiReleaseExportFormatDescription</a><wbr>(long&nbsp;desc)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiReleaseExportFormatDescription(org.lwjgl.assimp.AIExportFormatDesc)"><code>ReleaseExportFormatDescription</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiReleaseImport(long)" class="member-name-link">naiReleaseImport</a><wbr>(long&nbsp;pScene)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiReleasePropertyStore(long)" class="member-name-link">naiReleasePropertyStore</a><wbr>(long&nbsp;p)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiReleasePropertyStore(org.lwjgl.assimp.AIPropertyStore)"><code>ReleasePropertyStore</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiSetImportPropertyFloat(long,long,float)" class="member-name-link">naiSetImportPropertyFloat</a><wbr>(long&nbsp;store,
 long&nbsp;szName,
 float&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyFloat(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,float)"><code>SetImportPropertyFloat</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiSetImportPropertyInteger(long,long,int)" class="member-name-link">naiSetImportPropertyInteger</a><wbr>(long&nbsp;store,
 long&nbsp;szName,
 int&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyInteger(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,int)"><code>SetImportPropertyInteger</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiSetImportPropertyMatrix(long,long,long)" class="member-name-link">naiSetImportPropertyMatrix</a><wbr>(long&nbsp;store,
 long&nbsp;szName,
 long&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyMatrix(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIMatrix4x4)"><code>SetImportPropertyMatrix</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiSetImportPropertyString(long,long,long)" class="member-name-link">naiSetImportPropertyString</a><wbr>(long&nbsp;store,
 long&nbsp;szName,
 long&nbsp;value)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyString(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIString)"><code>SetImportPropertyString</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiTextureTypeToString(int)" class="member-name-link">naiTextureTypeToString</a><wbr>(int&nbsp;in)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiTextureTypeToString(int)"><code>TextureTypeToString</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiTransformVecByMatrix3(long,long)" class="member-name-link">naiTransformVecByMatrix3</a><wbr>(long&nbsp;vec,
 long&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiTransformVecByMatrix3(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix3x3)"><code>TransformVecByMatrix3</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiTransformVecByMatrix4(long,long)" class="member-name-link">naiTransformVecByMatrix4</a><wbr>(long&nbsp;vec,
 long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiTransformVecByMatrix4(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix4x4)"><code>TransformVecByMatrix4</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiTransposeMatrix3(long)" class="member-name-link">naiTransposeMatrix3</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiTransposeMatrix3(org.lwjgl.assimp.AIMatrix3x3)"><code>TransposeMatrix3</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiTransposeMatrix4(long)" class="member-name-link">naiTransposeMatrix4</a><wbr>(long&nbsp;mat)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiTransposeMatrix4(org.lwjgl.assimp.AIMatrix4x4)"><code>TransposeMatrix4</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2Add(long,long)" class="member-name-link">naiVector2Add</a><wbr>(long&nbsp;dst,
 long&nbsp;src)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2Add(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2Add</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2AreEqual(long,long)" class="member-name-link">naiVector2AreEqual</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2AreEqual(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2AreEqual</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2AreEqualEpsilon(long,long,float)" class="member-name-link">naiVector2AreEqualEpsilon</a><wbr>(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2AreEqualEpsilon(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D,float)"><code>Vector2AreEqualEpsilon</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2DivideByScalar(long,float)" class="member-name-link">naiVector2DivideByScalar</a><wbr>(long&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2DivideByScalar(org.lwjgl.assimp.AIVector2D,float)"><code>Vector2DivideByScalar</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2DivideByVector(long,long)" class="member-name-link">naiVector2DivideByVector</a><wbr>(long&nbsp;dst,
 long&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2DivideByVector(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2DivideByVector</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2DotProduct(long,long)" class="member-name-link">naiVector2DotProduct</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2DotProduct(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2DotProduct</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2Length(long)" class="member-name-link">naiVector2Length</a><wbr>(long&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2Length(org.lwjgl.assimp.AIVector2D)"><code>Vector2Length</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2Negate(long)" class="member-name-link">naiVector2Negate</a><wbr>(long&nbsp;dst)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2Negate(org.lwjgl.assimp.AIVector2D)"><code>Vector2Negate</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2Normalize(long)" class="member-name-link">naiVector2Normalize</a><wbr>(long&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2Normalize(org.lwjgl.assimp.AIVector2D)"><code>Vector2Normalize</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2Scale(long,float)" class="member-name-link">naiVector2Scale</a><wbr>(long&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2Scale(org.lwjgl.assimp.AIVector2D,float)"><code>Vector2Scale</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2SquareLength(long)" class="member-name-link">naiVector2SquareLength</a><wbr>(long&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2SquareLength(org.lwjgl.assimp.AIVector2D)"><code>Vector2SquareLength</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2Subtract(long,long)" class="member-name-link">naiVector2Subtract</a><wbr>(long&nbsp;dst,
 long&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2Subtract(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2Subtract</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector2SymMul(long,long)" class="member-name-link">naiVector2SymMul</a><wbr>(long&nbsp;dst,
 long&nbsp;other)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector2SymMul(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2SymMul</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3Add(long,long)" class="member-name-link">naiVector3Add</a><wbr>(long&nbsp;dst,
 long&nbsp;src)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3Add(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3Add</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3AreEqual(long,long)" class="member-name-link">naiVector3AreEqual</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3AreEqual(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3AreEqual</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3AreEqualEpsilon(long,long,float)" class="member-name-link">naiVector3AreEqualEpsilon</a><wbr>(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3AreEqualEpsilon(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,float)"><code>Vector3AreEqualEpsilon</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3CrossProduct(long,long,long)" class="member-name-link">naiVector3CrossProduct</a><wbr>(long&nbsp;dst,
 long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3CrossProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3CrossProduct</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3DivideByScalar(long,float)" class="member-name-link">naiVector3DivideByScalar</a><wbr>(long&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3DivideByScalar(org.lwjgl.assimp.AIVector3D,float)"><code>Vector3DivideByScalar</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3DivideByVector(long,long)" class="member-name-link">naiVector3DivideByVector</a><wbr>(long&nbsp;dst,
 long&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3DivideByVector(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3DivideByVector</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3DotProduct(long,long)" class="member-name-link">naiVector3DotProduct</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3DotProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3DotProduct</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3Length(long)" class="member-name-link">naiVector3Length</a><wbr>(long&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3Length(org.lwjgl.assimp.AIVector3D)"><code>Vector3Length</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3LessThan(long,long)" class="member-name-link">naiVector3LessThan</a><wbr>(long&nbsp;a,
 long&nbsp;b)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3LessThan(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3LessThan</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3Negate(long)" class="member-name-link">naiVector3Negate</a><wbr>(long&nbsp;dst)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3Negate(org.lwjgl.assimp.AIVector3D)"><code>Vector3Negate</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3Normalize(long)" class="member-name-link">naiVector3Normalize</a><wbr>(long&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3Normalize(org.lwjgl.assimp.AIVector3D)"><code>Vector3Normalize</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3NormalizeSafe(long)" class="member-name-link">naiVector3NormalizeSafe</a><wbr>(long&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3NormalizeSafe(org.lwjgl.assimp.AIVector3D)"><code>Vector3NormalizeSafe</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3RotateByQuaternion(long,long)" class="member-name-link">naiVector3RotateByQuaternion</a><wbr>(long&nbsp;v,
 long&nbsp;q)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3RotateByQuaternion(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion)"><code>Vector3RotateByQuaternion</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3Scale(long,float)" class="member-name-link">naiVector3Scale</a><wbr>(long&nbsp;dst,
 float&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3Scale(org.lwjgl.assimp.AIVector3D,float)"><code>Vector3Scale</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3SquareLength(long)" class="member-name-link">naiVector3SquareLength</a><wbr>(long&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3SquareLength(org.lwjgl.assimp.AIVector3D)"><code>Vector3SquareLength</code></a></div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3Subtract(long,long)" class="member-name-link">naiVector3Subtract</a><wbr>(long&nbsp;dst,
 long&nbsp;src)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3Subtract(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3Subtract</code></a></div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#naiVector3SymMul(long,long)" class="member-name-link">naiVector3SymMul</a><wbr>(long&nbsp;dst,
 long&nbsp;other)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Unsafe version of: <a href="#aiVector3SymMul(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3SymMul</code></a></div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="AI_CONFIG_GLOB_MEASURE_TIME">
<h3>AI_CONFIG_GLOB_MEASURE_TIME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_GLOB_MEASURE_TIME</span></div>
<div class="block">Enables time measurements.
 
 <p>If enabled, measures the time needed for each part of the loading process (i.e. IO time, importing, postprocessing, ..) and dumps these timings to the
 DefaultLogger. See the <a target="_blank" href="http://assimp.org/lib_html/perf.html">Performance Page</a> for more information on this topic.</p>
 
 <p>Property type: bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_GLOB_MEASURE_TIME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_NO_SKELETON_MESHES">
<h3>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_NO_SKELETON_MESHES</span></div>
<div class="block">Global setting to disable generation of skeleton dummy meshes
 
 <p>Skeleton dummy meshes are generated as a visualization aid in cases which the input data contains no geometry, but only animation data.</p>
 
 <p>Property data type: bool. Default value: false</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_NO_SKELETON_MESHES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_SBBC_MAX_BONES">
<h3>AI_CONFIG_PP_SBBC_MAX_BONES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_SBBC_MAX_BONES</span></div>
<div class="block">Maximum bone count per mesh for the <a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> step.
 
 <p>Meshes are split until the maximum number of bones is reached. The default value is <a href="#AI_SBBC_DEFAULT_MAX_BONES"><code>AI_SBBC_DEFAULT_MAX_BONES</code></a>, which may be altered at compile-time.</p>
 
 <p>Property data type: integer.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_SBBC_MAX_BONES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE">
<h3>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</span></div>
<div class="block">Specifies the maximum angle that may be between two vertex tangents that their tangents and bi-tangents are smoothed.
 
 <p>This applies to the <a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> step. The angle is specified in degrees. The maximum value is 175.</p>
 
 <p>Property type: float. Default value: 45 degrees</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX">
<h3>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</span></div>
<div class="block">Source UV channel for tangent space computation.
 
 <p>The specified channel must exist or an error will be raised.</p>
 
 <p>Property type: integer. Default value: 0</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE">
<h3>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</span></div>
<div class="block">Specifies the maximum angle that may be between two face normals at the same vertex position that their are smoothed together.
 
 <p>Sometimes referred to as 'crease angle'. This applies to the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> step. The angle is specified in degrees, so 180 is PI. The
 default value is 175 degrees (all vertex normals are smoothed). The maximum value is 175, too.</p>
 
 <p>Property type: float.</p>
 
 <p>Warning: setting this option may cause a severe loss of performance. The performance is unaffected if the <a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a> flag is set but the
 output quality may be reduced.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_COLORMAP">
<h3>AI_CONFIG_IMPORT_MDL_COLORMAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_COLORMAP</span></div>
<div class="block">Sets the colormap (= palette) to be used to decode embedded textures in MDL (Quake or 3DGS) files.
 
 <p>This must be a valid path to a file. The file is 768 (256*3) bytes large and contains RGB triplets for each of the 256 palette entries. The default
 value is colormap.lmp. If the file is not found, a default palette (from Quake 1) is used.</p>
 
 <p>Property type: string.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_COLORMAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_RRM_EXCLUDE_LIST">
<h3>AI_CONFIG_PP_RRM_EXCLUDE_LIST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_RRM_EXCLUDE_LIST</span></div>
<div class="block">Configures the <a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> step to keep materials matching a name in a given list.
 
 <p>This is a list of 1 to n strings, ' ' serves as delimiter character. Identifiers containing whitespaces must be enclosed in *single* quotation marks.
 For example: <code>"keep-me and_me_to anotherMaterialToBeKept \'name with whitespace\'"</code>. If a material matches on of these names, it will not be
 modified or removed by the postprocessing step nor will other materials be replaced by a reference to it.</p>
 
 <p>This option might be useful if you are using some magic material names to pass additional semantics through the content pipeline. This ensures they
 won't be optimized away, but a general optimization is still performed for materials not contained in the list.</p>
 
 <p>Property type: String. Default value: n/a</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Linefeeds, tabs or carriage returns are treated as whitespace. Material names are case sensitive.</p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_RRM_EXCLUDE_LIST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_PTV_KEEP_HIERARCHY">
<h3>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_PTV_KEEP_HIERARCHY</span></div>
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to keep the scene hierarchy. Meshes are moved to worldspace, but no optimization is performed (read:
 meshes with equal materials are not joined. The total number of meshes won't change).
 
 <p>This option could be of use for you if the scene hierarchy contains important additional information which you intend to parse. For rendering, you can
 still render all meshes in the scene without any transformations.</p>
 
 <p>Property type: bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_PTV_KEEP_HIERARCHY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_PTV_NORMALIZE">
<h3>AI_CONFIG_PP_PTV_NORMALIZE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_PTV_NORMALIZE</span></div>
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to normalize all vertex components into the <code>[-1,1]</code> range. That is, a bounding box for the
 whole scene is computed, the maximum component is taken and all meshes are scaled appropriately (uniformly of course!). This might be useful if you
 don't know the spatial dimension of the input data.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_PTV_NORMALIZE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION">
<h3>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</span></div>
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to use a users defined matrix as the scene root node transformation before transforming vertices.
 
 <p>Property type: bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION">
<h3>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</span></div>
<div class="block">Configures the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> step to use a users defined matrix as the scene root node transformation before transforming vertices.
 This property corresponds to the 'a1' component of the transformation matrix.
 
 <p>Property type: aiMatrix4x4.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_FD_REMOVE">
<h3>AI_CONFIG_PP_FD_REMOVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_FD_REMOVE</span></div>
<div class="block">Configures the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> step to remove degenerated primitives from the import - immediately.
 
 <p>The default behaviour converts degenerated triangles to lines and degenerated lines to points. See the documentation to the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a>
 step for a detailed example of the various ways to get rid of these lines and points if you don't want them.</p>
 
 <p>Property type: bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_FD_REMOVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_FD_CHECKAREA">
<h3>AI_CONFIG_PP_FD_CHECKAREA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_FD_CHECKAREA</span></div>
<div class="block">Configures the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> to check the area of a triangle to be greater than e-6. If this is not the case the triangle will be removed if
 <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> is set to true.
 
 <p>Property type: bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_FD_CHECKAREA">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_OG_EXCLUDE_LIST">
<h3>AI_CONFIG_PP_OG_EXCLUDE_LIST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_OG_EXCLUDE_LIST</span></div>
<div class="block">Configures the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to preserve nodes matching a name in a given list.
 
 <p>This is a list of 1 to n strings, ' ' serves as delimiter character. Identifiers containing whitespaces must be enclosed in *single* quotation marks.
 For example: <code>"keep-me and_me_to anotherNodeToBeKept \'name with whitespace\'"</code>. If a node matches on of these names, it will not be modified or
 removed by the postprocessing step.</p>
 
 <p>This option might be useful if you are using some magic node names to pass additional semantics through the content pipeline. This ensures they won't
 be optimized away, but a general optimization is still performed for nodes not contained in the list.</p>
 
 <p>Property type: String. Default value: n/a</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Linefeeds, tabs or carriage returns are treated as whitespace. Node names are case sensitive.</p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_OG_EXCLUDE_LIST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_SLM_TRIANGLE_LIMIT">
<h3>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</span></div>
<div class="block">Set the maximum number of triangles in a mesh.
 
 <p>This is used by the <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> PostProcess-Step to determine whether a mesh must be split or not.</p>
 
 <p>Property type: integer.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The default value is <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a></p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_SLM_TRIANGLE_LIMIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_SLM_VERTEX_LIMIT">
<h3>AI_CONFIG_PP_SLM_VERTEX_LIMIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_SLM_VERTEX_LIMIT</span></div>
<div class="block">Set the maximum number of vertices in a mesh.
 
 <p>This is used by the <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> PostProcess-Step to determine whether a mesh must be split or not.</p>
 
 <p>Property type: integer.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The default value is <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a></p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_SLM_VERTEX_LIMIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_LBW_MAX_WEIGHTS">
<h3>AI_CONFIG_PP_LBW_MAX_WEIGHTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_LBW_MAX_WEIGHTS</span></div>
<div class="block">Set the maximum number of bones affecting a single vertex.
 
 <p>This is used by the <a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> PostProcess-Step.</p>
 
 <p>Property type: integer.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The default value is <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a></p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_LBW_MAX_WEIGHTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_DB_THRESHOLD">
<h3>AI_CONFIG_PP_DB_THRESHOLD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_DB_THRESHOLD</span></div>
<div class="block">Lower the deboning threshold in order to remove more bones.
 
 <p>This is used by the <a href="#aiProcess_Debone"><code>Process_Debone</code></a> PostProcess-Step.</p>
 
 <p>Property type: float.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The default value is <a href="#AI_DEBONE_THRESHOLD"><code>AI_DEBONE_THRESHOLD</code></a></p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_DB_THRESHOLD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_DB_ALL_OR_NONE">
<h3>AI_CONFIG_PP_DB_ALL_OR_NONE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_DB_ALL_OR_NONE</span></div>
<div class="block">Require all bones qualify for deboning before removing any.
 
 <p>This is used by the <a href="#aiProcess_Debone"><code>Process_Debone</code></a> PostProcess-Step.</p>
 
 <p>Property type: bool.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The default value is 0</p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_DB_ALL_OR_NONE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_ICL_PTCACHE_SIZE">
<h3>AI_CONFIG_PP_ICL_PTCACHE_SIZE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_ICL_PTCACHE_SIZE</span></div>
<div class="block">Set the size of the post-transform vertex cache to optimize the vertices for. This configures the <a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> step.
 
 <p>The size is given in vertices. Of course you can't know how the vertex format will exactly look like after the import returns, but you can still guess
 what your meshes will probably have.</p>
 
 <p>Property type: integer.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The default value is <a href="#PP_ICL_PTCACHE_SIZE"><code>PP_ICL_PTCACHE_SIZE</code></a>. That results in slight performance improvements for most nVidia/AMD cards since 2002.</p></div></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_ICL_PTCACHE_SIZE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_RVC_FLAGS">
<h3>AI_CONFIG_PP_RVC_FLAGS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_RVC_FLAGS</span></div>
<div class="block">Input parameter to the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step: Specifies the parts of the data structure to be removed.
 
 <p>See the documentation to this step for further details. The property is expected to be an integer, a bitwise combination of the <code>aiComponent</code>
 flags. The default value is 0. Important: if no valid mesh is remaining after the step has been executed (e.g you thought it was funny to specify ALL
 of the flags defined above) the import FAILS. Mainly because there is no data to work on anymore ...</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_RVC_FLAGS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_SBP_REMOVE">
<h3>AI_CONFIG_PP_SBP_REMOVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_SBP_REMOVE</span></div>
<div class="block">Input parameter to the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> step: Specifies which primitive types are removed by the step.
 
 <p>This is a bitwise combination of the <code>aiPrimitiveType</code> flags. Specifying all of them is illegal, of course. A typical use would be to exclude
 all line and point meshes from the import.</p>
 
 <p>This is an integer property, its default value is 0.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_SBP_REMOVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_FID_ANIM_ACCURACY">
<h3>AI_CONFIG_PP_FID_ANIM_ACCURACY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_FID_ANIM_ACCURACY</span></div>
<div class="block">Input parameter to the <a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> step: Specifies the floating-point accuracy for animation values.
 
 <p>The step checks for animation tracks where all frame values are absolutely equal and removes them. This tweakable controls the epsilon for
 floating-point comparisons - two keys are considered equal if the invariant <code>abs(n0-n1)&gt;epsilon</code> holds true for all vector respectively
 quaternion components.</p>
 
 <p>The default value is 0.f - comparisons are exact then.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_FID_ANIM_ACCURACY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS">
<h3>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</span></div>
<div class="block">Input parameter to the <a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> step: Set to true to ignore texture coordinates.
 
 <p>This may be useful if you have to assign different kind of textures like one for the summer or one for the winter.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_PP_TUV_EVALUATE">
<h3>AI_CONFIG_PP_TUV_EVALUATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_PP_TUV_EVALUATE</span></div>
<div class="block">Input parameter to the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step: Specifies which UV transformations are evaluated.
 
 <p>This is a bitwise combination of the <code>AI_UVTRAFO_XXX</code> flags (integer property, of course). By default all transformations are enabled
 (<a href="#AI_UVTRAFO_ALL"><code>AI_UVTRAFO_ALL</code></a>).</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_PP_TUV_EVALUATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_FAVOUR_SPEED">
<h3>AI_CONFIG_FAVOUR_SPEED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_FAVOUR_SPEED</span></div>
<div class="block">A hint to assimp to favour speed against import quality.
 
 <p>Enabling this option may result in faster loading, but it needn't. It represents just a hint to loaders and post-processing steps to use faster code
 paths, if possible.</p>
 
 <p>This property is expected to be an integer, != 0 stands for true. The default value is 0.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_FAVOUR_SPEED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER">
<h3>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</span></div>
<div class="block">Importers which parse JSON may use this to obtain a pointer to a <code>rapidjson::IRemoteSchemaDocumentProvider</code>.
 
 <p>Property type: void*. The default value is <code>nullptr</code></p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS">
<h3>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</span></div>
<div class="block">Set whether the fbx importer will merge all geometry layers present in the source file or take only the first.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS">
<h3>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</span></div>
<div class="block">Set whether the fbx importer will read all materials present in the source file or take only the referenced materials.
 
 <p>This is void unless <code>IMPORT_FBX_READ_MATERIALS=1</code>.</p>
 
 <p>Property type: bool. The default value is false (0)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_MATERIALS">
<h3>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_MATERIALS</span></div>
<div class="block">Set whether the fbx importer will read materials.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_MATERIALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_TEXTURES">
<h3>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_TEXTURES</span></div>
<div class="block">Set whether the fbx importer will read embedded textures.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_TEXTURES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_CAMERAS">
<h3>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_CAMERAS</span></div>
<div class="block">Set whether the fbx importer will read cameras.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_CAMERAS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_LIGHTS">
<h3>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_LIGHTS</span></div>
<div class="block">Set whether the fbx importer will read light sources.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_LIGHTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS">
<h3>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</span></div>
<div class="block">Set whether the fbx importer will read animations.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_READ_WEIGHTS">
<h3>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</span></div>
<div class="block">Set whether the fbx importer will read weights.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_READ_WEIGHTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_STRICT_MODE">
<h3>AI_CONFIG_IMPORT_FBX_STRICT_MODE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_STRICT_MODE</span></div>
<div class="block">Set whether the fbx importer will act in strict mode in which only FBX 2013 is supported and any other sub formats are rejected. FBX 2013 is the
 primary target for the importer, so this format is best supported and well-tested.
 
 <p>Property type: bool. The default value is false (0)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_STRICT_MODE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS">
<h3>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</span></div>
<div class="block">Set whether the fbx importer will preserve pivot points for transformations (as extra nodes). If set to false, pivots and offsets will be evaluated
 whenever possible.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES">
<h3>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</span></div>
<div class="block">Specifies whether the importer will drop empty animation curves or animation curves which match the bind pose transformation over their entire defined
 range.
 
 <p>Property type: bool. The default value is true (1)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING">
<h3>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</span></div>
<div class="block">Set whether the fbx importer will use the legacy embedded texture naming.
 
 <p>Property type: bool. The default value is false (0)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES">
<h3>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</span></div>
<div class="block">Set whether the importer shall not remove empty bones.
 
 <p>Empty bones are often used to define connections for other models.</p>
 
 <p>Property type: bool. The default value is false (0)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_FBX_CONVERT_TO_M">
<h3>AI_CONFIG_FBX_CONVERT_TO_M</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_FBX_CONVERT_TO_M</span></div>
<div class="block">Set whether the FBX importer shall convert the unit from cm to m.
 
 <p>Property type: bool. The default value is false (0)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_FBX_CONVERT_TO_M">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER">
<h3>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</span></div>
<div class="block">Will enable the skeleton structo to store bone data.
 
 <p>This will decouple the bone coupling to the mesh. This feature is experimental.</p>
 
 <p>Property type: bool. The default value is false (0)</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_GLOBAL_KEYFRAME">
<h3>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</span></div>
<div class="block">Set the vertex animation keyframe to be imported.
 
 <p>ASSIMP does not support vertex keyframes (only bone animation is supported). The library reads only one frame of models with vertex animations. By
 default this is the first frame.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The default value is 0. This option applies to all importers. However, it is also possible to override the global setting for a specific loader.
 You can use the <code>AI_CONFIG_IMPORT_XXX_KEYFRAME</code> options (where XXX is a placeholder for the file format for which you want to override the
 global setting).</p>
 </div>
 
 <p>Property type: integer.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_GLOBAL_KEYFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MD3_KEYFRAME">
<h3>AI_CONFIG_IMPORT_MD3_KEYFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MD3_KEYFRAME</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MD3_KEYFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MD2_KEYFRAME">
<h3>AI_CONFIG_IMPORT_MD2_KEYFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MD2_KEYFRAME</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></li>
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MD2_KEYFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_KEYFRAME">
<h3>AI_CONFIG_IMPORT_MDL_KEYFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_KEYFRAME</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></li>
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_KEYFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDC_KEYFRAME">
<h3>AI_CONFIG_IMPORT_MDC_KEYFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDC_KEYFRAME</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></li>
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDC_KEYFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_SMD_KEYFRAME">
<h3>AI_CONFIG_IMPORT_SMD_KEYFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_SMD_KEYFRAME</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></li>
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_SMD_KEYFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_UNREAL_KEYFRAME">
<h3>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_UNREAL_KEYFRAME</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></li>
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_UNREAL_KEYFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</span></div>
<div class="block">Set whether the MDL (HL1) importer will read animations.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</span></div>
<div class="block">Set whether the MDL (HL1) importer will read animation events.
 
 <p>This property requires <a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a> to be set to true.</p>
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</span></div>
<div class="block">Set whether the MDL (HL1) importer will read blend controllers.
 
 <p>This property requires <a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a> to be set to true.</p>
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</span></div>
<div class="block">Set whether the MDL (HL1) importer will read sequence transition graph.
 
 <p>This property requires <a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a> to be set to true.</p>
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</span></div>
<div class="block">Set whether the MDL (HL1) importer will read attachments info.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</span></div>
<div class="block">Set whether the MDL (HL1) importer will read bone controllers info.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</span></div>
<div class="block">Set whether the MDL (HL1) importer will read hitboxes info.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO">
<h3>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</span></div>
<div class="block">Set whether the MDL (HL1) importer will read miscellaneous global model info.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST">
<h3>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</span></div>
<div class="block">Smd load multiple animations.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL">
<h3>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</span></div>
<div class="block">Configures the AC loader to collect all surfaces which have the "Backface cull" flag set in separate meshes.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION">
<h3>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</span></div>
<div class="block">Configures whether the AC loader evaluates subdivision surfaces (indicated by the presence of the 'subdiv' attribute in the file). By default, Assimp
 performs the subdivision using the standard Catmull-Clark algorithm.
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_UNREAL_HANDLE_FLAGS">
<h3>AI_CONFIG_UNREAL_HANDLE_FLAGS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_UNREAL_HANDLE_FLAGS</span></div>
<div class="block">Configures the UNREAL 3D loader to separate faces with different surface flags (e.g. two-sided vs. single-sided).
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_UNREAL_HANDLE_FLAGS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_TER_MAKE_UVS">
<h3>AI_CONFIG_IMPORT_TER_MAKE_UVS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_TER_MAKE_UVS</span></div>
<div class="block">Configures the terragen import plugin to compute uv's for terrains, if not given. Furthermore a default texture is assigned.
 
 <p>UV coordinates for terrains are so simple to compute that you'll usually want to compute them on your own, if you need them. This option is intended
 for model viewers which want to offer an easy way to apply textures to terrains.</p>
 
 <p>Property type: bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_TER_MAKE_UVS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS">
<h3>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</span></div>
<div class="block">Configures the ASE loader to always reconstruct normal vectors basing on the smoothing groups loaded from the file.
 
 <p>Some ASE files have carry invalid normals, other don't.</p>
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART">
<h3>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</span></div>
<div class="block">Configures the M3D loader to detect and process multi-part Quake player models.
 
 <p>These models usually consist of 3 files, lower.md3, upper.md3 and head.md3. If this property is set to true, Assimp will try to load and * combine all
 three files if one of them is loaded.</p>
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MD3_SKIN_NAME">
<h3>AI_CONFIG_IMPORT_MD3_SKIN_NAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MD3_SKIN_NAME</span></div>
<div class="block">Tells the MD3 loader which skin files to load.
 
 <p>When loading MD3 files, Assimp checks whether a file <code>[md3_file_name]_[skin_name].skin</code> is existing. These files are used by * Quake III to be
 able to assign different skins (e.g. red and blue team) to models. 'default', 'red', 'blue' are typical skin names.</p>
 
 <p>Property type: String. Default value: "default".</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MD3_SKIN_NAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MD3_LOAD_SHADERS">
<h3>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</span></div>
<div class="block">Specify if to try load Quake 3 shader files.
 
 <p>This also controls  original surface name handling: when disabled it will be used unchanged.</p>
 
 <p>Property type: bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MD3_LOAD_SHADERS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MD3_SHADER_SRC">
<h3>AI_CONFIG_IMPORT_MD3_SHADER_SRC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MD3_SHADER_SRC</span></div>
<div class="block">Specify the Quake 3 shader file to be used for a particular MD3 file. This can also be a search path.
 
 <p>By default Assimp's behaviour is as follows: If a MD3 file <code>any_path/models/any_q3_subdir/model_name/file_name.md3</code> is loaded, the library tries
 to locate the corresponding shader file in <code>any_path/scripts/model_name.shader</code>. This property overrides this behaviour. It can either specify a
 full path to the shader to be loaded or alternatively the path (relative or absolute) to the directory where the shaders for all MD3s to be loaded
 reside. Assimp attempts to open <code>IMPORT_MD3_SHADER_SRC/model_name.shader</code> first, <code>IMPORT_MD3_SHADER_SRC/file_name.shader</code> is the fallback
 file. Note that <code>IMPORT_MD3_SHADER_SRC</code> should have a terminal (back)slash.</p>
 
 <p>Property type: String. Default value: n/a.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MD3_SHADER_SRC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY">
<h3>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</span></div>
<div class="block">Configures the LWO loader to load just one layer from the model.
 
 <p>LWO files consist of layers and in some cases it could be useful to load only one of them. This property can be either a string - which specifies the
 name of the layer - or an integer - the index of the layer. If the property is not set the whole LWO model is loaded. Loading fails if the requested
 layer is not available. The layer index is zero-based and the layer name may not be empty.</p>
 
 <p>Property type: Integer. Default value: all layers are loaded.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD">
<h3>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</span></div>
<div class="block">Configures the MD5 loader to not load the MD5ANIM file for a MD5MESH file automatically.
 
 <p>The default strategy is to look for a file with the same name but the MD5ANIM extension in the same directory. If it is found, it is loaded * and
 combined with the MD5MESH file. This configuration option can be used to disable this behaviour.</p>
 
 <p>Property type: bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_LWS_ANIM_START">
<h3>AI_CONFIG_IMPORT_LWS_ANIM_START</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_LWS_ANIM_START</span></div>
<div class="block">Defines the begin of the time range for which the LWS loader evaluates animations and computes <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a>'s.
 
 <p>Assimp provides full conversion of LightWave's envelope system, including pre and post conditions. The loader computes linearly subsampled animation
 chanels with the frame rate given in the LWS file. This property defines the start time. Note: animation channels are only generated if a node has at
 least one envelope with more tan one key assigned. This property is given in frames, '0' is the first frame. By default, if this property is not set,
 the importer takes the animation start from the input LWS file ('FirstFrame' line).</p>
 
 <p>Property type: Integer. Default value: taken from file.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_LWS_ANIM_START">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_LWS_ANIM_END">
<h3>AI_CONFIG_IMPORT_LWS_ANIM_END</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_LWS_ANIM_END</span></div>
<div class="block">End of the imported time range.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></li>
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_LWS_ANIM_END">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_IRR_ANIM_FPS">
<h3>AI_CONFIG_IMPORT_IRR_ANIM_FPS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_IRR_ANIM_FPS</span></div>
<div class="block">Defines the output frame rate of the IRR loader.
 
 <p>IRR animations are difficult to convert for Assimp and there will always be a loss of quality. This setting defines how many keys per second are
 returned by the converter.</p>
 
 <p>Property type: integer. Default value: 100</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_IRR_ANIM_FPS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE">
<h3>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</span></div>
<div class="block">Ogre Importer will try to find referenced materials from this file.
 
 <p>Ogre meshes reference with material names, this does not tell Assimp the file where it is located in. Assimp will try to find the source file in the
 following order: <code>&lt;material-name&gt;.material</code>, <code>&lt;mesh-filename-base&gt;.material</code> and lastly the material name defined by this config property.</p>
 
 <p>Property type: String. Default value: <code>Scene.material</code>.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME">
<h3>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</span></div>
<div class="block">Ogre Importer detect the texture usage from its filename.
 
 <p>Ogre material texture units do not define texture type, the textures usage depends on the used shader or Ogre's fixed pipeline. If this config
 property is true Assimp will try to detect the type from the textures filename postfix: _n, _nrm, _nrml, _normal, _normals and _normalmap for normal
 map, _s, _spec, _specular and _specularmap for specular map, _l, _light, _lightmap, _occ and _occlusion for light map, _disp and _displacement for
 displacement map. The matching is case insensitive. Post fix is taken between the last underscore and the last period.</p>
 
 <p>Default behavior is to detect type from lower cased texture unit name by matching against: normalmap, specularmap, lightmap and displacementmap. For
 both cases if no match is found <a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> is used.</p>
 
 <p>Property type: Bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS">
<h3>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</span></div>
<div class="block">Specifies whether the IFC loader skips over IfcSpace elements.
 
 <p>IfcSpace elements (and their geometric representations) are used to represent, well, free space in a building storey.</p>
 
 <p>Property type: Bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT">
<h3>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</span></div>
<div class="block">Specifies whether the Android JNI asset extraction is supported.
 
 <p>Turn on this option if you want to manage assets in native Android application without having to keep the internal directory and asset manager
 pointer.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS">
<h3>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</span></div>
<div class="block">Specifies whether the IFC loader skips over shape representations of type 'Curve2D'.
 
 <p>A lot of files contain both a faceted mesh representation and a outline with a presentation type of 'Curve2D'. Currently Assimp doesn't convert those,
 so turning this option off just clutters the log with errors.</p>
 
 <p>Property type: Bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION">
<h3>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</span></div>
<div class="block">Specifies whether the IFC loader will use its own, custom triangulation algorithm to triangulate wall and floor meshes.
 
 <p>If this property is set to false, walls will be either triangulated by <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> or will be passed through as huge polygons with faked
 holes (i.e. holes that are connected with the outer boundary using a dummy edge). It is highly recommended to set this property to true if you want
 triangulated data because <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> is known to have problems with the kind of polygons that the IFC loader spits out for complicated
 meshes.</p>
 
 <p>Property type: Bool. Default value: true.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE">
<h3>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</span></div>
<div class="block">Sets the tessellation conic angle for IFC smoothing curves.
 
 <p>This is used by the IFC importer to determine the tessellation parameter for smoothing curves.</p>
 
 <p>The default value is <a href="#AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE"><code>AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE</code></a> and the accepted values are in range [5.0, 120.0].</p>
 
 <p>Property type: Float.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION">
<h3>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</span></div>
<div class="block">Set the tessellation for IFC cylindrical shapes.
 
 <p>This is used by the IFC importer to determine the tessellation parameter for cylindrical shapes, i.e. the number of segments used to aproximate a circle.</p>
 
 <p>The default value is <a href="#AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION"><code>AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION</code></a> and the accepted values are in range [3, 180].</p>
 
 <p>Property type: Integer.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION">
<h3>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</span></div>
<div class="block">Specifies whether the Collada loader will ignore the provided up direction.
 
 <p>If this property is set to true, the up direction provided in the file header will be ignored and the file will be loaded as is.</p>
 
 <p>Property type: Bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES">
<h3>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</span></div>
<div class="block">Specifies whether the Collada loader should use Collada names.
 
 <p>If this property is set to true, the Collada names will be used as the node and mesh names. The default is to use the id tag (resp. sid tag, if no id
 tag is present) instead.</p>
 
 <p>Property type: Bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_EXPORT_XFILE_64BIT">
<h3>AI_CONFIG_EXPORT_XFILE_64BIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_EXPORT_XFILE_64BIT</span></div>
<div class="block">Specifies the xfile use double for real values of float.
 
 <p>Property type: Bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_EXPORT_XFILE_64BIT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_EXPORT_POINT_CLOUDS">
<h3>AI_CONFIG_EXPORT_POINT_CLOUDS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_EXPORT_POINT_CLOUDS</span></div>
<div class="block">Specifies whether the assimp export shall be able to export point clouds.
 
 <p>When this flag is not defined the render data has to contain valid faces. Point clouds are only a collection of vertices which have nor spatial
 organization by a face and the validation process will remove them. Enabling this feature will switch off the flag and enable the functionality to
 export pure point clouds.</p>
 
 <p>Property type: Bool. Default value: false.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_EXPORT_POINT_CLOUDS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_EXPORT_BLOB_NAME">
<h3>AI_CONFIG_EXPORT_BLOB_NAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_EXPORT_BLOB_NAME</span></div>
<div class="block">Specifies the blob name, assimp uses for exporting.
 
 <p>Some formats require auxiliary files to be written, that need to be linked back into the original file. For example, OBJ files export materials to a
 separate MTL file and use the <code>mtllib</code> keyword to reference this file.</p>
 
 <p>When exporting blobs using <code>#ExportToBlob</code>, assimp does not know the name of the blob file and thus outputs <code>mtllib $blobfile.mtl</code>, which
 might not be desired, since the MTL file might be called differently.</p>
 
 <p>This property can be used to give the exporter a hint on how to use the magic <code>$blobfile</code> keyword. If the exporter detects the keyword and is
 provided with a name for the blob, it instead uses this name.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_EXPORT_BLOB_NAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY">
<h3>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</span></div>
<div class="block">Specifies a global key factor for scale.
 
 <p>Property type: float. Default value: 1.0f</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_APP_SCALE_KEY">
<h3>AI_CONFIG_APP_SCALE_KEY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_CONFIG_APP_SCALE_KEY</span></div>
<div class="block">Specifies an application key factor for scale.
 
 <p>Property type: float. Default value: 1.0f</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_APP_SCALE_KEY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SBBC_DEFAULT_MAX_BONES">
<h3>AI_SBBC_DEFAULT_MAX_BONES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SBBC_DEFAULT_MAX_BONES</span></div>
<div class="block">Default values for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SBBC_DEFAULT_MAX_BONES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SLM_DEFAULT_MAX_TRIANGLES">
<h3>AI_SLM_DEFAULT_MAX_TRIANGLES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SLM_DEFAULT_MAX_TRIANGLES</span></div>
<div class="block">Default values for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SLM_DEFAULT_MAX_TRIANGLES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SLM_DEFAULT_MAX_VERTICES">
<h3>AI_SLM_DEFAULT_MAX_VERTICES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SLM_DEFAULT_MAX_VERTICES</span></div>
<div class="block">Default values for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SLM_DEFAULT_MAX_VERTICES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_LBW_MAX_WEIGHTS">
<h3>AI_LBW_MAX_WEIGHTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_LBW_MAX_WEIGHTS</span></div>
<div class="block">Default values for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_LBW_MAX_WEIGHTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="PP_ICL_PTCACHE_SIZE">
<h3>PP_ICL_PTCACHE_SIZE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">PP_ICL_PTCACHE_SIZE</span></div>
<div class="block">Default values for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.PP_ICL_PTCACHE_SIZE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION">
<h3>AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION</span></div>
<div class="block">Default values for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_DEBONE_THRESHOLD">
<h3>AI_DEBONE_THRESHOLD</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_DEBONE_THRESHOLD</span></div>
<div class="block">Default value for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_DEBONE_THRESHOLD">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE">
<h3>AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE</span></div>
<div class="block">Default value for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT">
<h3>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</span></div>
<div class="block">Default value for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_CONFIG_APP_SCALE_DEFAULT">
<h3>AI_CONFIG_APP_SCALE_DEFAULT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_CONFIG_APP_SCALE_DEFAULT</span></div>
<div class="block">Default value for configuration properties.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_CONFIG_APP_SCALE_DEFAULT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_UVTRAFO_SCALING">
<h3>AI_UVTRAFO_SCALING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_UVTRAFO_SCALING</span></div>
<div class="block">UVCoord Transforms</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_UVTRAFO_SCALING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_UVTRAFO_ROTATION">
<h3>AI_UVTRAFO_ROTATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_UVTRAFO_ROTATION</span></div>
<div class="block">UVCoord Transforms</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_UVTRAFO_ROTATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_UVTRAFO_TRANSLATION">
<h3>AI_UVTRAFO_TRANSLATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_UVTRAFO_TRANSLATION</span></div>
<div class="block">UVCoord Transforms</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_UVTRAFO_TRANSLATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_UVTRAFO_ALL">
<h3>AI_UVTRAFO_ALL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_UVTRAFO_ALL</span></div>
<div class="block">UVCoord Transforms</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_UVTRAFO_ALL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_NORMALS">
<h3>aiComponent_NORMALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_NORMALS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_NORMALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_TANGENTS_AND_BITANGENTS">
<h3>aiComponent_TANGENTS_AND_BITANGENTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_TANGENTS_AND_BITANGENTS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_TANGENTS_AND_BITANGENTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_COLORS">
<h3>aiComponent_COLORS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_COLORS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_COLORS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_TEXCOORDS">
<h3>aiComponent_TEXCOORDS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_TEXCOORDS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_TEXCOORDS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_BONEWEIGHTS">
<h3>aiComponent_BONEWEIGHTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_BONEWEIGHTS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_BONEWEIGHTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_ANIMATIONS">
<h3>aiComponent_ANIMATIONS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_ANIMATIONS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_ANIMATIONS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_TEXTURES">
<h3>aiComponent_TEXTURES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_TEXTURES</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_TEXTURES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_LIGHTS">
<h3>aiComponent_LIGHTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_LIGHTS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_LIGHTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_CAMERAS">
<h3>aiComponent_CAMERAS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_CAMERAS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_CAMERAS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_MESHES">
<h3>aiComponent_MESHES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_MESHES</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_MESHES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_MATERIALS">
<h3>aiComponent_MATERIALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_MATERIALS</span></div>
<div class="block">Enumerates components of the <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> and <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a> data structures that can be excluded from the import using the <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> step.
 
 <p>See the documentation to <a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiComponent_NORMALS"><code>Component_NORMALS</code></a> - Normal vectors</li>
 <li><a href="#aiComponent_TANGENTS_AND_BITANGENTS"><code>Component_TANGENTS_AND_BITANGENTS</code></a> - Tangents and bitangents go always together</li>
 <li><a href="#aiComponent_COLORS"><code>Component_COLORS</code></a> - ALL color sets. Use <a href="#aiComponent_COLORSn(int)"><code>Component_COLORSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_TEXCOORDS"><code>Component_TEXCOORDS</code></a> - ALL texture UV sets. Use <a href="#aiComponent_TEXCOORDSn(int)"><code>Component_TEXCOORDSn</code></a> to specify the N'th set.</li>
 <li><a href="#aiComponent_BONEWEIGHTS"><code>Component_BONEWEIGHTS</code></a> - 
 Removes all bone weights from all meshes. The scenegraph nodes corresponding to the bones are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_ANIMATIONS"><code>Component_ANIMATIONS</code></a> - 
 Removes all node animations (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mAnimations</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>
 step to do this.
 </li>
 <li><a href="#aiComponent_TEXTURES"><code>Component_TEXTURES</code></a> - Removes all embedded textures</li>
 <li><a href="#aiComponent_LIGHTS"><code>Component_LIGHTS</code></a> - 
 Removes all light sources (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mLights</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to
 do this.
 </li>
 <li><a href="#aiComponent_CAMERAS"><code>Component_CAMERAS</code></a> - 
 Removes all cameras (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mCameras</code>). The corresponding scenegraph nodes are NOT removed. use the <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> step to do
 this.
 </li>
 <li><a href="#aiComponent_MESHES"><code>Component_MESHES</code></a> - Removes all meshes (<a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mMeshes</code>).</li>
 <li><a href="#aiComponent_MATERIALS"><code>Component_MATERIALS</code></a> - Removes all materials. One default material will be generated, so <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mNumMaterials</code> will be 1.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiComponent_MATERIALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATH_PI">
<h3>AI_MATH_PI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">AI_MATH_PI</span></div>
<div class="block">This is PI. Hi PI.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATH_PI">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATH_TWO_PI">
<h3>AI_MATH_TWO_PI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">AI_MATH_TWO_PI</span></div>
<div class="block">This is PI. Hi PI.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATH_TWO_PI">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATH_HALF_PI">
<h3>AI_MATH_HALF_PI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">AI_MATH_HALF_PI</span></div>
<div class="block">This is PI. Hi PI.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATH_HALF_PI">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATH_PI_F">
<h3>AI_MATH_PI_F</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_MATH_PI_F</span></div>
<div class="block">This is PI. Hi PI.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATH_PI_F">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATH_TWO_PI_F">
<h3>AI_MATH_TWO_PI_F</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_MATH_TWO_PI_F</span></div>
<div class="block">This is PI. Hi PI.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATH_TWO_PI_F">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATH_HALF_PI_F">
<h3>AI_MATH_HALF_PI_F</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_MATH_HALF_PI_F</span></div>
<div class="block">This is PI. Hi PI.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATH_HALF_PI_F">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ai_epsilon">
<h3>ai_epsilon</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">ai_epsilon</span></div>
<div class="block">Numerical limits.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.ai_epsilon">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MAXLEN">
<h3>MAXLEN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MAXLEN</span></div>
<div class="block">Maximum dimension for strings, ASSIMP strings are zero terminated.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.MAXLEN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiReturn_SUCCESS">
<h3>aiReturn_SUCCESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiReturn_SUCCESS</span></div>
<div class="block">Standard return type for some library functions, rarely used. (@code aiReturn}
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiReturn_SUCCESS"><code>Return_SUCCESS</code></a> - Indicates that a function was successful.</li>
 <li><a href="#aiReturn_FAILURE"><code>Return_FAILURE</code></a> - Indicates that a function failed.</li>
 <li><a href="#aiReturn_OUTOFMEMORY"><code>Return_OUTOFMEMORY</code></a> - Indicates that not enough memory is available to perform the requested operation.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiReturn_SUCCESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiReturn_FAILURE">
<h3>aiReturn_FAILURE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiReturn_FAILURE</span></div>
<div class="block">Standard return type for some library functions, rarely used. (@code aiReturn}
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiReturn_SUCCESS"><code>Return_SUCCESS</code></a> - Indicates that a function was successful.</li>
 <li><a href="#aiReturn_FAILURE"><code>Return_FAILURE</code></a> - Indicates that a function failed.</li>
 <li><a href="#aiReturn_OUTOFMEMORY"><code>Return_OUTOFMEMORY</code></a> - Indicates that not enough memory is available to perform the requested operation.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiReturn_FAILURE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiReturn_OUTOFMEMORY">
<h3>aiReturn_OUTOFMEMORY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiReturn_OUTOFMEMORY</span></div>
<div class="block">Standard return type for some library functions, rarely used. (@code aiReturn}
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiReturn_SUCCESS"><code>Return_SUCCESS</code></a> - Indicates that a function was successful.</li>
 <li><a href="#aiReturn_FAILURE"><code>Return_FAILURE</code></a> - Indicates that a function failed.</li>
 <li><a href="#aiReturn_OUTOFMEMORY"><code>Return_OUTOFMEMORY</code></a> - Indicates that not enough memory is available to perform the requested operation.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiReturn_OUTOFMEMORY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiOrigin_SET">
<h3>aiOrigin_SET</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiOrigin_SET</span></div>
<div class="block">Seek origins (for the virtual file system API).
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiOrigin_SET"><code>Origin_SET</code></a> - Beginning of the file</li>
 <li><a href="#aiOrigin_CUR"><code>Origin_CUR</code></a> - Current position of the file pointer</li>
 <li><a href="#aiOrigin_END"><code>Origin_END</code></a> - End of the file, offsets must be negative</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiOrigin_SET">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiOrigin_CUR">
<h3>aiOrigin_CUR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiOrigin_CUR</span></div>
<div class="block">Seek origins (for the virtual file system API).
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiOrigin_SET"><code>Origin_SET</code></a> - Beginning of the file</li>
 <li><a href="#aiOrigin_CUR"><code>Origin_CUR</code></a> - Current position of the file pointer</li>
 <li><a href="#aiOrigin_END"><code>Origin_END</code></a> - End of the file, offsets must be negative</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiOrigin_CUR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiOrigin_END">
<h3>aiOrigin_END</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiOrigin_END</span></div>
<div class="block">Seek origins (for the virtual file system API).
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiOrigin_SET"><code>Origin_SET</code></a> - Beginning of the file</li>
 <li><a href="#aiOrigin_CUR"><code>Origin_CUR</code></a> - Current position of the file pointer</li>
 <li><a href="#aiOrigin_END"><code>Origin_END</code></a> - End of the file, offsets must be negative</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiOrigin_END">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiDefaultLogStream_FILE">
<h3>aiDefaultLogStream_FILE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiDefaultLogStream_FILE</span></div>
<div class="block">Enumerates predefined log streaming destinations.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a> - Stream the log to a file</li>
 <li><a href="#aiDefaultLogStream_STDOUT"><code>DefaultLogStream_STDOUT</code></a> - Stream the log to <code>std::cout</code></li>
 <li><a href="#aiDefaultLogStream_STDERR"><code>DefaultLogStream_STDERR</code></a> - Stream the log to <code>std::cerr</code></li>
 <li><a href="#aiDefaultLogStream_DEBUGGER"><code>DefaultLogStream_DEBUGGER</code></a> - MSVC only: Stream the log the the debugger (this relies on <code>OutputDebugString</code> from the Win32 SDK)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiDefaultLogStream_FILE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiDefaultLogStream_STDOUT">
<h3>aiDefaultLogStream_STDOUT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiDefaultLogStream_STDOUT</span></div>
<div class="block">Enumerates predefined log streaming destinations.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a> - Stream the log to a file</li>
 <li><a href="#aiDefaultLogStream_STDOUT"><code>DefaultLogStream_STDOUT</code></a> - Stream the log to <code>std::cout</code></li>
 <li><a href="#aiDefaultLogStream_STDERR"><code>DefaultLogStream_STDERR</code></a> - Stream the log to <code>std::cerr</code></li>
 <li><a href="#aiDefaultLogStream_DEBUGGER"><code>DefaultLogStream_DEBUGGER</code></a> - MSVC only: Stream the log the the debugger (this relies on <code>OutputDebugString</code> from the Win32 SDK)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiDefaultLogStream_STDOUT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiDefaultLogStream_STDERR">
<h3>aiDefaultLogStream_STDERR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiDefaultLogStream_STDERR</span></div>
<div class="block">Enumerates predefined log streaming destinations.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a> - Stream the log to a file</li>
 <li><a href="#aiDefaultLogStream_STDOUT"><code>DefaultLogStream_STDOUT</code></a> - Stream the log to <code>std::cout</code></li>
 <li><a href="#aiDefaultLogStream_STDERR"><code>DefaultLogStream_STDERR</code></a> - Stream the log to <code>std::cerr</code></li>
 <li><a href="#aiDefaultLogStream_DEBUGGER"><code>DefaultLogStream_DEBUGGER</code></a> - MSVC only: Stream the log the the debugger (this relies on <code>OutputDebugString</code> from the Win32 SDK)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiDefaultLogStream_STDERR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiDefaultLogStream_DEBUGGER">
<h3>aiDefaultLogStream_DEBUGGER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiDefaultLogStream_DEBUGGER</span></div>
<div class="block">Enumerates predefined log streaming destinations.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a> - Stream the log to a file</li>
 <li><a href="#aiDefaultLogStream_STDOUT"><code>DefaultLogStream_STDOUT</code></a> - Stream the log to <code>std::cout</code></li>
 <li><a href="#aiDefaultLogStream_STDERR"><code>DefaultLogStream_STDERR</code></a> - Stream the log to <code>std::cerr</code></li>
 <li><a href="#aiDefaultLogStream_DEBUGGER"><code>DefaultLogStream_DEBUGGER</code></a> - MSVC only: Stream the log the the debugger (this relies on <code>OutputDebugString</code> from the Win32 SDK)</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiDefaultLogStream_DEBUGGER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiAnimBehaviour_DEFAULT">
<h3>aiAnimBehaviour_DEFAULT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiAnimBehaviour_DEFAULT</span></div>
<div class="block">Defines how an animation channel behaves outside the defined time range. This corresponds to <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPreState</code> and
 <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPostState</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiAnimBehaviour_DEFAULT"><code>AnimBehaviour_DEFAULT</code></a> - The value from the default node transformation is taken</li>
 <li><a href="#aiAnimBehaviour_CONSTANT"><code>AnimBehaviour_CONSTANT</code></a> - The nearest key value is used without interpolation</li>
 <li><a href="#aiAnimBehaviour_LINEAR"><code>AnimBehaviour_LINEAR</code></a> - The value of the nearest two keys is linearly extrapolated for the current time value.</li>
 <li><a href="#aiAnimBehaviour_REPEAT"><code>AnimBehaviour_REPEAT</code></a> - The animation is repeated. If the animation key go from n to m and the current time is t, use the value at <code>(t-n) % (|m-n|)</code>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiAnimBehaviour_DEFAULT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiAnimBehaviour_CONSTANT">
<h3>aiAnimBehaviour_CONSTANT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiAnimBehaviour_CONSTANT</span></div>
<div class="block">Defines how an animation channel behaves outside the defined time range. This corresponds to <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPreState</code> and
 <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPostState</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiAnimBehaviour_DEFAULT"><code>AnimBehaviour_DEFAULT</code></a> - The value from the default node transformation is taken</li>
 <li><a href="#aiAnimBehaviour_CONSTANT"><code>AnimBehaviour_CONSTANT</code></a> - The nearest key value is used without interpolation</li>
 <li><a href="#aiAnimBehaviour_LINEAR"><code>AnimBehaviour_LINEAR</code></a> - The value of the nearest two keys is linearly extrapolated for the current time value.</li>
 <li><a href="#aiAnimBehaviour_REPEAT"><code>AnimBehaviour_REPEAT</code></a> - The animation is repeated. If the animation key go from n to m and the current time is t, use the value at <code>(t-n) % (|m-n|)</code>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiAnimBehaviour_CONSTANT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiAnimBehaviour_LINEAR">
<h3>aiAnimBehaviour_LINEAR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiAnimBehaviour_LINEAR</span></div>
<div class="block">Defines how an animation channel behaves outside the defined time range. This corresponds to <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPreState</code> and
 <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPostState</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiAnimBehaviour_DEFAULT"><code>AnimBehaviour_DEFAULT</code></a> - The value from the default node transformation is taken</li>
 <li><a href="#aiAnimBehaviour_CONSTANT"><code>AnimBehaviour_CONSTANT</code></a> - The nearest key value is used without interpolation</li>
 <li><a href="#aiAnimBehaviour_LINEAR"><code>AnimBehaviour_LINEAR</code></a> - The value of the nearest two keys is linearly extrapolated for the current time value.</li>
 <li><a href="#aiAnimBehaviour_REPEAT"><code>AnimBehaviour_REPEAT</code></a> - The animation is repeated. If the animation key go from n to m and the current time is t, use the value at <code>(t-n) % (|m-n|)</code>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiAnimBehaviour_LINEAR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiAnimBehaviour_REPEAT">
<h3>aiAnimBehaviour_REPEAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiAnimBehaviour_REPEAT</span></div>
<div class="block">Defines how an animation channel behaves outside the defined time range. This corresponds to <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPreState</code> and
 <a href="AINodeAnim.html" title="class in org.lwjgl.assimp"><code>AINodeAnim</code></a><code>::mPostState</code>.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiAnimBehaviour_DEFAULT"><code>AnimBehaviour_DEFAULT</code></a> - The value from the default node transformation is taken</li>
 <li><a href="#aiAnimBehaviour_CONSTANT"><code>AnimBehaviour_CONSTANT</code></a> - The nearest key value is used without interpolation</li>
 <li><a href="#aiAnimBehaviour_LINEAR"><code>AnimBehaviour_LINEAR</code></a> - The value of the nearest two keys is linearly extrapolated for the current time value.</li>
 <li><a href="#aiAnimBehaviour_REPEAT"><code>AnimBehaviour_REPEAT</code></a> - The animation is repeated. If the animation key go from n to m and the current time is t, use the value at <code>(t-n) % (|m-n|)</code>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiAnimBehaviour_REPEAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_TRUE">
<h3>AI_TRUE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_TRUE</span></div>
<div class="block">Boolean constants
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_TRUE"><code>AI_TRUE</code></a> - true</li>
 <li><a href="#AI_FALSE"><code>AI_FALSE</code></a> - false</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_TRUE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_FALSE">
<h3>AI_FALSE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_FALSE</span></div>
<div class="block">Boolean constants
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_TRUE"><code>AI_TRUE</code></a> - true</li>
 <li><a href="#AI_FALSE"><code>AI_FALSE</code></a> - false</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_FALSE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImporterFlags_SupportTextFlavour">
<h3>aiImporterFlags_SupportTextFlavour</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiImporterFlags_SupportTextFlavour</span></div>
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiImporterFlags_SupportTextFlavour"><code>ImporterFlags_SupportTextFlavour</code></a> - Indicates that there is a textual encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportBinaryFlavour"><code>ImporterFlags_SupportBinaryFlavour</code></a> - Indicates that there is a binary encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportCompressedFlavour"><code>ImporterFlags_SupportCompressedFlavour</code></a> - Indicates that there is a compressed encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_LimitedSupport"><code>ImporterFlags_LimitedSupport</code></a> - 
 Indicates that the importer reads only a very particular subset of the file format. This happens commonly for declarative or procedural formats
 which cannot easily be mapped to <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a>
 </li>
 <li><a href="#aiImporterFlags_Experimental"><code>ImporterFlags_Experimental</code></a> - 
 Indicates that the importer is highly experimental and should be used with care. This only happens for trunk (i.e. SVN) versions, experimental code
 is not included in releases.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiImporterFlags_SupportTextFlavour">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImporterFlags_SupportBinaryFlavour">
<h3>aiImporterFlags_SupportBinaryFlavour</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiImporterFlags_SupportBinaryFlavour</span></div>
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiImporterFlags_SupportTextFlavour"><code>ImporterFlags_SupportTextFlavour</code></a> - Indicates that there is a textual encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportBinaryFlavour"><code>ImporterFlags_SupportBinaryFlavour</code></a> - Indicates that there is a binary encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportCompressedFlavour"><code>ImporterFlags_SupportCompressedFlavour</code></a> - Indicates that there is a compressed encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_LimitedSupport"><code>ImporterFlags_LimitedSupport</code></a> - 
 Indicates that the importer reads only a very particular subset of the file format. This happens commonly for declarative or procedural formats
 which cannot easily be mapped to <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a>
 </li>
 <li><a href="#aiImporterFlags_Experimental"><code>ImporterFlags_Experimental</code></a> - 
 Indicates that the importer is highly experimental and should be used with care. This only happens for trunk (i.e. SVN) versions, experimental code
 is not included in releases.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiImporterFlags_SupportBinaryFlavour">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImporterFlags_SupportCompressedFlavour">
<h3>aiImporterFlags_SupportCompressedFlavour</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiImporterFlags_SupportCompressedFlavour</span></div>
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiImporterFlags_SupportTextFlavour"><code>ImporterFlags_SupportTextFlavour</code></a> - Indicates that there is a textual encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportBinaryFlavour"><code>ImporterFlags_SupportBinaryFlavour</code></a> - Indicates that there is a binary encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportCompressedFlavour"><code>ImporterFlags_SupportCompressedFlavour</code></a> - Indicates that there is a compressed encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_LimitedSupport"><code>ImporterFlags_LimitedSupport</code></a> - 
 Indicates that the importer reads only a very particular subset of the file format. This happens commonly for declarative or procedural formats
 which cannot easily be mapped to <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a>
 </li>
 <li><a href="#aiImporterFlags_Experimental"><code>ImporterFlags_Experimental</code></a> - 
 Indicates that the importer is highly experimental and should be used with care. This only happens for trunk (i.e. SVN) versions, experimental code
 is not included in releases.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiImporterFlags_SupportCompressedFlavour">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImporterFlags_LimitedSupport">
<h3>aiImporterFlags_LimitedSupport</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiImporterFlags_LimitedSupport</span></div>
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiImporterFlags_SupportTextFlavour"><code>ImporterFlags_SupportTextFlavour</code></a> - Indicates that there is a textual encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportBinaryFlavour"><code>ImporterFlags_SupportBinaryFlavour</code></a> - Indicates that there is a binary encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportCompressedFlavour"><code>ImporterFlags_SupportCompressedFlavour</code></a> - Indicates that there is a compressed encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_LimitedSupport"><code>ImporterFlags_LimitedSupport</code></a> - 
 Indicates that the importer reads only a very particular subset of the file format. This happens commonly for declarative or procedural formats
 which cannot easily be mapped to <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a>
 </li>
 <li><a href="#aiImporterFlags_Experimental"><code>ImporterFlags_Experimental</code></a> - 
 Indicates that the importer is highly experimental and should be used with care. This only happens for trunk (i.e. SVN) versions, experimental code
 is not included in releases.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiImporterFlags_LimitedSupport">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImporterFlags_Experimental">
<h3>aiImporterFlags_Experimental</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiImporterFlags_Experimental</span></div>
<div class="block">Mixed set of flags for <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>, indicating some features common to many importers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiImporterFlags_SupportTextFlavour"><code>ImporterFlags_SupportTextFlavour</code></a> - Indicates that there is a textual encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportBinaryFlavour"><code>ImporterFlags_SupportBinaryFlavour</code></a> - Indicates that there is a binary encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_SupportCompressedFlavour"><code>ImporterFlags_SupportCompressedFlavour</code></a> - Indicates that there is a compressed encoding of the file format; and that it is supported.</li>
 <li><a href="#aiImporterFlags_LimitedSupport"><code>ImporterFlags_LimitedSupport</code></a> - 
 Indicates that the importer reads only a very particular subset of the file format. This happens commonly for declarative or procedural formats
 which cannot easily be mapped to <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a>
 </li>
 <li><a href="#aiImporterFlags_Experimental"><code>ImporterFlags_Experimental</code></a> - 
 Indicates that the importer is highly experimental and should be used with care. This only happens for trunk (i.e. SVN) versions, experimental code
 is not included in releases.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiImporterFlags_Experimental">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiLightSource_UNDEFINED">
<h3>aiLightSource_UNDEFINED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiLightSource_UNDEFINED</span></div>
<div class="block">Enumerates all supported types of light sources. (<code>enum aiLightSourceType</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiLightSource_UNDEFINED"><code>LightSource_UNDEFINED</code></a> - Undefined or unknown light source</li>
 <li><a href="#aiLightSource_DIRECTIONAL"><code>LightSource_DIRECTIONAL</code></a> - A directional light source has a well-defined direction but is infinitely far away. That's quite a good approximation for sun light.</li>
 <li><a href="#aiLightSource_POINT"><code>LightSource_POINT</code></a> - A point light source has a well-defined position in space but no direction - it emits light in all directions. A normal bulb is a point light.</li>
 <li><a href="#aiLightSource_SPOT"><code>LightSource_SPOT</code></a> - 
 A spot light source emits light in a specific angle. It has a position and a direction it is pointing to. A good example for a spot light is a
 light spot in sport arenas.
 </li>
 <li><a href="#aiLightSource_AMBIENT"><code>LightSource_AMBIENT</code></a> - 
 The generic light level of the world, including the bounces of all other light sources. Typically, there's at most one ambient light in a scene.
 This light type doesn't have a valid position, direction, or other properties, just a color.
 </li>
 <li><a href="#aiLightSource_AREA"><code>LightSource_AREA</code></a> - 
 An area light is a rectangle with predefined size that uniformly emits light from one of its sides. The position is center of the rectangle and
 direction is its normal vector.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiLightSource_UNDEFINED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiLightSource_DIRECTIONAL">
<h3>aiLightSource_DIRECTIONAL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiLightSource_DIRECTIONAL</span></div>
<div class="block">Enumerates all supported types of light sources. (<code>enum aiLightSourceType</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiLightSource_UNDEFINED"><code>LightSource_UNDEFINED</code></a> - Undefined or unknown light source</li>
 <li><a href="#aiLightSource_DIRECTIONAL"><code>LightSource_DIRECTIONAL</code></a> - A directional light source has a well-defined direction but is infinitely far away. That's quite a good approximation for sun light.</li>
 <li><a href="#aiLightSource_POINT"><code>LightSource_POINT</code></a> - A point light source has a well-defined position in space but no direction - it emits light in all directions. A normal bulb is a point light.</li>
 <li><a href="#aiLightSource_SPOT"><code>LightSource_SPOT</code></a> - 
 A spot light source emits light in a specific angle. It has a position and a direction it is pointing to. A good example for a spot light is a
 light spot in sport arenas.
 </li>
 <li><a href="#aiLightSource_AMBIENT"><code>LightSource_AMBIENT</code></a> - 
 The generic light level of the world, including the bounces of all other light sources. Typically, there's at most one ambient light in a scene.
 This light type doesn't have a valid position, direction, or other properties, just a color.
 </li>
 <li><a href="#aiLightSource_AREA"><code>LightSource_AREA</code></a> - 
 An area light is a rectangle with predefined size that uniformly emits light from one of its sides. The position is center of the rectangle and
 direction is its normal vector.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiLightSource_DIRECTIONAL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiLightSource_POINT">
<h3>aiLightSource_POINT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiLightSource_POINT</span></div>
<div class="block">Enumerates all supported types of light sources. (<code>enum aiLightSourceType</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiLightSource_UNDEFINED"><code>LightSource_UNDEFINED</code></a> - Undefined or unknown light source</li>
 <li><a href="#aiLightSource_DIRECTIONAL"><code>LightSource_DIRECTIONAL</code></a> - A directional light source has a well-defined direction but is infinitely far away. That's quite a good approximation for sun light.</li>
 <li><a href="#aiLightSource_POINT"><code>LightSource_POINT</code></a> - A point light source has a well-defined position in space but no direction - it emits light in all directions. A normal bulb is a point light.</li>
 <li><a href="#aiLightSource_SPOT"><code>LightSource_SPOT</code></a> - 
 A spot light source emits light in a specific angle. It has a position and a direction it is pointing to. A good example for a spot light is a
 light spot in sport arenas.
 </li>
 <li><a href="#aiLightSource_AMBIENT"><code>LightSource_AMBIENT</code></a> - 
 The generic light level of the world, including the bounces of all other light sources. Typically, there's at most one ambient light in a scene.
 This light type doesn't have a valid position, direction, or other properties, just a color.
 </li>
 <li><a href="#aiLightSource_AREA"><code>LightSource_AREA</code></a> - 
 An area light is a rectangle with predefined size that uniformly emits light from one of its sides. The position is center of the rectangle and
 direction is its normal vector.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiLightSource_POINT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiLightSource_SPOT">
<h3>aiLightSource_SPOT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiLightSource_SPOT</span></div>
<div class="block">Enumerates all supported types of light sources. (<code>enum aiLightSourceType</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiLightSource_UNDEFINED"><code>LightSource_UNDEFINED</code></a> - Undefined or unknown light source</li>
 <li><a href="#aiLightSource_DIRECTIONAL"><code>LightSource_DIRECTIONAL</code></a> - A directional light source has a well-defined direction but is infinitely far away. That's quite a good approximation for sun light.</li>
 <li><a href="#aiLightSource_POINT"><code>LightSource_POINT</code></a> - A point light source has a well-defined position in space but no direction - it emits light in all directions. A normal bulb is a point light.</li>
 <li><a href="#aiLightSource_SPOT"><code>LightSource_SPOT</code></a> - 
 A spot light source emits light in a specific angle. It has a position and a direction it is pointing to. A good example for a spot light is a
 light spot in sport arenas.
 </li>
 <li><a href="#aiLightSource_AMBIENT"><code>LightSource_AMBIENT</code></a> - 
 The generic light level of the world, including the bounces of all other light sources. Typically, there's at most one ambient light in a scene.
 This light type doesn't have a valid position, direction, or other properties, just a color.
 </li>
 <li><a href="#aiLightSource_AREA"><code>LightSource_AREA</code></a> - 
 An area light is a rectangle with predefined size that uniformly emits light from one of its sides. The position is center of the rectangle and
 direction is its normal vector.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiLightSource_SPOT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiLightSource_AMBIENT">
<h3>aiLightSource_AMBIENT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiLightSource_AMBIENT</span></div>
<div class="block">Enumerates all supported types of light sources. (<code>enum aiLightSourceType</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiLightSource_UNDEFINED"><code>LightSource_UNDEFINED</code></a> - Undefined or unknown light source</li>
 <li><a href="#aiLightSource_DIRECTIONAL"><code>LightSource_DIRECTIONAL</code></a> - A directional light source has a well-defined direction but is infinitely far away. That's quite a good approximation for sun light.</li>
 <li><a href="#aiLightSource_POINT"><code>LightSource_POINT</code></a> - A point light source has a well-defined position in space but no direction - it emits light in all directions. A normal bulb is a point light.</li>
 <li><a href="#aiLightSource_SPOT"><code>LightSource_SPOT</code></a> - 
 A spot light source emits light in a specific angle. It has a position and a direction it is pointing to. A good example for a spot light is a
 light spot in sport arenas.
 </li>
 <li><a href="#aiLightSource_AMBIENT"><code>LightSource_AMBIENT</code></a> - 
 The generic light level of the world, including the bounces of all other light sources. Typically, there's at most one ambient light in a scene.
 This light type doesn't have a valid position, direction, or other properties, just a color.
 </li>
 <li><a href="#aiLightSource_AREA"><code>LightSource_AREA</code></a> - 
 An area light is a rectangle with predefined size that uniformly emits light from one of its sides. The position is center of the rectangle and
 direction is its normal vector.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiLightSource_AMBIENT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiLightSource_AREA">
<h3>aiLightSource_AREA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiLightSource_AREA</span></div>
<div class="block">Enumerates all supported types of light sources. (<code>enum aiLightSourceType</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiLightSource_UNDEFINED"><code>LightSource_UNDEFINED</code></a> - Undefined or unknown light source</li>
 <li><a href="#aiLightSource_DIRECTIONAL"><code>LightSource_DIRECTIONAL</code></a> - A directional light source has a well-defined direction but is infinitely far away. That's quite a good approximation for sun light.</li>
 <li><a href="#aiLightSource_POINT"><code>LightSource_POINT</code></a> - A point light source has a well-defined position in space but no direction - it emits light in all directions. A normal bulb is a point light.</li>
 <li><a href="#aiLightSource_SPOT"><code>LightSource_SPOT</code></a> - 
 A spot light source emits light in a specific angle. It has a position and a direction it is pointing to. A good example for a spot light is a
 light spot in sport arenas.
 </li>
 <li><a href="#aiLightSource_AMBIENT"><code>LightSource_AMBIENT</code></a> - 
 The generic light level of the world, including the bounces of all other light sources. Typically, there's at most one ambient light in a scene.
 This light type doesn't have a valid position, direction, or other properties, just a color.
 </li>
 <li><a href="#aiLightSource_AREA"><code>LightSource_AREA</code></a> - 
 An area light is a rectangle with predefined size that uniformly emits light from one of its sides. The position is center of the rectangle and
 direction is its normal vector.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiLightSource_AREA">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_DEFAULT_MATERIAL_NAME">
<h3>AI_DEFAULT_MATERIAL_NAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_DEFAULT_MATERIAL_NAME</span></div>
<div class="block">Name for default materials (2nd is used if meshes have UV coords)</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_DEFAULT_MATERIAL_NAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureOp_Multiply">
<h3>aiTextureOp_Multiply</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureOp_Multiply</span></div>
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureOp_Multiply"><code>TextureOp_Multiply</code></a> - <code>T = T1 * T2</code></li>
 <li><a href="#aiTextureOp_Add"><code>TextureOp_Add</code></a> - <code>T = T1 + T2</code></li>
 <li><a href="#aiTextureOp_Subtract"><code>TextureOp_Subtract</code></a> - <code>T = T1 - T2</code></li>
 <li><a href="#aiTextureOp_Divide"><code>TextureOp_Divide</code></a> - <code>T = T1 / T2</code></li>
 <li><a href="#aiTextureOp_SmoothAdd"><code>TextureOp_SmoothAdd</code></a> - <code>T = (T1 + T2) - (T1 * T2)</code></li>
 <li><a href="#aiTextureOp_SignedAdd"><code>TextureOp_SignedAdd</code></a> - <code>T = T1 + (T2 - 0.5)</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureOp_Multiply">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureOp_Add">
<h3>aiTextureOp_Add</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureOp_Add</span></div>
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureOp_Multiply"><code>TextureOp_Multiply</code></a> - <code>T = T1 * T2</code></li>
 <li><a href="#aiTextureOp_Add"><code>TextureOp_Add</code></a> - <code>T = T1 + T2</code></li>
 <li><a href="#aiTextureOp_Subtract"><code>TextureOp_Subtract</code></a> - <code>T = T1 - T2</code></li>
 <li><a href="#aiTextureOp_Divide"><code>TextureOp_Divide</code></a> - <code>T = T1 / T2</code></li>
 <li><a href="#aiTextureOp_SmoothAdd"><code>TextureOp_SmoothAdd</code></a> - <code>T = (T1 + T2) - (T1 * T2)</code></li>
 <li><a href="#aiTextureOp_SignedAdd"><code>TextureOp_SignedAdd</code></a> - <code>T = T1 + (T2 - 0.5)</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureOp_Add">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureOp_Subtract">
<h3>aiTextureOp_Subtract</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureOp_Subtract</span></div>
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureOp_Multiply"><code>TextureOp_Multiply</code></a> - <code>T = T1 * T2</code></li>
 <li><a href="#aiTextureOp_Add"><code>TextureOp_Add</code></a> - <code>T = T1 + T2</code></li>
 <li><a href="#aiTextureOp_Subtract"><code>TextureOp_Subtract</code></a> - <code>T = T1 - T2</code></li>
 <li><a href="#aiTextureOp_Divide"><code>TextureOp_Divide</code></a> - <code>T = T1 / T2</code></li>
 <li><a href="#aiTextureOp_SmoothAdd"><code>TextureOp_SmoothAdd</code></a> - <code>T = (T1 + T2) - (T1 * T2)</code></li>
 <li><a href="#aiTextureOp_SignedAdd"><code>TextureOp_SignedAdd</code></a> - <code>T = T1 + (T2 - 0.5)</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureOp_Subtract">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureOp_Divide">
<h3>aiTextureOp_Divide</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureOp_Divide</span></div>
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureOp_Multiply"><code>TextureOp_Multiply</code></a> - <code>T = T1 * T2</code></li>
 <li><a href="#aiTextureOp_Add"><code>TextureOp_Add</code></a> - <code>T = T1 + T2</code></li>
 <li><a href="#aiTextureOp_Subtract"><code>TextureOp_Subtract</code></a> - <code>T = T1 - T2</code></li>
 <li><a href="#aiTextureOp_Divide"><code>TextureOp_Divide</code></a> - <code>T = T1 / T2</code></li>
 <li><a href="#aiTextureOp_SmoothAdd"><code>TextureOp_SmoothAdd</code></a> - <code>T = (T1 + T2) - (T1 * T2)</code></li>
 <li><a href="#aiTextureOp_SignedAdd"><code>TextureOp_SignedAdd</code></a> - <code>T = T1 + (T2 - 0.5)</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureOp_Divide">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureOp_SmoothAdd">
<h3>aiTextureOp_SmoothAdd</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureOp_SmoothAdd</span></div>
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureOp_Multiply"><code>TextureOp_Multiply</code></a> - <code>T = T1 * T2</code></li>
 <li><a href="#aiTextureOp_Add"><code>TextureOp_Add</code></a> - <code>T = T1 + T2</code></li>
 <li><a href="#aiTextureOp_Subtract"><code>TextureOp_Subtract</code></a> - <code>T = T1 - T2</code></li>
 <li><a href="#aiTextureOp_Divide"><code>TextureOp_Divide</code></a> - <code>T = T1 / T2</code></li>
 <li><a href="#aiTextureOp_SmoothAdd"><code>TextureOp_SmoothAdd</code></a> - <code>T = (T1 + T2) - (T1 * T2)</code></li>
 <li><a href="#aiTextureOp_SignedAdd"><code>TextureOp_SignedAdd</code></a> - <code>T = T1 + (T2 - 0.5)</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureOp_SmoothAdd">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureOp_SignedAdd">
<h3>aiTextureOp_SignedAdd</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureOp_SignedAdd</span></div>
<div class="block">Defines how the Nth texture of a specific type is combined with
 the result of all previous layers.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureOp_Multiply"><code>TextureOp_Multiply</code></a> - <code>T = T1 * T2</code></li>
 <li><a href="#aiTextureOp_Add"><code>TextureOp_Add</code></a> - <code>T = T1 + T2</code></li>
 <li><a href="#aiTextureOp_Subtract"><code>TextureOp_Subtract</code></a> - <code>T = T1 - T2</code></li>
 <li><a href="#aiTextureOp_Divide"><code>TextureOp_Divide</code></a> - <code>T = T1 / T2</code></li>
 <li><a href="#aiTextureOp_SmoothAdd"><code>TextureOp_SmoothAdd</code></a> - <code>T = (T1 + T2) - (T1 * T2)</code></li>
 <li><a href="#aiTextureOp_SignedAdd"><code>TextureOp_SignedAdd</code></a> - <code>T = T1 + (T2 - 0.5)</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureOp_SignedAdd">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapMode_Wrap">
<h3>aiTextureMapMode_Wrap</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapMode_Wrap</span></div>
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.
 Commonly referred to as 'wrapping mode'.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapMode_Wrap"><code>TextureMapMode_Wrap</code></a> - A texture coordinate <code>u|v</code> is translated to <code>u%1|v%1</code></li>
 <li><a href="#aiTextureMapMode_Clamp"><code>TextureMapMode_Clamp</code></a> - Texture coordinates outside <code>[0...1]</code> are clamped to the nearest valid value.</li>
 <li><a href="#aiTextureMapMode_Decal"><code>TextureMapMode_Decal</code></a> - If the texture coordinates for a pixel are outside <code>[0...1]</code> the texture is not applied to that pixel</li>
 <li><a href="#aiTextureMapMode_Mirror"><code>TextureMapMode_Mirror</code></a> - A texture coordinate <code>u|v</code> becomes <code>u%1|v%1</code> if <code>(u-(u%1))%2</code> is zero and <code>1-(u%1)|1-(v%1)</code> otherwise</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapMode_Wrap">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapMode_Clamp">
<h3>aiTextureMapMode_Clamp</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapMode_Clamp</span></div>
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.
 Commonly referred to as 'wrapping mode'.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapMode_Wrap"><code>TextureMapMode_Wrap</code></a> - A texture coordinate <code>u|v</code> is translated to <code>u%1|v%1</code></li>
 <li><a href="#aiTextureMapMode_Clamp"><code>TextureMapMode_Clamp</code></a> - Texture coordinates outside <code>[0...1]</code> are clamped to the nearest valid value.</li>
 <li><a href="#aiTextureMapMode_Decal"><code>TextureMapMode_Decal</code></a> - If the texture coordinates for a pixel are outside <code>[0...1]</code> the texture is not applied to that pixel</li>
 <li><a href="#aiTextureMapMode_Mirror"><code>TextureMapMode_Mirror</code></a> - A texture coordinate <code>u|v</code> becomes <code>u%1|v%1</code> if <code>(u-(u%1))%2</code> is zero and <code>1-(u%1)|1-(v%1)</code> otherwise</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapMode_Clamp">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapMode_Decal">
<h3>aiTextureMapMode_Decal</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapMode_Decal</span></div>
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.
 Commonly referred to as 'wrapping mode'.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapMode_Wrap"><code>TextureMapMode_Wrap</code></a> - A texture coordinate <code>u|v</code> is translated to <code>u%1|v%1</code></li>
 <li><a href="#aiTextureMapMode_Clamp"><code>TextureMapMode_Clamp</code></a> - Texture coordinates outside <code>[0...1]</code> are clamped to the nearest valid value.</li>
 <li><a href="#aiTextureMapMode_Decal"><code>TextureMapMode_Decal</code></a> - If the texture coordinates for a pixel are outside <code>[0...1]</code> the texture is not applied to that pixel</li>
 <li><a href="#aiTextureMapMode_Mirror"><code>TextureMapMode_Mirror</code></a> - A texture coordinate <code>u|v</code> becomes <code>u%1|v%1</code> if <code>(u-(u%1))%2</code> is zero and <code>1-(u%1)|1-(v%1)</code> otherwise</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapMode_Decal">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapMode_Mirror">
<h3>aiTextureMapMode_Mirror</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapMode_Mirror</span></div>
<div class="block">Defines how UV coordinates outside the [0...1] range are handled.
 Commonly referred to as 'wrapping mode'.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapMode_Wrap"><code>TextureMapMode_Wrap</code></a> - A texture coordinate <code>u|v</code> is translated to <code>u%1|v%1</code></li>
 <li><a href="#aiTextureMapMode_Clamp"><code>TextureMapMode_Clamp</code></a> - Texture coordinates outside <code>[0...1]</code> are clamped to the nearest valid value.</li>
 <li><a href="#aiTextureMapMode_Decal"><code>TextureMapMode_Decal</code></a> - If the texture coordinates for a pixel are outside <code>[0...1]</code> the texture is not applied to that pixel</li>
 <li><a href="#aiTextureMapMode_Mirror"><code>TextureMapMode_Mirror</code></a> - A texture coordinate <code>u|v</code> becomes <code>u%1|v%1</code> if <code>(u-(u%1))%2</code> is zero and <code>1-(u%1)|1-(v%1)</code> otherwise</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapMode_Mirror">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapping_UV">
<h3>aiTextureMapping_UV</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapping_UV</span></div>
<div class="block">Defines how the mapping coords for a texture are generated.
 
 <p>Real-time applications typically require full UV coordinates, so the use of the <a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> step is highly recommended. It generates proper UV
 channels for non-UV mapped objects, as long as an accurate description how the mapping should look like (e.g spherical) is given.</p>
 
 <p>See the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> property for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapping_UV"><code>TextureMapping_UV</code></a> - 
 The mapping coordinates are taken from an UV channel. The <a href="#_AI_MATKEY_UVWSRC_BASE"><code>_AI_MATKEY_UVWSRC_BASE</code></a> property specifies from which UV channel the texture coordinates are
 to be taken from (remember, meshes can have more than one UV channel).
 </li>
 <li><a href="#aiTextureMapping_SPHERE"><code>TextureMapping_SPHERE</code></a> - Spherical mapping</li>
 <li><a href="#aiTextureMapping_CYLINDER"><code>TextureMapping_CYLINDER</code></a> - Cylindrical mapping</li>
 <li><a href="#aiTextureMapping_BOX"><code>TextureMapping_BOX</code></a> - Cubic mapping</li>
 <li><a href="#aiTextureMapping_PLANE"><code>TextureMapping_PLANE</code></a> - Planar mapping</li>
 <li><a href="#aiTextureMapping_OTHER"><code>TextureMapping_OTHER</code></a> - Undefined mapping. Have fun.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapping_UV">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapping_SPHERE">
<h3>aiTextureMapping_SPHERE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapping_SPHERE</span></div>
<div class="block">Defines how the mapping coords for a texture are generated.
 
 <p>Real-time applications typically require full UV coordinates, so the use of the <a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> step is highly recommended. It generates proper UV
 channels for non-UV mapped objects, as long as an accurate description how the mapping should look like (e.g spherical) is given.</p>
 
 <p>See the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> property for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapping_UV"><code>TextureMapping_UV</code></a> - 
 The mapping coordinates are taken from an UV channel. The <a href="#_AI_MATKEY_UVWSRC_BASE"><code>_AI_MATKEY_UVWSRC_BASE</code></a> property specifies from which UV channel the texture coordinates are
 to be taken from (remember, meshes can have more than one UV channel).
 </li>
 <li><a href="#aiTextureMapping_SPHERE"><code>TextureMapping_SPHERE</code></a> - Spherical mapping</li>
 <li><a href="#aiTextureMapping_CYLINDER"><code>TextureMapping_CYLINDER</code></a> - Cylindrical mapping</li>
 <li><a href="#aiTextureMapping_BOX"><code>TextureMapping_BOX</code></a> - Cubic mapping</li>
 <li><a href="#aiTextureMapping_PLANE"><code>TextureMapping_PLANE</code></a> - Planar mapping</li>
 <li><a href="#aiTextureMapping_OTHER"><code>TextureMapping_OTHER</code></a> - Undefined mapping. Have fun.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapping_SPHERE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapping_CYLINDER">
<h3>aiTextureMapping_CYLINDER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapping_CYLINDER</span></div>
<div class="block">Defines how the mapping coords for a texture are generated.
 
 <p>Real-time applications typically require full UV coordinates, so the use of the <a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> step is highly recommended. It generates proper UV
 channels for non-UV mapped objects, as long as an accurate description how the mapping should look like (e.g spherical) is given.</p>
 
 <p>See the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> property for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapping_UV"><code>TextureMapping_UV</code></a> - 
 The mapping coordinates are taken from an UV channel. The <a href="#_AI_MATKEY_UVWSRC_BASE"><code>_AI_MATKEY_UVWSRC_BASE</code></a> property specifies from which UV channel the texture coordinates are
 to be taken from (remember, meshes can have more than one UV channel).
 </li>
 <li><a href="#aiTextureMapping_SPHERE"><code>TextureMapping_SPHERE</code></a> - Spherical mapping</li>
 <li><a href="#aiTextureMapping_CYLINDER"><code>TextureMapping_CYLINDER</code></a> - Cylindrical mapping</li>
 <li><a href="#aiTextureMapping_BOX"><code>TextureMapping_BOX</code></a> - Cubic mapping</li>
 <li><a href="#aiTextureMapping_PLANE"><code>TextureMapping_PLANE</code></a> - Planar mapping</li>
 <li><a href="#aiTextureMapping_OTHER"><code>TextureMapping_OTHER</code></a> - Undefined mapping. Have fun.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapping_CYLINDER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapping_BOX">
<h3>aiTextureMapping_BOX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapping_BOX</span></div>
<div class="block">Defines how the mapping coords for a texture are generated.
 
 <p>Real-time applications typically require full UV coordinates, so the use of the <a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> step is highly recommended. It generates proper UV
 channels for non-UV mapped objects, as long as an accurate description how the mapping should look like (e.g spherical) is given.</p>
 
 <p>See the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> property for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapping_UV"><code>TextureMapping_UV</code></a> - 
 The mapping coordinates are taken from an UV channel. The <a href="#_AI_MATKEY_UVWSRC_BASE"><code>_AI_MATKEY_UVWSRC_BASE</code></a> property specifies from which UV channel the texture coordinates are
 to be taken from (remember, meshes can have more than one UV channel).
 </li>
 <li><a href="#aiTextureMapping_SPHERE"><code>TextureMapping_SPHERE</code></a> - Spherical mapping</li>
 <li><a href="#aiTextureMapping_CYLINDER"><code>TextureMapping_CYLINDER</code></a> - Cylindrical mapping</li>
 <li><a href="#aiTextureMapping_BOX"><code>TextureMapping_BOX</code></a> - Cubic mapping</li>
 <li><a href="#aiTextureMapping_PLANE"><code>TextureMapping_PLANE</code></a> - Planar mapping</li>
 <li><a href="#aiTextureMapping_OTHER"><code>TextureMapping_OTHER</code></a> - Undefined mapping. Have fun.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapping_BOX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapping_PLANE">
<h3>aiTextureMapping_PLANE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapping_PLANE</span></div>
<div class="block">Defines how the mapping coords for a texture are generated.
 
 <p>Real-time applications typically require full UV coordinates, so the use of the <a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> step is highly recommended. It generates proper UV
 channels for non-UV mapped objects, as long as an accurate description how the mapping should look like (e.g spherical) is given.</p>
 
 <p>See the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> property for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapping_UV"><code>TextureMapping_UV</code></a> - 
 The mapping coordinates are taken from an UV channel. The <a href="#_AI_MATKEY_UVWSRC_BASE"><code>_AI_MATKEY_UVWSRC_BASE</code></a> property specifies from which UV channel the texture coordinates are
 to be taken from (remember, meshes can have more than one UV channel).
 </li>
 <li><a href="#aiTextureMapping_SPHERE"><code>TextureMapping_SPHERE</code></a> - Spherical mapping</li>
 <li><a href="#aiTextureMapping_CYLINDER"><code>TextureMapping_CYLINDER</code></a> - Cylindrical mapping</li>
 <li><a href="#aiTextureMapping_BOX"><code>TextureMapping_BOX</code></a> - Cubic mapping</li>
 <li><a href="#aiTextureMapping_PLANE"><code>TextureMapping_PLANE</code></a> - Planar mapping</li>
 <li><a href="#aiTextureMapping_OTHER"><code>TextureMapping_OTHER</code></a> - Undefined mapping. Have fun.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapping_PLANE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureMapping_OTHER">
<h3>aiTextureMapping_OTHER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureMapping_OTHER</span></div>
<div class="block">Defines how the mapping coords for a texture are generated.
 
 <p>Real-time applications typically require full UV coordinates, so the use of the <a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> step is highly recommended. It generates proper UV
 channels for non-UV mapped objects, as long as an accurate description how the mapping should look like (e.g spherical) is given.</p>
 
 <p>See the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> property for more details.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureMapping_UV"><code>TextureMapping_UV</code></a> - 
 The mapping coordinates are taken from an UV channel. The <a href="#_AI_MATKEY_UVWSRC_BASE"><code>_AI_MATKEY_UVWSRC_BASE</code></a> property specifies from which UV channel the texture coordinates are
 to be taken from (remember, meshes can have more than one UV channel).
 </li>
 <li><a href="#aiTextureMapping_SPHERE"><code>TextureMapping_SPHERE</code></a> - Spherical mapping</li>
 <li><a href="#aiTextureMapping_CYLINDER"><code>TextureMapping_CYLINDER</code></a> - Cylindrical mapping</li>
 <li><a href="#aiTextureMapping_BOX"><code>TextureMapping_BOX</code></a> - Cubic mapping</li>
 <li><a href="#aiTextureMapping_PLANE"><code>TextureMapping_PLANE</code></a> - Planar mapping</li>
 <li><a href="#aiTextureMapping_OTHER"><code>TextureMapping_OTHER</code></a> - Undefined mapping. Have fun.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureMapping_OTHER">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_NONE">
<h3>aiTextureType_NONE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_NONE</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_NONE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_DIFFUSE">
<h3>aiTextureType_DIFFUSE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_DIFFUSE</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_DIFFUSE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_SPECULAR">
<h3>aiTextureType_SPECULAR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_SPECULAR</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_SPECULAR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_AMBIENT">
<h3>aiTextureType_AMBIENT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_AMBIENT</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_AMBIENT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_EMISSIVE">
<h3>aiTextureType_EMISSIVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_EMISSIVE</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_EMISSIVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_HEIGHT">
<h3>aiTextureType_HEIGHT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_HEIGHT</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_HEIGHT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_NORMALS">
<h3>aiTextureType_NORMALS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_NORMALS</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_NORMALS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_SHININESS">
<h3>aiTextureType_SHININESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_SHININESS</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_SHININESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_OPACITY">
<h3>aiTextureType_OPACITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_OPACITY</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_OPACITY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_DISPLACEMENT">
<h3>aiTextureType_DISPLACEMENT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_DISPLACEMENT</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_DISPLACEMENT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_LIGHTMAP">
<h3>aiTextureType_LIGHTMAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_LIGHTMAP</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_LIGHTMAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_REFLECTION">
<h3>aiTextureType_REFLECTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_REFLECTION</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_REFLECTION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_BASE_COLOR">
<h3>aiTextureType_BASE_COLOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_BASE_COLOR</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_BASE_COLOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_NORMAL_CAMERA">
<h3>aiTextureType_NORMAL_CAMERA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_NORMAL_CAMERA</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_NORMAL_CAMERA">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_EMISSION_COLOR">
<h3>aiTextureType_EMISSION_COLOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_EMISSION_COLOR</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_EMISSION_COLOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_METALNESS">
<h3>aiTextureType_METALNESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_METALNESS</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_METALNESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_DIFFUSE_ROUGHNESS">
<h3>aiTextureType_DIFFUSE_ROUGHNESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_DIFFUSE_ROUGHNESS</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_DIFFUSE_ROUGHNESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_AMBIENT_OCCLUSION">
<h3>aiTextureType_AMBIENT_OCCLUSION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_AMBIENT_OCCLUSION</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_AMBIENT_OCCLUSION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_SHEEN">
<h3>aiTextureType_SHEEN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_SHEEN</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_SHEEN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_CLEARCOAT">
<h3>aiTextureType_CLEARCOAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_CLEARCOAT</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_CLEARCOAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_TRANSMISSION">
<h3>aiTextureType_TRANSMISSION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_TRANSMISSION</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_TRANSMISSION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureType_UNKNOWN">
<h3>aiTextureType_UNKNOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureType_UNKNOWN</span></div>
<div class="block">Defines the purpose of a texture.
 
 <p>This is a very difficult topic. Different 3D packages support different kinds of textures. For very common texture types, such as bumpmaps, the
 rendering results depend on implementation details in the rendering pipelines of these applications. Assimp loads all texture references from the model
 file and tries to determine which of the predefined texture types below is the best choice to match the original use of the texture as closely as
 possible.</p>
 
 <p>In content pipelines you'll usually define how textures have to be handled, and the artists working on models have to conform to this specification,
 regardless which 3D tool they're using.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a> - 
 Dummy value. No texture, but the value to be used as 'texture semantic' (<a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a><code>::mSemantic</code>) for all material properties *not*
 related to textures.
 </li>
 <li><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a> - The texture is combined with the result of the diffuse lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a> - The texture is combined with the result of the specular lighting equation OR PBR Specular/Glossiness.</li>
 <li><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a> - The texture is combined with the result of the ambient lighting equation.</li>
 <li><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a> - The texture is added to the result of the lighting calculation. It isn't influenced by incoming light.</li>
 <li><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a> - The texture is a height map. By convention, higher gray-scale values stand for higher elevations from the base height.</li>
 <li><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a> - 
 The texture is a (tangent space) normal-map. Again, there are several conventions for tangent-space normal maps. Assimp does (intentionally) not
 distinguish here.
 </li>
 <li><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a> - 
 The texture defines the glossiness of the material. The glossiness is in fact the exponent of the specular (phong) lighting equation. Usually there
 is a conversion function defined to map the linear color values in the texture to a suitable exponent. Have fun.
 </li>
 <li><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a> - The texture defines per-pixel opacity. Usually 'white' means opaque and 'black' means 'transparency'. Or quite the opposite. Have fun.</li>
 <li><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a> - Displacement texture. The exact purpose and format is application-dependent. Higher color values stand for higher vertex displacements.</li>
 <li><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a> - 
 Lightmap texture (aka Ambient Occlusion). Both 'Lightmaps' and dedicated 'ambient occlusion maps' are covered by this material property. The
 texture contains a scaling value for the final color value of a pixel. Its intensity is not affected by incoming light.
 </li>
 <li><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a> - Reflection texture. Contains the color of a perfect mirror reflection. Rarely used, almost never for real-time applications.</li>
 <li><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a> - PBR material.</li>
 <li><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a> - 
 Generally used to simulate textiles that are covered in a layer of microfibers eg velvet.
 
 <p><a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen">KHR_materials_sheen</a>)</p>
 </li>
 <li><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a> - 
 Simulates a layer of 'polish' or 'laquer' layered on top of a PBR substrate.
 
 <p><a target="_blank" href="https://autodesk.github.io/standard-surface/#closures/coating">coating</a>,
 <a target="_blank" href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat">KHR_materials_clearcoat</a></p>
 </li>
 <li><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a> - 
 Simulates transmission through the surface.
 
 <p>May include further information such as wall thickness.</p>
 </li>
 <li><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a> - 
 Unknown texture. A texture reference that does not match any of the definitions above is considered to be 'unknown'. It is still imported, but is
 excluded from any further post-processing.
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureType_UNKNOWN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Flat">
<h3>aiShadingMode_Flat</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Flat</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Flat">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Gouraud">
<h3>aiShadingMode_Gouraud</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Gouraud</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Gouraud">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Phong">
<h3>aiShadingMode_Phong</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Phong</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Phong">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Blinn">
<h3>aiShadingMode_Blinn</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Blinn</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Blinn">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Toon">
<h3>aiShadingMode_Toon</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Toon</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Toon">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_OrenNayar">
<h3>aiShadingMode_OrenNayar</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_OrenNayar</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_OrenNayar">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Minnaert">
<h3>aiShadingMode_Minnaert</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Minnaert</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Minnaert">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_CookTorrance">
<h3>aiShadingMode_CookTorrance</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_CookTorrance</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_CookTorrance">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_NoShading">
<h3>aiShadingMode_NoShading</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_NoShading</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_NoShading">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Unlit">
<h3>aiShadingMode_Unlit</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Unlit</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Unlit">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_Fresnel">
<h3>aiShadingMode_Fresnel</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_Fresnel</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_Fresnel">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiShadingMode_PBR_BRDF">
<h3>aiShadingMode_PBR_BRDF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiShadingMode_PBR_BRDF</span></div>
<div class="block">Defines all shading models supported by the library. (<code>aiShadingMode</code>)
 
 <p>Property: <a href="#AI_MATKEY_SHADING_MODEL"><code>AI_MATKEY_SHADING_MODEL</code></a></p>
 
 <p>The list of shading modes has been taken from Blender. See Blender documentation for more information. The API does not distinguish between "specular"
 and "diffuse" shaders (thus the specular term for diffuse shading models like Oren-Nayar remains undefined).</p>
 
 <p>Again, this value is just a hint. Assimp tries to select the shader whose most common implementation matches the original rendering results of the 3D
 modeller which wrote a particular model as closely as possible.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiShadingMode_Flat"><code>ShadingMode_Flat</code></a> - Flat shading. Shading is done on per-face base, diffuse only. Also known as 'faceted shading'.</li>
 <li><a href="#aiShadingMode_Gouraud"><code>ShadingMode_Gouraud</code></a> - Simple Gouraud shading.</li>
 <li><a href="#aiShadingMode_Phong"><code>ShadingMode_Phong</code></a> - Phong-Shading</li>
 <li><a href="#aiShadingMode_Blinn"><code>ShadingMode_Blinn</code></a> - Phong-Blinn-Shading</li>
 <li><a href="#aiShadingMode_Toon"><code>ShadingMode_Toon</code></a> - Toon-Shading per pixel. Also known as 'comic' shader.</li>
 <li><a href="#aiShadingMode_OrenNayar"><code>ShadingMode_OrenNayar</code></a> - OrenNayar-Shading per pixel. Extension to standard Lambertian shading, taking the roughness of the material into account</li>
 <li><a href="#aiShadingMode_Minnaert"><code>ShadingMode_Minnaert</code></a> - Minnaert-Shading per pixel. Extension to standard Lambertian shading, taking the 'darkness' of the material into account</li>
 <li><a href="#aiShadingMode_CookTorrance"><code>ShadingMode_CookTorrance</code></a> - CookTorrance-Shading per pixel. Special shader for metallic surfaces.</li>
 <li><a href="#aiShadingMode_NoShading"><code>ShadingMode_NoShading</code></a> - No shading at all. Constant light influence of 1.0. Also known as "Unlit".</li>
 <li><a href="#aiShadingMode_Unlit"><code>ShadingMode_Unlit</code></a></li>
 <li><a href="#aiShadingMode_Fresnel"><code>ShadingMode_Fresnel</code></a> - Fresnel shading</li>
 <li><a href="#aiShadingMode_PBR_BRDF"><code>ShadingMode_PBR_BRDF</code></a> - 
 Physically-Based Rendering (PBR) shading using Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
 
 <p>There are multiple methods under this banner, and model files may provide data for more than one PBR-BRDF method. Applications should use the set
 of provided properties to determine which of their preferred PBR rendering methods are likely to be available eg:</p>
 
 <ul>
 <li>If <a href="#AI_MATKEY_METALLIC_FACTOR"><code>AI_MATKEY_METALLIC_FACTOR</code></a> is set, then a Metallic/Roughness is available</li>
 <li>If <a href="#AI_MATKEY_GLOSSINESS_FACTOR"><code>AI_MATKEY_GLOSSINESS_FACTOR</code></a> is set, then a Specular/Glossiness is available</li>
 </ul>
 
 <p>Note that some PBR methods allow layering of techniques.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiShadingMode_PBR_BRDF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureFlags_Invert">
<h3>aiTextureFlags_Invert</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureFlags_Invert</span></div>
<div class="block">Defines some mixed flags for a particular texture.
 
 <p>Usually you'll instruct your cg artists how textures have to look like and how they will be processed in your application. However, if you use Assimp
 for completely generic loading purposes you might also need to process these flags in order to display as many 'unknown' 3D models as possible
 correctly.</p>
 
 <p>This corresponds to the <a href="#_AI_MATKEY_TEXFLAGS_BASE"><code>_AI_MATKEY_TEXFLAGS_BASE</code></a> property.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureFlags_Invert"><code>TextureFlags_Invert</code></a> - The texture's color values have to be inverted (component-wise 1-n)</li>
 <li><a href="#aiTextureFlags_UseAlpha"><code>TextureFlags_UseAlpha</code></a> - 
 Explicit request to the application to process the alpha channel of the texture. Mutually exclusive with <a href="#aiTextureFlags_IgnoreAlpha"><code>TextureFlags_IgnoreAlpha</code></a>. These flags are
 set if the library can say for sure that the alpha channel is used/is not used. If the model format does not define this, it is left to the
 application to decide whether the texture alpha channel - if any - is evaluated or not.
 </li>
 <li><a href="#aiTextureFlags_IgnoreAlpha"><code>TextureFlags_IgnoreAlpha</code></a> - Explicit request to the application to ignore the alpha channel of the texture. Mutually exclusive with <a href="#aiTextureFlags_UseAlpha"><code>TextureFlags_UseAlpha</code></a>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureFlags_Invert">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureFlags_UseAlpha">
<h3>aiTextureFlags_UseAlpha</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureFlags_UseAlpha</span></div>
<div class="block">Defines some mixed flags for a particular texture.
 
 <p>Usually you'll instruct your cg artists how textures have to look like and how they will be processed in your application. However, if you use Assimp
 for completely generic loading purposes you might also need to process these flags in order to display as many 'unknown' 3D models as possible
 correctly.</p>
 
 <p>This corresponds to the <a href="#_AI_MATKEY_TEXFLAGS_BASE"><code>_AI_MATKEY_TEXFLAGS_BASE</code></a> property.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureFlags_Invert"><code>TextureFlags_Invert</code></a> - The texture's color values have to be inverted (component-wise 1-n)</li>
 <li><a href="#aiTextureFlags_UseAlpha"><code>TextureFlags_UseAlpha</code></a> - 
 Explicit request to the application to process the alpha channel of the texture. Mutually exclusive with <a href="#aiTextureFlags_IgnoreAlpha"><code>TextureFlags_IgnoreAlpha</code></a>. These flags are
 set if the library can say for sure that the alpha channel is used/is not used. If the model format does not define this, it is left to the
 application to decide whether the texture alpha channel - if any - is evaluated or not.
 </li>
 <li><a href="#aiTextureFlags_IgnoreAlpha"><code>TextureFlags_IgnoreAlpha</code></a> - Explicit request to the application to ignore the alpha channel of the texture. Mutually exclusive with <a href="#aiTextureFlags_UseAlpha"><code>TextureFlags_UseAlpha</code></a>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureFlags_UseAlpha">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiTextureFlags_IgnoreAlpha">
<h3>aiTextureFlags_IgnoreAlpha</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiTextureFlags_IgnoreAlpha</span></div>
<div class="block">Defines some mixed flags for a particular texture.
 
 <p>Usually you'll instruct your cg artists how textures have to look like and how they will be processed in your application. However, if you use Assimp
 for completely generic loading purposes you might also need to process these flags in order to display as many 'unknown' 3D models as possible
 correctly.</p>
 
 <p>This corresponds to the <a href="#_AI_MATKEY_TEXFLAGS_BASE"><code>_AI_MATKEY_TEXFLAGS_BASE</code></a> property.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiTextureFlags_Invert"><code>TextureFlags_Invert</code></a> - The texture's color values have to be inverted (component-wise 1-n)</li>
 <li><a href="#aiTextureFlags_UseAlpha"><code>TextureFlags_UseAlpha</code></a> - 
 Explicit request to the application to process the alpha channel of the texture. Mutually exclusive with <a href="#aiTextureFlags_IgnoreAlpha"><code>TextureFlags_IgnoreAlpha</code></a>. These flags are
 set if the library can say for sure that the alpha channel is used/is not used. If the model format does not define this, it is left to the
 application to decide whether the texture alpha channel - if any - is evaluated or not.
 </li>
 <li><a href="#aiTextureFlags_IgnoreAlpha"><code>TextureFlags_IgnoreAlpha</code></a> - Explicit request to the application to ignore the alpha channel of the texture. Mutually exclusive with <a href="#aiTextureFlags_UseAlpha"><code>TextureFlags_UseAlpha</code></a>.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiTextureFlags_IgnoreAlpha">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiBlendMode_Default">
<h3>aiBlendMode_Default</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiBlendMode_Default</span></div>
<div class="block">Defines alpha-blend flags.
 
 <p>If you're familiar with OpenGL or D3D, these flags aren't new to you. They define *how* the final color value of a pixel is computed, basing on the
 previous color at that pixel and the new color value from the material.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiBlendMode_Default"><code>BlendMode_Default</code></a> - <code>SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)</code></li>
 <li><a href="#aiBlendMode_Additive"><code>BlendMode_Additive</code></a> - <code>SourceColor*1 + DestColor*1</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiBlendMode_Default">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiBlendMode_Additive">
<h3>aiBlendMode_Additive</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiBlendMode_Additive</span></div>
<div class="block">Defines alpha-blend flags.
 
 <p>If you're familiar with OpenGL or D3D, these flags aren't new to you. They define *how* the final color value of a pixel is computed, basing on the
 previous color at that pixel and the new color value from the material.</p>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiBlendMode_Default"><code>BlendMode_Default</code></a> - <code>SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)</code></li>
 <li><a href="#aiBlendMode_Additive"><code>BlendMode_Additive</code></a> - <code>SourceColor*1 + DestColor*1</code></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiBlendMode_Additive">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPTI_Float">
<h3>aiPTI_Float</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPTI_Float</span></div>
<div class="block">A very primitive RTTI system for the contents of material properties.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPTI_Float"><code>PTI_Float</code></a> - Array of single-precision (32 Bit) floats</li>
 <li><a href="#aiPTI_Double"><code>PTI_Double</code></a> - Array of double-precision (64 Bit) floats</li>
 <li><a href="#aiPTI_String"><code>PTI_String</code></a> - The material property is an aiString.</li>
 <li><a href="#aiPTI_Integer"><code>PTI_Integer</code></a> - Array of (32 Bit) integers</li>
 <li><a href="#aiPTI_Buffer"><code>PTI_Buffer</code></a> - Simple binary buffer, content undefined. Not convertible to anything.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPTI_Float">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPTI_Double">
<h3>aiPTI_Double</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPTI_Double</span></div>
<div class="block">A very primitive RTTI system for the contents of material properties.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPTI_Float"><code>PTI_Float</code></a> - Array of single-precision (32 Bit) floats</li>
 <li><a href="#aiPTI_Double"><code>PTI_Double</code></a> - Array of double-precision (64 Bit) floats</li>
 <li><a href="#aiPTI_String"><code>PTI_String</code></a> - The material property is an aiString.</li>
 <li><a href="#aiPTI_Integer"><code>PTI_Integer</code></a> - Array of (32 Bit) integers</li>
 <li><a href="#aiPTI_Buffer"><code>PTI_Buffer</code></a> - Simple binary buffer, content undefined. Not convertible to anything.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPTI_Double">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPTI_String">
<h3>aiPTI_String</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPTI_String</span></div>
<div class="block">A very primitive RTTI system for the contents of material properties.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPTI_Float"><code>PTI_Float</code></a> - Array of single-precision (32 Bit) floats</li>
 <li><a href="#aiPTI_Double"><code>PTI_Double</code></a> - Array of double-precision (64 Bit) floats</li>
 <li><a href="#aiPTI_String"><code>PTI_String</code></a> - The material property is an aiString.</li>
 <li><a href="#aiPTI_Integer"><code>PTI_Integer</code></a> - Array of (32 Bit) integers</li>
 <li><a href="#aiPTI_Buffer"><code>PTI_Buffer</code></a> - Simple binary buffer, content undefined. Not convertible to anything.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPTI_String">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPTI_Integer">
<h3>aiPTI_Integer</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPTI_Integer</span></div>
<div class="block">A very primitive RTTI system for the contents of material properties.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPTI_Float"><code>PTI_Float</code></a> - Array of single-precision (32 Bit) floats</li>
 <li><a href="#aiPTI_Double"><code>PTI_Double</code></a> - Array of double-precision (64 Bit) floats</li>
 <li><a href="#aiPTI_String"><code>PTI_String</code></a> - The material property is an aiString.</li>
 <li><a href="#aiPTI_Integer"><code>PTI_Integer</code></a> - Array of (32 Bit) integers</li>
 <li><a href="#aiPTI_Buffer"><code>PTI_Buffer</code></a> - Simple binary buffer, content undefined. Not convertible to anything.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPTI_Integer">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPTI_Buffer">
<h3>aiPTI_Buffer</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPTI_Buffer</span></div>
<div class="block">A very primitive RTTI system for the contents of material properties.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPTI_Float"><code>PTI_Float</code></a> - Array of single-precision (32 Bit) floats</li>
 <li><a href="#aiPTI_Double"><code>PTI_Double</code></a> - Array of double-precision (64 Bit) floats</li>
 <li><a href="#aiPTI_String"><code>PTI_String</code></a> - The material property is an aiString.</li>
 <li><a href="#aiPTI_Integer"><code>PTI_Integer</code></a> - Array of (32 Bit) integers</li>
 <li><a href="#aiPTI_Buffer"><code>PTI_Buffer</code></a> - Simple binary buffer, content undefined. Not convertible to anything.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPTI_Buffer">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_NAME">
<h3>AI_MATKEY_NAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_NAME</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_NAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_TWOSIDED">
<h3>AI_MATKEY_TWOSIDED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_TWOSIDED</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_TWOSIDED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHADING_MODEL">
<h3>AI_MATKEY_SHADING_MODEL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHADING_MODEL</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHADING_MODEL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_ENABLE_WIREFRAME">
<h3>AI_MATKEY_ENABLE_WIREFRAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_ENABLE_WIREFRAME</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_ENABLE_WIREFRAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_BLEND_FUNC">
<h3>AI_MATKEY_BLEND_FUNC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_BLEND_FUNC</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_BLEND_FUNC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_OPACITY">
<h3>AI_MATKEY_OPACITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_OPACITY</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_OPACITY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_TRANSPARENCYFACTOR">
<h3>AI_MATKEY_TRANSPARENCYFACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_TRANSPARENCYFACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_TRANSPARENCYFACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_BUMPSCALING">
<h3>AI_MATKEY_BUMPSCALING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_BUMPSCALING</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_BUMPSCALING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHININESS">
<h3>AI_MATKEY_SHININESS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHININESS</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHININESS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_REFLECTIVITY">
<h3>AI_MATKEY_REFLECTIVITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_REFLECTIVITY</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_REFLECTIVITY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHININESS_STRENGTH">
<h3>AI_MATKEY_SHININESS_STRENGTH</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHININESS_STRENGTH</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHININESS_STRENGTH">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_REFRACTI">
<h3>AI_MATKEY_REFRACTI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_REFRACTI</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_REFRACTI">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_COLOR_DIFFUSE">
<h3>AI_MATKEY_COLOR_DIFFUSE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_COLOR_DIFFUSE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_COLOR_DIFFUSE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_COLOR_AMBIENT">
<h3>AI_MATKEY_COLOR_AMBIENT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_COLOR_AMBIENT</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_COLOR_AMBIENT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_COLOR_SPECULAR">
<h3>AI_MATKEY_COLOR_SPECULAR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_COLOR_SPECULAR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_COLOR_SPECULAR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_COLOR_EMISSIVE">
<h3>AI_MATKEY_COLOR_EMISSIVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_COLOR_EMISSIVE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_COLOR_EMISSIVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_COLOR_TRANSPARENT">
<h3>AI_MATKEY_COLOR_TRANSPARENT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_COLOR_TRANSPARENT</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_COLOR_TRANSPARENT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_COLOR_REFLECTIVE">
<h3>AI_MATKEY_COLOR_REFLECTIVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_COLOR_REFLECTIVE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_COLOR_REFLECTIVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_GLOBAL_BACKGROUND_IMAGE">
<h3>AI_MATKEY_GLOBAL_BACKGROUND_IMAGE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_GLOBAL_BACKGROUND_IMAGE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_GLOBAL_BACKGROUND_IMAGE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_GLOBAL_SHADERLANG">
<h3>AI_MATKEY_GLOBAL_SHADERLANG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_GLOBAL_SHADERLANG</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_GLOBAL_SHADERLANG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHADER_VERTEX">
<h3>AI_MATKEY_SHADER_VERTEX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHADER_VERTEX</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHADER_VERTEX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHADER_FRAGMENT">
<h3>AI_MATKEY_SHADER_FRAGMENT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHADER_FRAGMENT</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHADER_FRAGMENT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHADER_GEO">
<h3>AI_MATKEY_SHADER_GEO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHADER_GEO</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHADER_GEO">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHADER_TESSELATION">
<h3>AI_MATKEY_SHADER_TESSELATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHADER_TESSELATION</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHADER_TESSELATION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHADER_PRIMITIVE">
<h3>AI_MATKEY_SHADER_PRIMITIVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHADER_PRIMITIVE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHADER_PRIMITIVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHADER_COMPUTE">
<h3>AI_MATKEY_SHADER_COMPUTE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHADER_COMPUTE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHADER_COMPUTE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_USE_COLOR_MAP">
<h3>AI_MATKEY_USE_COLOR_MAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_USE_COLOR_MAP</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_USE_COLOR_MAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_BASE_COLOR">
<h3>AI_MATKEY_BASE_COLOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_BASE_COLOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_BASE_COLOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_USE_METALLIC_MAP">
<h3>AI_MATKEY_USE_METALLIC_MAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_USE_METALLIC_MAP</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_USE_METALLIC_MAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_METALLIC_FACTOR">
<h3>AI_MATKEY_METALLIC_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_METALLIC_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_METALLIC_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_USE_ROUGHNESS_MAP">
<h3>AI_MATKEY_USE_ROUGHNESS_MAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_USE_ROUGHNESS_MAP</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_USE_ROUGHNESS_MAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_ROUGHNESS_FACTOR">
<h3>AI_MATKEY_ROUGHNESS_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_ROUGHNESS_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_ROUGHNESS_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_ANISOTROPY_FACTOR">
<h3>AI_MATKEY_ANISOTROPY_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_ANISOTROPY_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_ANISOTROPY_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SPECULAR_FACTOR">
<h3>AI_MATKEY_SPECULAR_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SPECULAR_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SPECULAR_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_GLOSSINESS_FACTOR">
<h3>AI_MATKEY_GLOSSINESS_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_GLOSSINESS_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_GLOSSINESS_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHEEN_COLOR_FACTOR">
<h3>AI_MATKEY_SHEEN_COLOR_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHEEN_COLOR_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHEEN_COLOR_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_SHEEN_ROUGHNESS_FACTOR">
<h3>AI_MATKEY_SHEEN_ROUGHNESS_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_SHEEN_ROUGHNESS_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_SHEEN_ROUGHNESS_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_CLEARCOAT_FACTOR">
<h3>AI_MATKEY_CLEARCOAT_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_CLEARCOAT_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_CLEARCOAT_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR">
<h3>AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_TRANSMISSION_FACTOR">
<h3>AI_MATKEY_TRANSMISSION_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_TRANSMISSION_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_TRANSMISSION_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_VOLUME_THICKNESS_FACTOR">
<h3>AI_MATKEY_VOLUME_THICKNESS_FACTOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_VOLUME_THICKNESS_FACTOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_VOLUME_THICKNESS_FACTOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_VOLUME_ATTENUATION_DISTANCE">
<h3>AI_MATKEY_VOLUME_ATTENUATION_DISTANCE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_VOLUME_ATTENUATION_DISTANCE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_VOLUME_ATTENUATION_DISTANCE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_VOLUME_ATTENUATION_COLOR">
<h3>AI_MATKEY_VOLUME_ATTENUATION_COLOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_VOLUME_ATTENUATION_COLOR</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_VOLUME_ATTENUATION_COLOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_USE_EMISSIVE_MAP">
<h3>AI_MATKEY_USE_EMISSIVE_MAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_USE_EMISSIVE_MAP</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_USE_EMISSIVE_MAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_EMISSIVE_INTENSITY">
<h3>AI_MATKEY_EMISSIVE_INTENSITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_EMISSIVE_INTENSITY</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_EMISSIVE_INTENSITY">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_USE_AO_MAP">
<h3>AI_MATKEY_USE_AO_MAP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_USE_AO_MAP</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_USE_AO_MAP">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_OBJ_ILLUM">
<h3>AI_MATKEY_OBJ_ILLUM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_OBJ_ILLUM</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_OBJ_ILLUM">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_TEXTURE_BASE">
<h3>_AI_MATKEY_TEXTURE_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_TEXTURE_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_TEXTURE_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_UVWSRC_BASE">
<h3>_AI_MATKEY_UVWSRC_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_UVWSRC_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_UVWSRC_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_TEXOP_BASE">
<h3>_AI_MATKEY_TEXOP_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_TEXOP_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_TEXOP_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_MAPPING_BASE">
<h3>_AI_MATKEY_MAPPING_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_MAPPING_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_MAPPING_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_TEXBLEND_BASE">
<h3>_AI_MATKEY_TEXBLEND_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_TEXBLEND_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_TEXBLEND_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_MAPPINGMODE_U_BASE">
<h3>_AI_MATKEY_MAPPINGMODE_U_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_MAPPINGMODE_U_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_MAPPINGMODE_U_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_MAPPINGMODE_V_BASE">
<h3>_AI_MATKEY_MAPPINGMODE_V_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_MAPPINGMODE_V_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_MAPPINGMODE_V_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_TEXMAP_AXIS_BASE">
<h3>_AI_MATKEY_TEXMAP_AXIS_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_TEXMAP_AXIS_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_TEXMAP_AXIS_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_UVTRANSFORM_BASE">
<h3>_AI_MATKEY_UVTRANSFORM_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_UVTRANSFORM_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_UVTRANSFORM_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_TEXFLAGS_BASE">
<h3>_AI_MATKEY_TEXFLAGS_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_TEXFLAGS_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_TEXFLAGS_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_OBJ_BUMPMULT_BASE">
<h3>_AI_MATKEY_OBJ_BUMPMULT_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_OBJ_BUMPMULT_BASE</span></div>
<div class="block">Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_OBJ_BUMPMULT_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE">
<h3>AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE</span></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_GLTF_ALPHAMODE">
<h3>AI_MATKEY_GLTF_ALPHAMODE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_GLTF_ALPHAMODE</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_GLTF_ALPHAMODE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MATKEY_GLTF_ALPHACUTOFF">
<h3>AI_MATKEY_GLTF_ALPHACUTOFF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_MATKEY_GLTF_ALPHACUTOFF</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MATKEY_GLTF_ALPHACUTOFF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_GLTF_MAPPINGNAME_BASE">
<h3>_AI_MATKEY_GLTF_MAPPINGNAME_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_GLTF_MAPPINGNAME_BASE</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_GLTF_MAPPINGNAME_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_GLTF_MAPPINGID_BASE">
<h3>_AI_MATKEY_GLTF_MAPPINGID_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_GLTF_MAPPINGID_BASE</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_GLTF_MAPPINGID_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE">
<h3>_AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE">
<h3>_AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_GLTF_SCALE_BASE">
<h3>_AI_MATKEY_GLTF_SCALE_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_GLTF_SCALE_BASE</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_GLTF_SCALE_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="_AI_MATKEY_GLTF_STRENGTH_BASE">
<h3>_AI_MATKEY_GLTF_STRENGTH_BASE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">_AI_MATKEY_GLTF_STRENGTH_BASE</span></div>
<div class="block">PBR Material keys</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp._AI_MATKEY_GLTF_STRENGTH_BASE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MAX_FACE_INDICES">
<h3>AI_MAX_FACE_INDICES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_MAX_FACE_INDICES</span></div>
<div class="block">Maximum number of indices per face (polygon).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MAX_FACE_INDICES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MAX_BONE_WEIGHTS">
<h3>AI_MAX_BONE_WEIGHTS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_MAX_BONE_WEIGHTS</span></div>
<div class="block">Maximum number of indices per face (polygon).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MAX_BONE_WEIGHTS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MAX_VERTICES">
<h3>AI_MAX_VERTICES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_MAX_VERTICES</span></div>
<div class="block">Maximum number of vertices per mesh.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MAX_VERTICES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MAX_FACES">
<h3>AI_MAX_FACES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_MAX_FACES</span></div>
<div class="block">Maximum number of faces per mesh.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MAX_FACES">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MAX_NUMBER_OF_COLOR_SETS">
<h3>AI_MAX_NUMBER_OF_COLOR_SETS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_MAX_NUMBER_OF_COLOR_SETS</span></div>
<div class="block">Supported number of vertex color sets per mesh.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MAX_NUMBER_OF_COLOR_SETS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_MAX_NUMBER_OF_TEXTURECOORDS">
<h3>AI_MAX_NUMBER_OF_TEXTURECOORDS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_MAX_NUMBER_OF_TEXTURECOORDS</span></div>
<div class="block">Supported number of texture coord sets (UV(W) channels) per mesh.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_MAX_NUMBER_OF_TEXTURECOORDS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPrimitiveType_POINT">
<h3>aiPrimitiveType_POINT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPrimitiveType_POINT</span></div>
<div class="block">Enumerates the types of geometric primitives supported by Assimp.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> - A point primitive. This is just a single vertex in the virtual world, <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains just one index for such a primitive.</li>
 <li><a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a> - A line primitive. This is a line defined through a start and an end position. <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains exactly two indices for such a primitive.</li>
 <li><a href="#aiPrimitiveType_TRIANGLE"><code>PrimitiveType_TRIANGLE</code></a> - A triangular primitive. A triangle consists of three indices.</li>
 <li><a href="#aiPrimitiveType_POLYGON"><code>PrimitiveType_POLYGON</code></a> - 
 A higher-level polygon with more than 3 edges. A triangle is a polygon, but polygon in this context means "all polygons that are not triangles".
 The "Triangulate"-Step is provided for your convenience, it splits all polygons in triangles (which are much easier to handle).
 </li>
 <li><a href="#aiPrimitiveType_NGONEncodingFlag"><code>PrimitiveType_NGONEncodingFlag</code></a> - 
 A flag to determine whether this triangles only mesh is NGON encoded.
 
 <p>NGON encoding is a special encoding that tells whether 2 or more consecutive triangles should be considered as a triangle fan. This is identified
 by looking at the first vertex index. 2 consecutive triangles with the same 1st vertex index are part of the same NGON.</p>
 
 <p>At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as triangles, as usual after a triangulation pass.</p>
 
 <p>To get an NGON encoded mesh, please use the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> post process.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPrimitiveType_POINT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPrimitiveType_LINE">
<h3>aiPrimitiveType_LINE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPrimitiveType_LINE</span></div>
<div class="block">Enumerates the types of geometric primitives supported by Assimp.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> - A point primitive. This is just a single vertex in the virtual world, <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains just one index for such a primitive.</li>
 <li><a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a> - A line primitive. This is a line defined through a start and an end position. <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains exactly two indices for such a primitive.</li>
 <li><a href="#aiPrimitiveType_TRIANGLE"><code>PrimitiveType_TRIANGLE</code></a> - A triangular primitive. A triangle consists of three indices.</li>
 <li><a href="#aiPrimitiveType_POLYGON"><code>PrimitiveType_POLYGON</code></a> - 
 A higher-level polygon with more than 3 edges. A triangle is a polygon, but polygon in this context means "all polygons that are not triangles".
 The "Triangulate"-Step is provided for your convenience, it splits all polygons in triangles (which are much easier to handle).
 </li>
 <li><a href="#aiPrimitiveType_NGONEncodingFlag"><code>PrimitiveType_NGONEncodingFlag</code></a> - 
 A flag to determine whether this triangles only mesh is NGON encoded.
 
 <p>NGON encoding is a special encoding that tells whether 2 or more consecutive triangles should be considered as a triangle fan. This is identified
 by looking at the first vertex index. 2 consecutive triangles with the same 1st vertex index are part of the same NGON.</p>
 
 <p>At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as triangles, as usual after a triangulation pass.</p>
 
 <p>To get an NGON encoded mesh, please use the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> post process.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPrimitiveType_LINE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPrimitiveType_TRIANGLE">
<h3>aiPrimitiveType_TRIANGLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPrimitiveType_TRIANGLE</span></div>
<div class="block">Enumerates the types of geometric primitives supported by Assimp.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> - A point primitive. This is just a single vertex in the virtual world, <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains just one index for such a primitive.</li>
 <li><a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a> - A line primitive. This is a line defined through a start and an end position. <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains exactly two indices for such a primitive.</li>
 <li><a href="#aiPrimitiveType_TRIANGLE"><code>PrimitiveType_TRIANGLE</code></a> - A triangular primitive. A triangle consists of three indices.</li>
 <li><a href="#aiPrimitiveType_POLYGON"><code>PrimitiveType_POLYGON</code></a> - 
 A higher-level polygon with more than 3 edges. A triangle is a polygon, but polygon in this context means "all polygons that are not triangles".
 The "Triangulate"-Step is provided for your convenience, it splits all polygons in triangles (which are much easier to handle).
 </li>
 <li><a href="#aiPrimitiveType_NGONEncodingFlag"><code>PrimitiveType_NGONEncodingFlag</code></a> - 
 A flag to determine whether this triangles only mesh is NGON encoded.
 
 <p>NGON encoding is a special encoding that tells whether 2 or more consecutive triangles should be considered as a triangle fan. This is identified
 by looking at the first vertex index. 2 consecutive triangles with the same 1st vertex index are part of the same NGON.</p>
 
 <p>At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as triangles, as usual after a triangulation pass.</p>
 
 <p>To get an NGON encoded mesh, please use the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> post process.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPrimitiveType_TRIANGLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPrimitiveType_POLYGON">
<h3>aiPrimitiveType_POLYGON</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPrimitiveType_POLYGON</span></div>
<div class="block">Enumerates the types of geometric primitives supported by Assimp.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> - A point primitive. This is just a single vertex in the virtual world, <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains just one index for such a primitive.</li>
 <li><a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a> - A line primitive. This is a line defined through a start and an end position. <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains exactly two indices for such a primitive.</li>
 <li><a href="#aiPrimitiveType_TRIANGLE"><code>PrimitiveType_TRIANGLE</code></a> - A triangular primitive. A triangle consists of three indices.</li>
 <li><a href="#aiPrimitiveType_POLYGON"><code>PrimitiveType_POLYGON</code></a> - 
 A higher-level polygon with more than 3 edges. A triangle is a polygon, but polygon in this context means "all polygons that are not triangles".
 The "Triangulate"-Step is provided for your convenience, it splits all polygons in triangles (which are much easier to handle).
 </li>
 <li><a href="#aiPrimitiveType_NGONEncodingFlag"><code>PrimitiveType_NGONEncodingFlag</code></a> - 
 A flag to determine whether this triangles only mesh is NGON encoded.
 
 <p>NGON encoding is a special encoding that tells whether 2 or more consecutive triangles should be considered as a triangle fan. This is identified
 by looking at the first vertex index. 2 consecutive triangles with the same 1st vertex index are part of the same NGON.</p>
 
 <p>At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as triangles, as usual after a triangulation pass.</p>
 
 <p>To get an NGON encoded mesh, please use the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> post process.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPrimitiveType_POLYGON">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiPrimitiveType_NGONEncodingFlag">
<h3>aiPrimitiveType_NGONEncodingFlag</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiPrimitiveType_NGONEncodingFlag</span></div>
<div class="block">Enumerates the types of geometric primitives supported by Assimp.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> - A point primitive. This is just a single vertex in the virtual world, <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains just one index for such a primitive.</li>
 <li><a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a> - A line primitive. This is a line defined through a start and an end position. <a href="AIFace.html" title="class in org.lwjgl.assimp"><code>AIFace</code></a> contains exactly two indices for such a primitive.</li>
 <li><a href="#aiPrimitiveType_TRIANGLE"><code>PrimitiveType_TRIANGLE</code></a> - A triangular primitive. A triangle consists of three indices.</li>
 <li><a href="#aiPrimitiveType_POLYGON"><code>PrimitiveType_POLYGON</code></a> - 
 A higher-level polygon with more than 3 edges. A triangle is a polygon, but polygon in this context means "all polygons that are not triangles".
 The "Triangulate"-Step is provided for your convenience, it splits all polygons in triangles (which are much easier to handle).
 </li>
 <li><a href="#aiPrimitiveType_NGONEncodingFlag"><code>PrimitiveType_NGONEncodingFlag</code></a> - 
 A flag to determine whether this triangles only mesh is NGON encoded.
 
 <p>NGON encoding is a special encoding that tells whether 2 or more consecutive triangles should be considered as a triangle fan. This is identified
 by looking at the first vertex index. 2 consecutive triangles with the same 1st vertex index are part of the same NGON.</p>
 
 <p>At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as triangles, as usual after a triangulation pass.</p>
 
 <p>To get an NGON encoded mesh, please use the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> post process.</p>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiPrimitiveType_NGONEncodingFlag">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiMorphingMethod_VERTEX_BLEND">
<h3>aiMorphingMethod_VERTEX_BLEND</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiMorphingMethod_VERTEX_BLEND</span></div>
<div class="block">Enumerates the methods of mesh morphing supported by Assimp. (<code>enum aiMorphingMethod</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiMorphingMethod_VERTEX_BLEND"><code>MorphingMethod_VERTEX_BLEND</code></a> - Interpolation between morph targets.</li>
 <li><a href="#aiMorphingMethod_MORPH_NORMALIZED"><code>MorphingMethod_MORPH_NORMALIZED</code></a> - Normalized morphing between morph targets.</li>
 <li><a href="#aiMorphingMethod_MORPH_RELATIVE"><code>MorphingMethod_MORPH_RELATIVE</code></a> - Relative morphing between morph targets.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiMorphingMethod_VERTEX_BLEND">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiMorphingMethod_MORPH_NORMALIZED">
<h3>aiMorphingMethod_MORPH_NORMALIZED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiMorphingMethod_MORPH_NORMALIZED</span></div>
<div class="block">Enumerates the methods of mesh morphing supported by Assimp. (<code>enum aiMorphingMethod</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiMorphingMethod_VERTEX_BLEND"><code>MorphingMethod_VERTEX_BLEND</code></a> - Interpolation between morph targets.</li>
 <li><a href="#aiMorphingMethod_MORPH_NORMALIZED"><code>MorphingMethod_MORPH_NORMALIZED</code></a> - Normalized morphing between morph targets.</li>
 <li><a href="#aiMorphingMethod_MORPH_RELATIVE"><code>MorphingMethod_MORPH_RELATIVE</code></a> - Relative morphing between morph targets.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiMorphingMethod_MORPH_NORMALIZED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiMorphingMethod_MORPH_RELATIVE">
<h3>aiMorphingMethod_MORPH_RELATIVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiMorphingMethod_MORPH_RELATIVE</span></div>
<div class="block">Enumerates the methods of mesh morphing supported by Assimp. (<code>enum aiMorphingMethod</code>)
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiMorphingMethod_VERTEX_BLEND"><code>MorphingMethod_VERTEX_BLEND</code></a> - Interpolation between morph targets.</li>
 <li><a href="#aiMorphingMethod_MORPH_NORMALIZED"><code>MorphingMethod_MORPH_NORMALIZED</code></a> - Normalized morphing between morph targets.</li>
 <li><a href="#aiMorphingMethod_MORPH_RELATIVE"><code>MorphingMethod_MORPH_RELATIVE</code></a> - Relative morphing between morph targets.</li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiMorphingMethod_MORPH_RELATIVE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_BOOL">
<h3>AI_BOOL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_BOOL</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_BOOL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_INT32">
<h3>AI_INT32</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_INT32</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_INT32">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_UINT64">
<h3>AI_UINT64</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_UINT64</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_UINT64">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_FLOAT">
<h3>AI_FLOAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_FLOAT</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_FLOAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_DOUBLE">
<h3>AI_DOUBLE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_DOUBLE</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_DOUBLE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_AISTRING">
<h3>AI_AISTRING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_AISTRING</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_AISTRING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_AIVECTOR3D">
<h3>AI_AIVECTOR3D</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_AIVECTOR3D</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_AIVECTOR3D">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_AIMETADATA">
<h3>AI_AIMETADATA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_AIMETADATA</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_AIMETADATA">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_META_MAX">
<h3>AI_META_MAX</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_META_MAX</span></div>
<div class="block">Enum used to distinguish data types. <code>aiMetadataType</code>
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#AI_BOOL"><code>AI_BOOL</code></a></li>
 <li><a href="#AI_INT32"><code>AI_INT32</code></a></li>
 <li><a href="#AI_UINT64"><code>AI_UINT64</code></a></li>
 <li><a href="#AI_FLOAT"><code>AI_FLOAT</code></a></li>
 <li><a href="#AI_DOUBLE"><code>AI_DOUBLE</code></a></li>
 <li><a href="#AI_AISTRING"><code>AI_AISTRING</code></a></li>
 <li><a href="#AI_AIVECTOR3D"><code>AI_AIVECTOR3D</code></a></li>
 <li><a href="#AI_AIMETADATA"><code>AI_AIMETADATA</code></a></li>
 <li><a href="#AI_META_MAX"><code>AI_META_MAX</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_META_MAX">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_METADATA_SOURCE_FORMAT">
<h3>AI_METADATA_SOURCE_FORMAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_METADATA_SOURCE_FORMAT</span></div>
<div class="block">Scene metadata holding the name of the importer which loaded the source asset.
 
 <p>This is always present if the scene was created from an imported asset.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_METADATA_SOURCE_FORMAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_METADATA_SOURCE_FORMAT_VERSION">
<h3>AI_METADATA_SOURCE_FORMAT_VERSION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_METADATA_SOURCE_FORMAT_VERSION</span></div>
<div class="block">Scene metadata holding the version of the source asset as a string, if available.
 
 <p>Not all formats add this metadata.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_METADATA_SOURCE_FORMAT_VERSION">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_METADATA_SOURCE_GENERATOR">
<h3>AI_METADATA_SOURCE_GENERATOR</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_METADATA_SOURCE_GENERATOR</span></div>
<div class="block">Scene metadata holding the name of the software which generated the source asset, if available.
 
 <p>Not all formats add this metadata.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_METADATA_SOURCE_GENERATOR">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_METADATA_SOURCE_COPYRIGHT">
<h3>AI_METADATA_SOURCE_COPYRIGHT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">AI_METADATA_SOURCE_COPYRIGHT</span></div>
<div class="block">Scene metadata holding the source asset copyright statement, if available.
 
 <p>Not all formats add this metadata.</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_METADATA_SOURCE_COPYRIGHT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_CalcTangentSpace">
<h3>aiProcess_CalcTangentSpace</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_CalcTangentSpace</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_CalcTangentSpace">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_JoinIdenticalVertices">
<h3>aiProcess_JoinIdenticalVertices</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_JoinIdenticalVertices</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_JoinIdenticalVertices">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_MakeLeftHanded">
<h3>aiProcess_MakeLeftHanded</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_MakeLeftHanded</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_MakeLeftHanded">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_Triangulate">
<h3>aiProcess_Triangulate</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_Triangulate</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_Triangulate">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_RemoveComponent">
<h3>aiProcess_RemoveComponent</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_RemoveComponent</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_RemoveComponent">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_GenNormals">
<h3>aiProcess_GenNormals</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_GenNormals</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_GenNormals">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_GenSmoothNormals">
<h3>aiProcess_GenSmoothNormals</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_GenSmoothNormals</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_GenSmoothNormals">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_SplitLargeMeshes">
<h3>aiProcess_SplitLargeMeshes</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_SplitLargeMeshes</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_SplitLargeMeshes">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_PreTransformVertices">
<h3>aiProcess_PreTransformVertices</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_PreTransformVertices</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_PreTransformVertices">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_LimitBoneWeights">
<h3>aiProcess_LimitBoneWeights</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_LimitBoneWeights</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_LimitBoneWeights">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_ValidateDataStructure">
<h3>aiProcess_ValidateDataStructure</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_ValidateDataStructure</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_ValidateDataStructure">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_ImproveCacheLocality">
<h3>aiProcess_ImproveCacheLocality</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_ImproveCacheLocality</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_ImproveCacheLocality">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_RemoveRedundantMaterials">
<h3>aiProcess_RemoveRedundantMaterials</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_RemoveRedundantMaterials</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_RemoveRedundantMaterials">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_FixInfacingNormals">
<h3>aiProcess_FixInfacingNormals</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_FixInfacingNormals</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_FixInfacingNormals">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_PopulateArmatureData">
<h3>aiProcess_PopulateArmatureData</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_PopulateArmatureData</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_PopulateArmatureData">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_SortByPType">
<h3>aiProcess_SortByPType</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_SortByPType</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_SortByPType">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_FindDegenerates">
<h3>aiProcess_FindDegenerates</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_FindDegenerates</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_FindDegenerates">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_FindInvalidData">
<h3>aiProcess_FindInvalidData</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_FindInvalidData</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_FindInvalidData">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_GenUVCoords">
<h3>aiProcess_GenUVCoords</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_GenUVCoords</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_GenUVCoords">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_TransformUVCoords">
<h3>aiProcess_TransformUVCoords</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_TransformUVCoords</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_TransformUVCoords">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_FindInstances">
<h3>aiProcess_FindInstances</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_FindInstances</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_FindInstances">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_OptimizeMeshes">
<h3>aiProcess_OptimizeMeshes</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_OptimizeMeshes</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_OptimizeMeshes">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_OptimizeGraph">
<h3>aiProcess_OptimizeGraph</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_OptimizeGraph</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_OptimizeGraph">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_FlipUVs">
<h3>aiProcess_FlipUVs</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_FlipUVs</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_FlipUVs">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_FlipWindingOrder">
<h3>aiProcess_FlipWindingOrder</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_FlipWindingOrder</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_FlipWindingOrder">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_SplitByBoneCount">
<h3>aiProcess_SplitByBoneCount</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_SplitByBoneCount</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_SplitByBoneCount">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_Debone">
<h3>aiProcess_Debone</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_Debone</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_Debone">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_GlobalScale">
<h3>aiProcess_GlobalScale</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_GlobalScale</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_GlobalScale">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_EmbedTextures">
<h3>aiProcess_EmbedTextures</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_EmbedTextures</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_EmbedTextures">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_ForceGenNormals">
<h3>aiProcess_ForceGenNormals</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_ForceGenNormals</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_ForceGenNormals">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_DropNormals">
<h3>aiProcess_DropNormals</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_DropNormals</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_DropNormals">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_GenBoundingBoxes">
<h3>aiProcess_GenBoundingBoxes</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_GenBoundingBoxes</span></div>
<div class="block">Defines the flags for all possible post processing steps.
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a> - 
 Calculates the tangents and bitangents for the imported meshes.
 
 <p>Does nothing if a mesh does not have normals. You might want this post processing step to be executed if you plan to use tangent space calculations
 such as normal mapping  applied to the meshes. There's an importer property, <a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a>, which allows you to
 specify a maximum smoothing angle for the algorithm. However, usually you'll want to leave it at the default value.</p>
 </li>
 <li><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> - 
 Identifies and joins identical vertex data sets within all imported meshes.
 
 <p>After this step is run, each mesh contains unique vertices, so a vertex may be used by multiple faces. You usually want to use this post processing
 step. If your application deals with indexed geometry, this step is compulsory or you'll just waste rendering time. <b>If this flag is not
 specified</b>, no vertices are referenced by more than one face and <b>no index buffer is required</b> for rendering.</p>
 </li>
 <li><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> - 
 Converts all the imported data to a left-handed coordinate space.
 
 <p>By default the data is returned in a right-handed coordinate space (which OpenGL prefers). In this space, +X points to the right, +Z points towards
 the viewer, and +Y points upwards. In the DirectX coordinate space +X points to the right, +Y points upwards, and +Z points away from the viewer.</p>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> - 
 Triangulates all faces of all meshes.
 
 <p>By default the imported mesh data might contain faces with more than 3 indices. For rendering you'll usually want all faces to be triangles. This
 post processing step splits up faces with more than 3 indices into triangles. Line and point primitives are *not* modified! If you want 'triangles
 only' with no other kinds of primitives, try the following solution:</p>
 
 <ul>
 <li>Specify both <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></li>
 <li>Ignore all point and line meshes when you process assimp's output</li>
 </ul>
 </li>
 <li><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a> - 
 Removes some parts of the data structure (animations, materials, light sources, cameras, textures, vertex components).
 
 <p>The  components to be removed are specified in a separate importer property, <a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a>. This is quite useful if you don't need
 all parts of the output structure. Vertex colors are rarely used today for example... Calling this step to remove unneeded data from the pipeline
 as early as possible results in increased performance and a more optimized output data structure. This step is also useful if you want to force
 Assimp to recompute normals or tangents. The corresponding steps don't recompute them if they're already there (loaded from the source asset). By
 using this step you can make sure they are NOT there.</p>
 
 <p>This flag is a poor one, mainly because its purpose is usually misunderstood. Consider the following case: a 3D model has been exported from a CAD
 app, and it has per-face vertex colors. Vertex positions can't be shared, thus the <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> step fails to optimize the data
 because of these nasty little vertex colors. Most apps don't even process them, so it's all for nothing. By using this step, unneeded components
 are excluded as early as possible thus opening more room for internal optimizations.</p>
 </li>
 <li><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a> - 
 Generates normals for all faces of all meshes.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there. Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the
 library to duplicate vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is *senseless* then.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> - 
 Generates smooth normals for all vertices in the mesh.
 
 <p>This is ignored if normals are already there at the time this flag is evaluated. Model importers try to load them from the source file, so they're
 usually already there.</p>
 
 <p>This flag may not be specified together with <a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a>. There's a importer property, <a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a> which
 allows you to specify an angle maximum for the normal smoothing algorithm. Normals exceeding this limit are not smoothed, resulting in a 'hard'
 seam between two faces. Using a decent angle here (e.g. 80 degrees) results in very good visual appearance.</p>
 </li>
 <li><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> - 
 Splits large meshes into smaller sub-meshes.
 
 <p>This is quite useful for real-time rendering, where the number of triangles which can be maximally processed in a single draw-call is limited by
 the video driver/hardware. The maximum vertex buffer is usually limited too. Both requirements can be met with this step: you may specify both a
 triangle and vertex limit for a single mesh.</p>
 
 <p>The split limits can (and should!) be set through the <a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a> and <a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a> importer
 properties. The default values are <a href="#AI_SLM_DEFAULT_MAX_VERTICES"><code>AI_SLM_DEFAULT_MAX_VERTICES</code></a> and <a href="#AI_SLM_DEFAULT_MAX_TRIANGLES"><code>AI_SLM_DEFAULT_MAX_TRIANGLES</code></a>.</p>
 
 <p>Note that splitting is generally a time-consuming task, but only if there's something to split. The use of this step is recommended for most users.</p>
 </li>
 <li><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> - 
 Removes the node graph and pre-transforms all vertices with the local transformation matrices of their nodes.
 
 <p>If the resulting scene can be reduced to a single mesh, with a single material, no lights, and no cameras, then the output scene will contain only
 a root node (with no children) that references the single mesh. Otherwise, the output scene will be reduced to a root node with a single level of
 child nodes, each one referencing one mesh, and each mesh referencing one material.</p>
 
 <p>In either case, for rendering, you can simply render all meshes in order - you don't need to pay attention to local transformations and the node
 hierarchy. Animations are removed during this step.</p>
 
 <p>This step is intended for applications without a scenegraph. The step CAN cause some problems: if e.g. a mesh of the asset contains normals and
 another, using the same material index, does not, they will be brought together, but the first meshes's part of the normal list is zeroed. However,
 these artifacts are rare.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>The <a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a> configuration property can be set to normalize the scene's spatial dimension to the <code>-1...1</code>
 range.</p>
 </div>
 </li>
 <li><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a> - 
 Limits the number of bones simultaneously affecting a single vertex to a maximum value.
 
 <p>If any vertex is affected by more than the maximum number of bones, the least important vertex weights are removed and the remaining vertex weights
 are renormalized so that the weights still sum up to 1. The default bone weight limit is 4 (defined as <a href="#AI_LBW_MAX_WEIGHTS"><code>AI_LBW_MAX_WEIGHTS</code></a> in config.h), but
 you can use the <a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a> importer property to supply your own limit to the post processing step.</p>
 
 <p>If you intend to perform the skinning in hardware, this post processing step might be of interest to you.</p>
 </li>
 <li><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> - 
 Validates the imported scene data structure. This makes sure that all indices are valid, all animations and bones are linked correctly, all
 material references are correct .. etc.
 
 <p>It is recommended that you capture Assimp's log output if you use this flag, so you can easily find out what's wrong if a file fails the
 validation. The validator is quite strict and will find *all* inconsistencies in the data structure... It is recommended that plugin developers use
 it to debug their loaders. There are two types of validation failures:</p>
 
 <ul>
 <li>Error: There's something wrong with the imported data. Further postprocessing is not possible and the data is not usable at all. The import
 fails. <a href="#aiGetErrorString()"><code>GetErrorString</code></a> carries the error message around.</li>
 <li>Warning: There are some minor issues (e.g. 1000000 animation keyframes with the same time), but further postprocessing and use of the data
 structure is still safe. Warning details are written to the log file, <a href="#AI_SCENE_FLAGS_VALIDATION_WARNING"><code>AI_SCENE_FLAGS_VALIDATION_WARNING</code></a> is set in
 <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a><code>::mFlags</code>.</li>
 </ul>
 
 <p>This post-processing step is not time-consuming. Its use is not compulsory, but recommended.</p>
 </li>
 <li><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a> - 
 Reorders triangles for better vertex cache locality.
 
 <p>The step tries to improve the ACMR (average post-transform vertex cache miss ratio) for all meshes. The implementation runs in O(n) and is roughly
 based on the 'tipsify' algorithm (see <a target="_blank" href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">this paper</a>).</p>
 
 <p>If you intend to render huge models in hardware, this step might be of interest to you. The <a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a> importer property
 can be used to fine-tune the cache optimization.</p>
 </li>
 <li><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a> - 
 Searches for redundant/unreferenced materials and removes them.
 
 <p>This is especially useful in combination with the <a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a> and <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> flags. Both join small meshes with
 equal characteristics, but they can't do their work if two meshes have different materials. Because several material settings are lost during
 Assimp's import filters, (and because many exporters don't check for redundant materials), huge models often have materials which are are defined
 several times with exactly the same settings.</p>
 
 <p>Several material settings not contributing to the final appearance of a surface are ignored in all comparisons (e.g. the material name). So, if
 you're passing additional information through the content pipeline (probably using *magic* material names), don't specify this flag. Alternatively
 take a look at the <a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a> importer property.</p>
 </li>
 <li><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a> - 
 This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
 
 <p>The algorithm is simple but effective: the bounding box of all vertices + their normals is compared against the volume of the bounding box of all
 vertices without their normals. This works well for most objects, problems might occur with planar surfaces. However, the step tries to filter such
 cases. The step inverts all in-facing normals. Generally it is recommended to enable this step, although the result is not always correct.</p>
 </li>
 <li><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a> - 
 This step generically populates <code>aiBone-&gt;mArmature</code> and <code>aiBone-&gt;mNode</code>.
 
 <p>The point of these is it saves you later having to calculate these elements. This is useful when handling rest information or skin information. If
 you have multiple armatures on your models we strongly recommend enabling this. Instead of writing your own multi-root, multi-armature lookups we
 have done the hard work for you.</p>
 </li>
 <li><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> - 
 This step splits meshes with more than one primitive type in homogeneous sub-meshes.
 
 <p>The step is executed after the triangulation step. After the step returns, just one bit is set in <a href="AIMesh.html" title="class in org.lwjgl.assimp"><code>AIMesh</code></a><code>::mPrimitiveTypes</code>. This is
 especially useful for real-time rendering where point and line primitives are often ignored or rendered separately. You can use the
 <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to specify which primitive types you need. This can be used to easily exclude lines and points,
 which are rarely used, from the import.</p>
 </li>
 <li><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> - 
 This step searches all meshes for degenerate primitives and converts them to proper lines or points.
 
 <p>A face is 'degenerate' if one or more of its points are identical. To have the degenerate stuff not only detected and collapsed but removed, try
 one of the following procedures:</p>
 
 <ol>
 <li>(if you support lines and points for rendering but don't want the degenerates)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Set the <a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a> importer property to 1. This will cause the step to remove degenerate triangles from the import as
 soon as they're detected. They won't pass any further pipeline steps.</li>
 </ul></li>
 <li>(if you don't support lines and points at all)
 
 <ul>
 <li>Specify the <a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a> flag.</li>
 <li>Specify the <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> flag. This moves line and point primitives to separate meshes.</li>
 <li>Set the <a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a> importer property to <code><a href="#aiPrimitiveType_POINT"><code>PrimitiveType_POINT</code></a> | <a href="#aiPrimitiveType_LINE"><code>PrimitiveType_LINE</code></a></code> to cause
 <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a> to reject point and line meshes from the scene.</li>
 </ul></li>
 </ol>
 
 <p>This step also removes very small triangles with a surface area smaller than 10^-6. If you rely on having these small triangles, or notice holes in
 your model, set the property <a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a> to <code>false</code>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Degenerate polygons are not necessarily evil and that's why they're not removed by default. There are several file formats which don't support
 lines or points, and some exporters bypass the format specification and write them as degenerate triangles instead.</p></div>
 </li>
 <li><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a> - 
 This step searches all meshes for invalid data, such as zeroed normal vectors or invalid UV coords and removes/fixes them. This is intended to get
 rid of some common exporter errors.
 
 <p>This is especially useful for normals. If they are invalid, and the step recognizes this, they will be removed and can later be recomputed, i.e. by
 the <a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a> flag.</p>
 
 <p>The step will also remove meshes that are infinitely small and reduce animation tracks consisting of hundreds if redundant keys to a single key.
 The <a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a> config property decides the accuracy of the check for duplicate animation tracks.</p>
 </li>
 <li><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a> - 
 This step converts non-UV mappings (such as spherical or cylindrical mapping) to proper texture coordinate channels.
 
 <p>Most applications will support UV mapping only, so you will probably want to specify this step in every case. Note that Assimp is not always able
 to match the original mapping implementation of the 3D app which produced a model perfectly. It's always better to let the modelling app compute
 the UV channels - 3ds max, Maya, Blender, LightWave, and Modo do this for example.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>If this step is not requested, you'll need to process the <a href="#_AI_MATKEY_MAPPING_BASE"><code>_AI_MATKEY_MAPPING_BASE</code></a> material property in order to display all assets
 properly.</p>
 </div>
 </li>
 <li><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> - 
 This step applies per-texture UV transformations and bakes them into stand-alone vtexture coordinate channels.
 
 <p>UV transformations are specified per-texture - see the <a href="#_AI_MATKEY_UVTRANSFORM_BASE"><code>_AI_MATKEY_UVTRANSFORM_BASE</code></a> material key for more information. This step processes
 all textures with transformed input UV coordinates and generates a new (pre-transformed) UV channel which replaces the old channel. Most
 applications won't support UV transformations, so you will probably want to specify this step.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>UV transformations are usually implemented in real-time apps by transforming texture coordinates at vertex shader stage with a 3x3 (homogeneous)
 transformation matrix.</p></div>
 </li>
 <li><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a> - 
 This step searches for duplicate meshes and replaces them with references to the first mesh.
 
 <p>This step takes a while, so don't use it if speed is a concern. Its main purpose is to workaround the fact that many export file formats don't
 support instanced meshes, so exporters need to duplicate meshes. This step removes the duplicates again. Please note that Assimp does not currently
 support per-node material assignment to meshes, which means that identical meshes with different materials are currently *not* joined, although
 this is planned for future versions.</p>
 </li>
 <li><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> - 
 A post-processing step to reduce the number of meshes.
 
 <p>This will, in fact, reduce the number of draw calls.</p>
 
 <p>This is a very effective optimization and is recommended to be used together with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a>, if possible. The flag is fully compatible
 with both <a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a> and <a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a>.</p>
 </li>
 <li><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> - 
 A post-processing step to optimize the scene hierarchy.
 
 <p>Nodes without animations, bones, lights or cameras assigned are collapsed and joined.</p>
 
 <p>Node names can be lost during this step. If you use special 'tag nodes' to pass additional information through your content pipeline, use the
 <a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a> importer property to specify a list of node names you want to be kept. Nodes matching one of the names in this
 list won't be touched or modified.</p>
 
 <p>Use this flag with caution. Most simple files will be collapsed to a single node, so complex hierarchies are usually completely lost. This is not
 useful for editor environments, but probably a very effective optimization if you just want to get the model data, convert it to your own format,
 and render it as fast as possible.</p>
 
 <p>This flag is designed to be used with <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a> for best results.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>'Crappy' scenes with thousands of extremely small meshes packed in deeply nested nodes exist for almost all file formats. <a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a>
 in combination with <a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a> usually fixes them all and makes them renderable.</p>
 </div>
 </li>
 <li><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> - 
 This step flips all UV coordinates along the y-axis and adjusts material settings and bitangents accordingly.
 
 <p><b>Output UV coordinate system:</b></p>
 
 <pre><code>
 0y|0y ---------- 1x|0y
   |                |
   |                |
   |                |
 0x|1y ---------- 1x|1y</code></pre>
 
 <p>You'll probably want to consider this flag if you use Direct3D for rendering. The <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> flag supersedes this setting and
 bundles all conversions typically required for D3D-based applications.</p>
 </li>
 <li><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> - 
 This step adjusts the output face winding order to be CW.
 
 <p>The default face winding order is counter clockwise (CCW).</p>
 
 <p><b>Output face order:</b></p>
 
 <pre><code>
     x2
 
                   x0
 x1</code></pre>
 </li>
 <li><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a> - 
 This step splits meshes with many bones into sub-meshes so that each sub-mesh has fewer or as many bones as a given limit.
 </li>
 <li><a href="#aiProcess_Debone"><code>Process_Debone</code></a> - 
 This step removes bones losslessly or according to some threshold.
 
 <p>In some cases (i.e. formats that require it) exporters are forced to assign dummy bone weights to otherwise static meshes assigned to animated
 meshes. Full, weight-based skinning is expensive while animating nodes is extremely cheap, so this step is offered to clean up the data in that
 regard.</p>
 
 <p>Use <a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a> to control this. Use <a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a> if you want bones removed if and only if all bones
 within the scene qualify for removal.</p>
 </li>
 <li><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a> - 
 This step will perform a global scale of the model.
 
 <p>Some importers are providing a mechanism to define a scaling unit for the model. This post processing step can be used to do so. You need to get
 the global scaling from your importer settings like in FBX. Use the flag <code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code> from the global property table
 to configure this.</p>
 
 <p>Use <a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a> to setup the global scaling factor.</p>
 </li>
 <li><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a> - 
 A postprocessing step to embed of textures.
 
 <p>This will remove external data dependencies for textures. If a texture's file does not exist at the specified path (due, for instance, to an
 absolute path generated on another system), it will check if a file with the same name exists at the root folder of the imported model. And if so,
 it uses that.</p>
 </li>
 <li><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></li>
 <li><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a> - 
 Drops normals for all faces of all meshes.
 
 <p>This is ignored if no normals are present.</p>
 
 <p>Face normals are shared between all points of a single face, so a single point can have multiple normals, which forces the library to duplicate
 vertices in some cases. <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a> is <em>senseless</em> then. This process gives sense back to <a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a>.</p>
 </li>
 <li><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_GenBoundingBoxes">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcess_ConvertToLeftHanded">
<h3>aiProcess_ConvertToLeftHanded</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcess_ConvertToLeftHanded</span></div>
<div class="block">Process Presets
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> - 
 Shortcut flag for Direct3D-based applications.
 
 <p>Supersedes the <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> and <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags. The output data matches Direct3D's conventions:
 left-handed geometry, upper-left origin for UV coordinates and finally clockwise face order, suitable for CCW culling.</p>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Applications would want to use this preset to load models on end-user PCs, maybe for direct use in game.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Unlike <a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a>, this configuration performs some extra optimizations to improve rendering speed and to minimize memory
 usage. It could be a good choice for a level editor environment where import speed is not so important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>This preset enables almost every optimization step to achieve perfectly optimized data. It's your choice for level editor environments where import
 speed is not important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application, apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcess_ConvertToLeftHanded">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcessPreset_TargetRealtime_Fast">
<h3>aiProcessPreset_TargetRealtime_Fast</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcessPreset_TargetRealtime_Fast</span></div>
<div class="block">Process Presets
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> - 
 Shortcut flag for Direct3D-based applications.
 
 <p>Supersedes the <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> and <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags. The output data matches Direct3D's conventions:
 left-handed geometry, upper-left origin for UV coordinates and finally clockwise face order, suitable for CCW culling.</p>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Applications would want to use this preset to load models on end-user PCs, maybe for direct use in game.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Unlike <a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a>, this configuration performs some extra optimizations to improve rendering speed and to minimize memory
 usage. It could be a good choice for a level editor environment where import speed is not so important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>This preset enables almost every optimization step to achieve perfectly optimized data. It's your choice for level editor environments where import
 speed is not important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application, apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcessPreset_TargetRealtime_Fast">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcessPreset_TargetRealtime_Quality">
<h3>aiProcessPreset_TargetRealtime_Quality</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcessPreset_TargetRealtime_Quality</span></div>
<div class="block">Process Presets
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> - 
 Shortcut flag for Direct3D-based applications.
 
 <p>Supersedes the <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> and <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags. The output data matches Direct3D's conventions:
 left-handed geometry, upper-left origin for UV coordinates and finally clockwise face order, suitable for CCW culling.</p>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Applications would want to use this preset to load models on end-user PCs, maybe for direct use in game.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Unlike <a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a>, this configuration performs some extra optimizations to improve rendering speed and to minimize memory
 usage. It could be a good choice for a level editor environment where import speed is not so important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>This preset enables almost every optimization step to achieve perfectly optimized data. It's your choice for level editor environments where import
 speed is not important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application, apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcessPreset_TargetRealtime_Quality">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiProcessPreset_TargetRealtime_MaxQuality">
<h3>aiProcessPreset_TargetRealtime_MaxQuality</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiProcessPreset_TargetRealtime_MaxQuality</span></div>
<div class="block">Process Presets
 
 <h5>Enum values:</h5>
 
 <ul>
 <li><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> - 
 Shortcut flag for Direct3D-based applications.
 
 <p>Supersedes the <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a> and <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags. The output data matches Direct3D's conventions:
 left-handed geometry, upper-left origin for UV coordinates and finally clockwise face order, suitable for CCW culling.</p>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Applications would want to use this preset to load models on end-user PCs, maybe for direct use in game.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>Unlike <a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a>, this configuration performs some extra optimizations to improve rendering speed and to minimize memory
 usage. It could be a good choice for a level editor environment where import speed is not so important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 <li><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a> - 
 Default postprocess configuration optimizing the data for real-time rendering.
 
 <p>This preset enables almost every optimization step to achieve perfectly optimized data. It's your choice for level editor environments where import
 speed is not important.</p>
 
 <p>If you're using DirectX, don't forget to combine this value with the <a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a> step. If you don't support UV transformations in
 your application, apply the <a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a> step, too.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Please take the time to read the docs for the steps enabled by this preset. Some of them offer further configurable properties, while some of them
 might not be of use for you so it might be better to not specify them.</p></div>
 </li>
 </ul></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.aiProcessPreset_TargetRealtime_MaxQuality">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SCENE_FLAGS_INCOMPLETE">
<h3>AI_SCENE_FLAGS_INCOMPLETE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SCENE_FLAGS_INCOMPLETE</span></div>
<div class="block">Specifies that the scene data structure that was imported is not complete.
 This flag bypasses some internal validations and allows the import
 of animation skeletons, material libraries or camera animation paths
 using Assimp. Most applications won't support such data.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SCENE_FLAGS_INCOMPLETE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SCENE_FLAGS_VALIDATED">
<h3>AI_SCENE_FLAGS_VALIDATED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SCENE_FLAGS_VALIDATED</span></div>
<div class="block">This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
 if the validation is successful. In a validated scene you can be sure that
 any cross references in the data structure (e.g. vertex indices) are valid.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SCENE_FLAGS_VALIDATED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SCENE_FLAGS_VALIDATION_WARNING">
<h3>AI_SCENE_FLAGS_VALIDATION_WARNING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SCENE_FLAGS_VALIDATION_WARNING</span></div>
<div class="block">This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
 if the validation is successful but some issues have been found.
 This can for example mean that a texture that does not exist is referenced
 by a material or that the bone weights for a vertex don't sum to 1.0 ... .
 In most cases you should still be able to use the import. This flag could
 be useful for applications which don't capture Assimp's log output.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SCENE_FLAGS_VALIDATION_WARNING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SCENE_FLAGS_NON_VERBOSE_FORMAT">
<h3>AI_SCENE_FLAGS_NON_VERBOSE_FORMAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SCENE_FLAGS_NON_VERBOSE_FORMAT</span></div>
<div class="block">This flag is currently only set by the aiProcess_JoinIdenticalVertices step.
 It indicates that the vertices of the output meshes aren't in the internal
 verbose format anymore. In the verbose format all vertices are unique,
 no vertex is ever referenced by more than one face.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SCENE_FLAGS_NON_VERBOSE_FORMAT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_SCENE_FLAGS_TERRAIN">
<h3>AI_SCENE_FLAGS_TERRAIN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">AI_SCENE_FLAGS_TERRAIN</span></div>
<div class="block">Denotes pure height-map terrain data. Pure terrains usually consist of quads,
 sometimes triangles, in a regular grid. The x,y coordinates of all vertex
 positions refer to the x,y coordinates on the terrain height map, the z-axis
 stores the elevation at a specific point.
 
 <p>TER (Terragen) and HMP (3D Game Studio) are height map formats.
 <b>Note</b>: Assimp is probably not the best choice for loading *huge* terrains -
 fully triangulated data takes extremely much free store and should be avoided
 as long as possible (typically you'll do the triangulation when you actually
 need to render it).</p></div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.AI_SCENE_FLAGS_TERRAIN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ASSIMP_CFLAGS_SHARED">
<h3>ASSIMP_CFLAGS_SHARED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ASSIMP_CFLAGS_SHARED</span></div>
<div class="block">Assimp was compiled as a shared object (Windows: DLL)</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.ASSIMP_CFLAGS_SHARED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ASSIMP_CFLAGS_STLPORT">
<h3>ASSIMP_CFLAGS_STLPORT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ASSIMP_CFLAGS_STLPORT</span></div>
<div class="block">Assimp was compiled against STLport</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.ASSIMP_CFLAGS_STLPORT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ASSIMP_CFLAGS_DEBUG">
<h3>ASSIMP_CFLAGS_DEBUG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ASSIMP_CFLAGS_DEBUG</span></div>
<div class="block">Assimp was compiled as a debug build</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.ASSIMP_CFLAGS_DEBUG">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ASSIMP_CFLAGS_NOBOOST">
<h3>ASSIMP_CFLAGS_NOBOOST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ASSIMP_CFLAGS_NOBOOST</span></div>
<div class="block">Assimp was compiled with <code>ASSIMP_BUILD_BOOST_WORKAROUND</code> defined</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.ASSIMP_CFLAGS_NOBOOST">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ASSIMP_CFLAGS_SINGLETHREADED">
<h3>ASSIMP_CFLAGS_SINGLETHREADED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ASSIMP_CFLAGS_SINGLETHREADED</span></div>
<div class="block">Assimp was compiled with <code>ASSIMP_BUILD_SINGLETHREADED</code> defined</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.ASSIMP_CFLAGS_SINGLETHREADED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ASSIMP_CFLAGS_DOUBLE_SUPPORT">
<h3>ASSIMP_CFLAGS_DOUBLE_SUPPORT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">ASSIMP_CFLAGS_DOUBLE_SUPPORT</span></div>
<div class="block">Assimp was compiled with <code>ASSIMP_DOUBLE_PRECISION</code> defined</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../constant-values.html#org.lwjgl.assimp.Assimp.ASSIMP_CFLAGS_DOUBLE_SUPPORT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="getLibrary()">
<h3>getLibrary</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system">SharedLibrary</a></span>&nbsp;<span class="element-name">getLibrary</span>()</div>
<div class="block">Returns the assimp <a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system"><code>SharedLibrary</code></a>.</div>
</section>
</li>
<li>
<section class="detail" id="getDraco()">
<h3>getDraco</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system">SharedLibrary</a></span>&nbsp;<span class="element-name">getDraco</span>()</div>
<div class="block">Returns the Draco <a href="../system/SharedLibrary.html" title="interface in org.lwjgl.system"><code>SharedLibrary</code></a>.</div>
</section>
</li>
<li>
<section class="detail" id="aiComponent_COLORSn(int)">
<h3>aiComponent_COLORSn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_COLORSn</span><wbr><span class="parameters">(int&nbsp;n)</span></div>
<div class="block">Remove a specific color channel 'n'</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - The color channel</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiComponent_TEXCOORDSn(int)">
<h3>aiComponent_TEXCOORDSn</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiComponent_TEXCOORDSn</span><wbr><span class="parameters">(int&nbsp;n)</span></div>
<div class="block">Remove a specific UV channel 'n'</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - The UV channel</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_DEG_TO_RAD(float)">
<h3>AI_DEG_TO_RAD</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_DEG_TO_RAD</span><wbr><span class="parameters">(float&nbsp;x)</span></div>
<div class="block">Tiny macro to convert from degrees to radians</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - The value in degrees</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="AI_RAD_TO_DEG(float)">
<h3>AI_RAD_TO_DEG</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">AI_RAD_TO_DEG</span><wbr><span class="parameters">(float&nbsp;x)</span></div>
<div class="block">Tiny macro to convert from radians to degrees</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>x</code> - The value in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetExportFormatCount()">
<h3>aiGetExportFormatCount</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">aiGetExportFormatCount</span>()</div>
<div class="block">Returns the number of export file formats available in the current Assimp build. Use <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a> to retrieve infos of a specific
 export format.</div>
</section>
</li>
<li>
<section class="detail" id="naiGetExportFormatDescription(long)">
<h3>naiGetExportFormatDescription</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiGetExportFormatDescription</span><wbr><span class="parameters">(long&nbsp;pIndex)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetExportFormatDescription(long)">
<h3>aiGetExportFormatDescription</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIExportFormatDesc.html" title="class in org.lwjgl.assimp">AIExportFormatDesc</a></span>&nbsp;<span class="element-name">aiGetExportFormatDescription</span><wbr><span class="parameters">(long&nbsp;pIndex)</span></div>
<div class="block">Returns a description of the nth export file format. Use <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a> to learn how many export formats are supported. The description must
 be released by calling <a href="#aiReleaseExportFormatDescription(org.lwjgl.assimp.AIExportFormatDesc)"><code>ReleaseExportFormatDescription</code></a> afterwards.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pIndex</code> - Index of the export format to retrieve information for. Valid range is 0 to <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a></dd>
<dt>Returns:</dt>
<dd>A description of that specific export format. <code>NULL</code> if <code>pIndex</code> is out of range.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiReleaseExportFormatDescription(long)">
<h3>naiReleaseExportFormatDescription</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiReleaseExportFormatDescription</span><wbr><span class="parameters">(long&nbsp;desc)</span></div>
<div class="block">Unsafe version of: <a href="#aiReleaseExportFormatDescription(org.lwjgl.assimp.AIExportFormatDesc)"><code>ReleaseExportFormatDescription</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiReleaseExportFormatDescription(org.lwjgl.assimp.AIExportFormatDesc)">
<h3>aiReleaseExportFormatDescription</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiReleaseExportFormatDescription</span><wbr><span class="parameters">(<a href="AIExportFormatDesc.html" title="class in org.lwjgl.assimp">AIExportFormatDesc</a>&nbsp;desc)</span></div>
<div class="block">Release a description of the nth export file format. Must be returned by <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>desc</code> - Pointer to the description</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiCopyScene(long,long)">
<h3>naiCopyScene</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiCopyScene</span><wbr><span class="parameters">(long&nbsp;pIn,
 long&nbsp;pOut)</span></div>
<div class="block">Unsafe version of: <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)">
<h3>aiCopyScene</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiCopyScene</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;pOut)</span></div>
<div class="block">Create a modifiable copy of a scene.
 
 <p>This is useful to import files via Assimp, change their topology and export them again. Since the scene returned by the various importer functions is
 const, a modifiable copy is needed.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pIn</code> - Valid scene to be copied</dd>
<dd><code>pOut</code> - Receives a modifiable copy of the scene. Use <a href="#aiFreeScene(org.lwjgl.assimp.AIScene)"><code>FreeScene</code></a> to delete it again.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiCopyScene(org.lwjgl.assimp.AIScene)">
<h3>aiCopyScene</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiCopyScene</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn)</span></div>
<div class="block">Create a modifiable copy of a scene.
 
 <p>This is useful to import files via Assimp, change their topology and export them again. Since the scene returned by the various importer functions is
 const, a modifiable copy is needed.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pIn</code> - Valid scene to be copied</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiFreeScene(long)">
<h3>naiFreeScene</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiFreeScene</span><wbr><span class="parameters">(long&nbsp;pIn)</span></div>
<div class="block">Unsafe version of: <a href="#aiFreeScene(org.lwjgl.assimp.AIScene)"><code>FreeScene</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiFreeScene(org.lwjgl.assimp.AIScene)">
<h3>aiFreeScene</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiFreeScene</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn)</span></div>
<div class="block">Frees a scene copy created using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pIn</code> - Scene to be freed</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiExportScene(long,long,long,int)">
<h3>naiExportScene</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiExportScene</span><wbr><span class="parameters">(long&nbsp;pScene,
 long&nbsp;pFormatId,
 long&nbsp;pFileName,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Unsafe version of: <a href="#aiExportScene(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,int)"><code>ExportScene</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiExportScene(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,int)">
<h3>aiExportScene</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiExportScene</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFileName,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Exports the given scene to a chosen file format and writes the result file(s) to disk.
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Use <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> to get a modifiable copy of a previously imported scene.</p></div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - The scene to export. Stays in possession of the caller, is not changed by the function. The scene is expected to conform to Assimp's Importer
                       output format as specified in the Data Structures Page. In short, this means the model data should use a right-handed coordinate systems, face
                       winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. If your input data uses different conventions,
                       have a look at the last parameter.</dd>
<dd><code>pFormatId</code> - ID string to specify to which format you want to export to. Use <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a> / <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a> to learn which export
                       formats are available.</dd>
<dd><code>pFileName</code> - Output file to write</dd>
<dd><code>pPreProcessing</code> - Accepts any choice of the <code>aiPostProcessSteps</code> enumerated flags, but in reality only a subset of them makes sense here. Specifying
                       'preprocessing' flags is useful if the input scene does not conform to Assimp's default conventions as specified in the Data Structures Page. In
                       short, this means the geometry data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate
                       origin is assumed to be in the upper left. The <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags are used in the import
                       side to allow users to have those defaults automatically adapted to their conventions. Specifying those flags for exporting has the opposite
                       effect, respectively. Some other of the <code>aiPostProcessSteps</code> enumerated values may be useful as well, but you'll need to try out what their
                       effect on the exported file is. Many formats impose their own restrictions on the structure of the geometry stored therein, so some preprocessing
                       may have little or no effect at all, or may be redundant as exporters would apply them anyhow. A good example is triangulation - whilst you can
                       enforce it by specifying the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> flag, most export formats support only triangulate data so they would run the step anyway.
                       
                       <p>If assimp detects that the input scene was directly taken from the importer side of the library (i.e. not copied using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> and potentially
                       modified afterwards), any post-processing steps already applied to the scene will not be applied again, unless they show non-idempotent behavior
                       (<a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a>). One or more of:<br></p><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>a status code indicating the result of the export</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiExportScene(org.lwjgl.assimp.AIScene,java.lang.CharSequence,java.lang.CharSequence,int)">
<h3>aiExportScene</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiExportScene</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFileName,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Exports the given scene to a chosen file format and writes the result file(s) to disk.
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Use <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> to get a modifiable copy of a previously imported scene.</p></div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - The scene to export. Stays in possession of the caller, is not changed by the function. The scene is expected to conform to Assimp's Importer
                       output format as specified in the Data Structures Page. In short, this means the model data should use a right-handed coordinate systems, face
                       winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. If your input data uses different conventions,
                       have a look at the last parameter.</dd>
<dd><code>pFormatId</code> - ID string to specify to which format you want to export to. Use <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a> / <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a> to learn which export
                       formats are available.</dd>
<dd><code>pFileName</code> - Output file to write</dd>
<dd><code>pPreProcessing</code> - Accepts any choice of the <code>aiPostProcessSteps</code> enumerated flags, but in reality only a subset of them makes sense here. Specifying
                       'preprocessing' flags is useful if the input scene does not conform to Assimp's default conventions as specified in the Data Structures Page. In
                       short, this means the geometry data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate
                       origin is assumed to be in the upper left. The <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags are used in the import
                       side to allow users to have those defaults automatically adapted to their conventions. Specifying those flags for exporting has the opposite
                       effect, respectively. Some other of the <code>aiPostProcessSteps</code> enumerated values may be useful as well, but you'll need to try out what their
                       effect on the exported file is. Many formats impose their own restrictions on the structure of the geometry stored therein, so some preprocessing
                       may have little or no effect at all, or may be redundant as exporters would apply them anyhow. A good example is triangulation - whilst you can
                       enforce it by specifying the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> flag, most export formats support only triangulate data so they would run the step anyway.
                       
                       <p>If assimp detects that the input scene was directly taken from the importer side of the library (i.e. not copied using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> and potentially
                       modified afterwards), any post-processing steps already applied to the scene will not be applied again, unless they show non-idempotent behavior
                       (<a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a>). One or more of:<br></p><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>a status code indicating the result of the export</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiExportSceneEx(long,long,long,long,int)">
<h3>naiExportSceneEx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiExportSceneEx</span><wbr><span class="parameters">(long&nbsp;pScene,
 long&nbsp;pFormatId,
 long&nbsp;pFileName,
 long&nbsp;pIO,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Unsafe version of: <a href="#aiExportSceneEx(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,org.lwjgl.assimp.AIFileIO,int)"><code>ExportSceneEx</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiExportSceneEx(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,java.nio.ByteBuffer,org.lwjgl.assimp.AIFileIO,int)">
<h3>aiExportSceneEx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiExportSceneEx</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFileName,
 @Nullable
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pIO,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Exports the given scene to a chosen file format using custom IO logic supplied by you.
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Use <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> to get a modifiable copy of a previously imported scene.</p></div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - The scene to export. Stays in possession of the caller, is not changed by the function. The scene is expected to conform to Assimp's Importer
                       output format as specified in the Data Structures Page. In short, this means the model data should use a right-handed coordinate systems, face
                       winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. If your input data uses different conventions,
                       have a look at the last parameter.</dd>
<dd><code>pFormatId</code> - ID string to specify to which format you want to export to. Use <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a> / <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a> to learn which export
                       formats are available.</dd>
<dd><code>pFileName</code> - Output file to write</dd>
<dd><code>pIO</code> - custom IO implementation to be used. Use this if you use your own storage methods. If none is supplied, a default implementation using standard
                       file IO is used. Note that <a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)"><code>ExportSceneToBlob</code></a> is provided as convenience function to export to memory buffers.</dd>
<dd><code>pPreProcessing</code> - Accepts any choice of the <code>aiPostProcessSteps</code> enumerated flags, but in reality only a subset of them makes sense here. Specifying
                       'preprocessing' flags is useful if the input scene does not conform to Assimp's default conventions as specified in the Data Structures Page. In
                       short, this means the geometry data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate
                       origin is assumed to be in the upper left. The <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags are used in the import
                       side to allow users to have those defaults automatically adapted to their conventions. Specifying those flags for exporting has the opposite
                       effect, respectively. Some other of the <code>aiPostProcessSteps</code> enumerated values may be useful as well, but you'll need to try out what their
                       effect on the exported file is. Many formats impose their own restrictions on the structure of the geometry stored therein, so some preprocessing
                       may have little or no effect at all, or may be redundant as exporters would apply them anyhow. A good example is triangulation - whilst you can
                       enforce it by specifying the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> flag, most export formats support only triangulate data so they would run the step anyway.
                       
                       <p>If assimp detects that the input scene was directly taken from the importer side of the library (i.e. not copied using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> and potentially
                       modified afterwards), any post-processing steps already applied to the scene will not be applied again, unless they show non-idempotent behavior
                       (<a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a>). One or more of:<br></p><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>a status code indicating the result of the export</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiExportSceneEx(org.lwjgl.assimp.AIScene,java.lang.CharSequence,java.lang.CharSequence,org.lwjgl.assimp.AIFileIO,int)">
<h3>aiExportSceneEx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiExportSceneEx</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFormatId,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFileName,
 @Nullable
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pIO,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Exports the given scene to a chosen file format using custom IO logic supplied by you.
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>Use <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> to get a modifiable copy of a previously imported scene.</p></div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - The scene to export. Stays in possession of the caller, is not changed by the function. The scene is expected to conform to Assimp's Importer
                       output format as specified in the Data Structures Page. In short, this means the model data should use a right-handed coordinate systems, face
                       winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. If your input data uses different conventions,
                       have a look at the last parameter.</dd>
<dd><code>pFormatId</code> - ID string to specify to which format you want to export to. Use <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a> / <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a> to learn which export
                       formats are available.</dd>
<dd><code>pFileName</code> - Output file to write</dd>
<dd><code>pIO</code> - custom IO implementation to be used. Use this if you use your own storage methods. If none is supplied, a default implementation using standard
                       file IO is used. Note that <a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)"><code>ExportSceneToBlob</code></a> is provided as convenience function to export to memory buffers.</dd>
<dd><code>pPreProcessing</code> - Accepts any choice of the <code>aiPostProcessSteps</code> enumerated flags, but in reality only a subset of them makes sense here. Specifying
                       'preprocessing' flags is useful if the input scene does not conform to Assimp's default conventions as specified in the Data Structures Page. In
                       short, this means the geometry data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate
                       origin is assumed to be in the upper left. The <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags are used in the import
                       side to allow users to have those defaults automatically adapted to their conventions. Specifying those flags for exporting has the opposite
                       effect, respectively. Some other of the <code>aiPostProcessSteps</code> enumerated values may be useful as well, but you'll need to try out what their
                       effect on the exported file is. Many formats impose their own restrictions on the structure of the geometry stored therein, so some preprocessing
                       may have little or no effect at all, or may be redundant as exporters would apply them anyhow. A good example is triangulation - whilst you can
                       enforce it by specifying the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> flag, most export formats support only triangulate data so they would run the step anyway.
                       
                       <p>If assimp detects that the input scene was directly taken from the importer side of the library (i.e. not copied using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> and potentially
                       modified afterwards), any post-processing steps already applied to the scene will not be applied again, unless they show non-idempotent behavior
                       (<a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a>). One or more of:<br></p><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>a status code indicating the result of the export</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiExportSceneToBlob(long,long,int)">
<h3>naiExportSceneToBlob</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiExportSceneToBlob</span><wbr><span class="parameters">(long&nbsp;pScene,
 long&nbsp;pFormatId,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Unsafe version of: <a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)"><code>ExportSceneToBlob</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)">
<h3>aiExportSceneToBlob</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIExportDataBlob.html" title="class in org.lwjgl.assimp">AIExportDataBlob</a></span>&nbsp;<span class="element-name">aiExportSceneToBlob</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFormatId,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Exports the given scene to a chosen file format. Returns the exported data as a binary blob which you can write into a file or something. When you're
 done with the data, use <a href="#aiReleaseExportBlob(org.lwjgl.assimp.AIExportDataBlob)"><code>ReleaseExportBlob</code></a> to free the resources associated with the export.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - The scene to export. Stays in possession of the caller, is not changed by the function. The scene is expected to conform to Assimp's Importer
                       output format as specified in the Data Structures Page. In short, this means the model data should use a right-handed coordinate systems, face
                       winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. If your input data uses different conventions,
                       have a look at the last parameter.</dd>
<dd><code>pFormatId</code> - ID string to specify to which format you want to export to. Use <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a> / <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a> to learn which export
                       formats are available.</dd>
<dd><code>pPreProcessing</code> - Accepts any choice of the <code>aiPostProcessSteps</code> enumerated flags, but in reality only a subset of them makes sense here. Specifying
                       'preprocessing' flags is useful if the input scene does not conform to Assimp's default conventions as specified in the Data Structures Page. In
                       short, this means the geometry data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate
                       origin is assumed to be in the upper left. The <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags are used in the import
                       side to allow users to have those defaults automatically adapted to their conventions. Specifying those flags for exporting has the opposite
                       effect, respectively. Some other of the <code>aiPostProcessSteps</code> enumerated values may be useful as well, but you'll need to try out what their
                       effect on the exported file is. Many formats impose their own restrictions on the structure of the geometry stored therein, so some preprocessing
                       may have little or no effect at all, or may be redundant as exporters would apply them anyhow. A good example is triangulation - whilst you can
                       enforce it by specifying the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> flag, most export formats support only triangulate data so they would run the step anyway.
                       
                       <p>If assimp detects that the input scene was directly taken from the importer side of the library (i.e. not copied using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> and potentially
                       modified afterwards), any post-processing steps already applied to the scene will not be applied again, unless they show non-idempotent behavior
                       (<a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a>). One or more of:<br></p><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>the exported data or <code>NULL</code> in case of error</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.lang.CharSequence,int)">
<h3>aiExportSceneToBlob</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIExportDataBlob.html" title="class in org.lwjgl.assimp">AIExportDataBlob</a></span>&nbsp;<span class="element-name">aiExportSceneToBlob</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFormatId,
 int&nbsp;pPreProcessing)</span></div>
<div class="block">Exports the given scene to a chosen file format. Returns the exported data as a binary blob which you can write into a file or something. When you're
 done with the data, use <a href="#aiReleaseExportBlob(org.lwjgl.assimp.AIExportDataBlob)"><code>ReleaseExportBlob</code></a> to free the resources associated with the export.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - The scene to export. Stays in possession of the caller, is not changed by the function. The scene is expected to conform to Assimp's Importer
                       output format as specified in the Data Structures Page. In short, this means the model data should use a right-handed coordinate systems, face
                       winding should be counter-clockwise and the UV coordinate origin is assumed to be in the upper left. If your input data uses different conventions,
                       have a look at the last parameter.</dd>
<dd><code>pFormatId</code> - ID string to specify to which format you want to export to. Use <a href="#aiGetExportFormatCount()"><code>GetExportFormatCount</code></a> / <a href="#aiGetExportFormatDescription(long)"><code>GetExportFormatDescription</code></a> to learn which export
                       formats are available.</dd>
<dd><code>pPreProcessing</code> - Accepts any choice of the <code>aiPostProcessSteps</code> enumerated flags, but in reality only a subset of them makes sense here. Specifying
                       'preprocessing' flags is useful if the input scene does not conform to Assimp's default conventions as specified in the Data Structures Page. In
                       short, this means the geometry data should use a right-handed coordinate systems, face winding should be counter-clockwise and the UV coordinate
                       origin is assumed to be in the upper left. The <a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a> flags are used in the import
                       side to allow users to have those defaults automatically adapted to their conventions. Specifying those flags for exporting has the opposite
                       effect, respectively. Some other of the <code>aiPostProcessSteps</code> enumerated values may be useful as well, but you'll need to try out what their
                       effect on the exported file is. Many formats impose their own restrictions on the structure of the geometry stored therein, so some preprocessing
                       may have little or no effect at all, or may be redundant as exporters would apply them anyhow. A good example is triangulation - whilst you can
                       enforce it by specifying the <a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a> flag, most export formats support only triangulate data so they would run the step anyway.
                       
                       <p>If assimp detects that the input scene was directly taken from the importer side of the library (i.e. not copied using <a href="#aiCopyScene(org.lwjgl.assimp.AIScene,org.lwjgl.PointerBuffer)"><code>CopyScene</code></a> and potentially
                       modified afterwards), any post-processing steps already applied to the scene will not be applied again, unless they show non-idempotent behavior
                       (<a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a>, <a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a> and <a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a>). One or more of:<br></p><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>the exported data or <code>NULL</code> in case of error</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiReleaseExportBlob(long)">
<h3>naiReleaseExportBlob</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiReleaseExportBlob</span><wbr><span class="parameters">(long&nbsp;pData)</span></div>
<div class="block">Unsafe version of: <a href="#aiReleaseExportBlob(org.lwjgl.assimp.AIExportDataBlob)"><code>ReleaseExportBlob</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiReleaseExportBlob(org.lwjgl.assimp.AIExportDataBlob)">
<h3>aiReleaseExportBlob</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiReleaseExportBlob</span><wbr><span class="parameters">(<a href="AIExportDataBlob.html" title="class in org.lwjgl.assimp">AIExportDataBlob</a>&nbsp;pData)</span></div>
<div class="block">Releases the memory associated with the given exported data. Use this function to free a data blob returned by <a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)"><code>ExportSceneToBlob</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pData</code> - the data blob returned by <a href="#aiExportSceneToBlob(org.lwjgl.assimp.AIScene,java.nio.ByteBuffer,int)"><code>ExportSceneToBlob</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiImportFile(long,int)">
<h3>naiImportFile</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiImportFile</span><wbr><span class="parameters">(long&nbsp;pFile,
 int&nbsp;pFlags)</span></div>
<div class="block">Unsafe version of: <a href="#aiImportFile(java.nio.ByteBuffer,int)"><code>ImportFile</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiImportFile(java.nio.ByteBuffer,int)">
<h3>aiImportFile</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFile</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFile,
 int&nbsp;pFlags)</span></div>
<div class="block">Reads the given file and returns its content.
 
 <p>If the call succeeds, the imported data is returned in an <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> structure. The data is intended to be read-only, it stays property of the ASSIMP
 library and will be stable until <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> is called. After you're done with it, call <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> to free the resources associated with
 this file. If the import fails, <code>NULL</code> is returned instead. Call <a href="#aiGetErrorString()"><code>GetErrorString</code></a> to retrieve a human-readable error text.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pFile</code> - Path and filename of the file to be imported</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
               your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>Pointer to the imported data or <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImportFile(java.lang.CharSequence,int)">
<h3>aiImportFile</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFile</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFile,
 int&nbsp;pFlags)</span></div>
<div class="block">Reads the given file and returns its content.
 
 <p>If the call succeeds, the imported data is returned in an <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> structure. The data is intended to be read-only, it stays property of the ASSIMP
 library and will be stable until <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> is called. After you're done with it, call <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> to free the resources associated with
 this file. If the import fails, <code>NULL</code> is returned instead. Call <a href="#aiGetErrorString()"><code>GetErrorString</code></a> to retrieve a human-readable error text.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pFile</code> - Path and filename of the file to be imported</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
               your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>Pointer to the imported data or <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiImportFileEx(long,int,long)">
<h3>naiImportFileEx</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiImportFileEx</span><wbr><span class="parameters">(long&nbsp;pFile,
 int&nbsp;pFlags,
 long&nbsp;pFS)</span></div>
<div class="block">Unsafe version of: <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)">
<h3>aiImportFileEx</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileEx</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFile,
 int&nbsp;pFlags,
 @Nullable
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS)</span></div>
<div class="block">Reads the given file using user-defined I/O functions and returns its content.
 
 <p>If the call succeeds, the imported data is returned in an <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> structure. The data is intended to be read-only, it stays property of the ASSIMP
 library and will be stable until <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> is called. After you're done with it, call <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> to free the resources associated with
 this file. If the import fails, <code>NULL</code> is returned instead. Call <a href="#aiGetErrorString()"><code>GetErrorString</code></a> to retrieve a human-readable error text.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pFile</code> - Path and filename of the file to be imported</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
               your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pFS</code> - Will be used to open the model file itself and any other files the loader needs to open. Pass <code>NULL</code> to use the default implementation.</dd>
<dt>Returns:</dt>
<dd>Pointer to the imported data or <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImportFileEx(java.lang.CharSequence,int,org.lwjgl.assimp.AIFileIO)">
<h3>aiImportFileEx</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileEx</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFile,
 int&nbsp;pFlags,
 @Nullable
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS)</span></div>
<div class="block">Reads the given file using user-defined I/O functions and returns its content.
 
 <p>If the call succeeds, the imported data is returned in an <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> structure. The data is intended to be read-only, it stays property of the ASSIMP
 library and will be stable until <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> is called. After you're done with it, call <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a> to free the resources associated with
 this file. If the import fails, <code>NULL</code> is returned instead. Call <a href="#aiGetErrorString()"><code>GetErrorString</code></a> to retrieve a human-readable error text.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pFile</code> - Path and filename of the file to be imported</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
               your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pFS</code> - Will be used to open the model file itself and any other files the loader needs to open. Pass <code>NULL</code> to use the default implementation.</dd>
<dt>Returns:</dt>
<dd>Pointer to the imported data or <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiImportFileExWithProperties(long,int,long,long)">
<h3>naiImportFileExWithProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiImportFileExWithProperties</span><wbr><span class="parameters">(long&nbsp;pFile,
 int&nbsp;pFlags,
 long&nbsp;pFS,
 long&nbsp;pProps)</span></div>
<div class="block">Unsafe version of: <a href="#aiImportFileExWithProperties(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)"><code>ImportFileExWithProperties</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiImportFileExWithProperties(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)">
<h3>aiImportFileExWithProperties</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileExWithProperties</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pFile,
 int&nbsp;pFlags,
 @Nullable
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</span></div>
<div class="block">Same as <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a>, but adds an extra parameter containing importer settings.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pFile</code> - Path and filename of the file to be imported</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
               your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pFS</code> - Will be used to open the model file itself and any other files the loader needs to open. Pass <code>NULL</code> to use the default implementation.</dd>
<dd><code>pProps</code> - <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp"><code>AIPropertyStore</code></a> instance containing import settings.</dd>
<dt>Returns:</dt>
<dd>Pointer to the imported data or <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImportFileExWithProperties(java.lang.CharSequence,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)">
<h3>aiImportFileExWithProperties</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileExWithProperties</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pFile,
 int&nbsp;pFlags,
 @Nullable
 <a href="AIFileIO.html" title="class in org.lwjgl.assimp">AIFileIO</a>&nbsp;pFS,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</span></div>
<div class="block">Same as <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a>, but adds an extra parameter containing importer settings.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pFile</code> - Path and filename of the file to be imported</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
               your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pFS</code> - Will be used to open the model file itself and any other files the loader needs to open. Pass <code>NULL</code> to use the default implementation.</dd>
<dd><code>pProps</code> - <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp"><code>AIPropertyStore</code></a> instance containing import settings.</dd>
<dt>Returns:</dt>
<dd>Pointer to the imported data or <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiImportFileFromMemory(long,int,int,long)">
<h3>naiImportFileFromMemory</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiImportFileFromMemory</span><wbr><span class="parameters">(long&nbsp;pBuffer,
 int&nbsp;pLength,
 int&nbsp;pFlags,
 long&nbsp;pHint)</span></div>
<div class="block">Unsafe version of: <a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)"><code>ImportFileFromMemory</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pLength</code> - Length of pBuffer, in bytes</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)">
<h3>aiImportFileFromMemory</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileFromMemory</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pHint)</span></div>
<div class="block">Reads the given file from a given memory buffer.
 
 <p>If the call succeeds, the contents of the file are returned as a pointer to an <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> object. The returned data is intended to be read-only, the
 importer keeps ownership of the data and will destroy it upon destruction. If the import fails, <code>NULL</code> is returned. A human-readable error description
 can be retrieved by calling <a href="#aiGetErrorString()"><code>GetErrorString</code></a>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>This is a straightforward way to decode models from memory buffers, but it doesn't handle model formats that spread their data across multiple files or
 even directories. Examples include OBJ or MD3, which outsource parts of their material info into external scripts. If you need full functionality,
 provide a custom IOSystem to make Assimp find these files and use the regular <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a>/<a href="#aiImportFileExWithProperties(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)"><code>ImportFileExWithProperties</code></a> API.</p>
 </div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pBuffer</code> - Pointer to the file data</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
                your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pHint</code> - An additional hint to the library. If this is a non empty string, the library looks for a loader to support the file extension specified by
                <code>pHint</code> and passes the file to the first matching loader. If this loader is unable to completely the request, the library continues and tries
                to determine the file format on its own, a task that may or may not be successful. Check the return value, and you'll know ...</dd>
<dt>Returns:</dt>
<dd>A pointer to the imported data, <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImportFileFromMemory(java.nio.ByteBuffer,int,java.lang.CharSequence)">
<h3>aiImportFileFromMemory</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileFromMemory</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pHint)</span></div>
<div class="block">Reads the given file from a given memory buffer.
 
 <p>If the call succeeds, the contents of the file are returned as a pointer to an <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> object. The returned data is intended to be read-only, the
 importer keeps ownership of the data and will destroy it upon destruction. If the import fails, <code>NULL</code> is returned. A human-readable error description
 can be retrieved by calling <a href="#aiGetErrorString()"><code>GetErrorString</code></a>.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>This is a straightforward way to decode models from memory buffers, but it doesn't handle model formats that spread their data across multiple files or
 even directories. Examples include OBJ or MD3, which outsource parts of their material info into external scripts. If you need full functionality,
 provide a custom IOSystem to make Assimp find these files and use the regular <a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a>/<a href="#aiImportFileExWithProperties(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO,org.lwjgl.assimp.AIPropertyStore)"><code>ImportFileExWithProperties</code></a> API.</p>
 </div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pBuffer</code> - Pointer to the file data</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
                your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pHint</code> - An additional hint to the library. If this is a non empty string, the library looks for a loader to support the file extension specified by
                <code>pHint</code> and passes the file to the first matching loader. If this loader is unable to completely the request, the library continues and tries
                to determine the file format on its own, a task that may or may not be successful. Check the return value, and you'll know ...</dd>
<dt>Returns:</dt>
<dd>A pointer to the imported data, <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiImportFileFromMemoryWithProperties(long,int,int,long,long)">
<h3>naiImportFileFromMemoryWithProperties</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiImportFileFromMemoryWithProperties</span><wbr><span class="parameters">(long&nbsp;pBuffer,
 int&nbsp;pLength,
 int&nbsp;pFlags,
 long&nbsp;pHint,
 long&nbsp;pProps)</span></div>
<div class="block">Unsafe version of: <a href="#aiImportFileFromMemoryWithProperties(java.nio.ByteBuffer,int,java.nio.ByteBuffer,org.lwjgl.assimp.AIPropertyStore)"><code>ImportFileFromMemoryWithProperties</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pLength</code> - Length of pBuffer, in bytes</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImportFileFromMemoryWithProperties(java.nio.ByteBuffer,int,java.nio.ByteBuffer,org.lwjgl.assimp.AIPropertyStore)">
<h3>aiImportFileFromMemoryWithProperties</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileFromMemoryWithProperties</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pHint,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</span></div>
<div class="block">Same as <a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)"><code>ImportFileFromMemory</code></a>, but adds an extra parameter containing importer settings.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pBuffer</code> - Pointer to the file data</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
                your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pHint</code> - An additional hint to the library. If this is a non empty string, the library looks for a loader to support the file extension specified by
                <code>pHint</code> and passes the file to the first matching loader. If this loader is unable to completely the request, the library continues and tries
                to determine the file format on its own, a task that may or may not be successful. Check the return value, and you'll know ...</dd>
<dd><code>pProps</code> - <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp"><code>AIPropertyStore</code></a> instance containing import settings.</dd>
<dt>Returns:</dt>
<dd>A pointer to the imported data, <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiImportFileFromMemoryWithProperties(java.nio.ByteBuffer,int,java.lang.CharSequence,org.lwjgl.assimp.AIPropertyStore)">
<h3>aiImportFileFromMemoryWithProperties</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiImportFileFromMemoryWithProperties</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pBuffer,
 int&nbsp;pFlags,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pHint,
 <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;pProps)</span></div>
<div class="block">Same as <a href="#aiImportFileFromMemory(java.nio.ByteBuffer,int,java.nio.ByteBuffer)"><code>ImportFileFromMemory</code></a>, but adds an extra parameter containing importer settings.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pBuffer</code> - Pointer to the file data</dd>
<dd><code>pFlags</code> - Optional post processing steps to be executed after a successful import. If you wish to inspect the imported scene first in order to fine-tune
                your post-processing setup, consider to use <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dd><code>pHint</code> - An additional hint to the library. If this is a non empty string, the library looks for a loader to support the file extension specified by
                <code>pHint</code> and passes the file to the first matching loader. If this loader is unable to completely the request, the library continues and tries
                to determine the file format on its own, a task that may or may not be successful. Check the return value, and you'll know ...</dd>
<dd><code>pProps</code> - <a href="AIPropertyStore.html" title="class in org.lwjgl.assimp"><code>AIPropertyStore</code></a> instance containing import settings.</dd>
<dt>Returns:</dt>
<dd>A pointer to the imported data, <code>NULL</code> if the import failed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiApplyPostProcessing(long,int)">
<h3>naiApplyPostProcessing</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiApplyPostProcessing</span><wbr><span class="parameters">(long&nbsp;pScene,
 int&nbsp;pFlags)</span></div>
<div class="block">Unsafe version of: <a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)">
<h3>aiApplyPostProcessing</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a></span>&nbsp;<span class="element-name">aiApplyPostProcessing</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene,
 int&nbsp;pFlags)</span></div>
<div class="block">Apply post-processing to an already-imported scene.
 
 <p>This is strictly equivalent to calling <a href="#aiImportFile(java.nio.ByteBuffer,int)"><code>ImportFile</code></a>/<a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a> with the same flags. However, you can use this separate function to inspect the
 imported scene first to fine-tune your post-processing setup.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - Scene to work on.</dd>
<dd><code>pFlags</code> - Provide a bitwise combination of the <code>aiPostProcessSteps</code> flags. One or more of:<br><table><tr><td><a href="#aiProcess_CalcTangentSpace"><code>Process_CalcTangentSpace</code></a></td><td><a href="#aiProcess_JoinIdenticalVertices"><code>Process_JoinIdenticalVertices</code></a></td><td><a href="#aiProcess_MakeLeftHanded"><code>Process_MakeLeftHanded</code></a></td></tr><tr><td><a href="#aiProcess_Triangulate"><code>Process_Triangulate</code></a></td><td><a href="#aiProcess_RemoveComponent"><code>Process_RemoveComponent</code></a></td><td><a href="#aiProcess_GenNormals"><code>Process_GenNormals</code></a></td></tr><tr><td><a href="#aiProcess_GenSmoothNormals"><code>Process_GenSmoothNormals</code></a></td><td><a href="#aiProcess_SplitLargeMeshes"><code>Process_SplitLargeMeshes</code></a></td><td><a href="#aiProcess_PreTransformVertices"><code>Process_PreTransformVertices</code></a></td></tr><tr><td><a href="#aiProcess_LimitBoneWeights"><code>Process_LimitBoneWeights</code></a></td><td><a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a></td><td><a href="#aiProcess_ImproveCacheLocality"><code>Process_ImproveCacheLocality</code></a></td></tr><tr><td><a href="#aiProcess_RemoveRedundantMaterials"><code>Process_RemoveRedundantMaterials</code></a></td><td><a href="#aiProcess_FixInfacingNormals"><code>Process_FixInfacingNormals</code></a></td><td><a href="#aiProcess_PopulateArmatureData"><code>Process_PopulateArmatureData</code></a></td></tr><tr><td><a href="#aiProcess_SortByPType"><code>Process_SortByPType</code></a></td><td><a href="#aiProcess_FindDegenerates"><code>Process_FindDegenerates</code></a></td><td><a href="#aiProcess_FindInvalidData"><code>Process_FindInvalidData</code></a></td></tr><tr><td><a href="#aiProcess_GenUVCoords"><code>Process_GenUVCoords</code></a></td><td><a href="#aiProcess_TransformUVCoords"><code>Process_TransformUVCoords</code></a></td><td><a href="#aiProcess_FindInstances"><code>Process_FindInstances</code></a></td></tr><tr><td><a href="#aiProcess_OptimizeMeshes"><code>Process_OptimizeMeshes</code></a></td><td><a href="#aiProcess_OptimizeGraph"><code>Process_OptimizeGraph</code></a></td><td><a href="#aiProcess_FlipUVs"><code>Process_FlipUVs</code></a></td></tr><tr><td><a href="#aiProcess_FlipWindingOrder"><code>Process_FlipWindingOrder</code></a></td><td><a href="#aiProcess_SplitByBoneCount"><code>Process_SplitByBoneCount</code></a></td><td><a href="#aiProcess_Debone"><code>Process_Debone</code></a></td></tr><tr><td><a href="#aiProcess_GlobalScale"><code>Process_GlobalScale</code></a></td><td><a href="#aiProcess_EmbedTextures"><code>Process_EmbedTextures</code></a></td><td><a href="#aiProcess_ForceGenNormals"><code>Process_ForceGenNormals</code></a></td></tr><tr><td><a href="#aiProcess_DropNormals"><code>Process_DropNormals</code></a></td><td><a href="#aiProcess_GenBoundingBoxes"><code>Process_GenBoundingBoxes</code></a></td><td><a href="#aiProcess_ConvertToLeftHanded"><code>Process_ConvertToLeftHanded</code></a></td></tr><tr><td><a href="#aiProcessPreset_TargetRealtime_Fast"><code>ProcessPreset_TargetRealtime_Fast</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_Quality"><code>ProcessPreset_TargetRealtime_Quality</code></a></td><td><a href="#aiProcessPreset_TargetRealtime_MaxQuality"><code>ProcessPreset_TargetRealtime_MaxQuality</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>A pointer to the post-processed data. Post processing is done in-place, meaning this is still the same <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> which you passed for <code>pScene</code>.
         However, <em>if</em> post-processing failed, the scene could now be <code>NULL</code>. That's quite a rare case, post processing steps are not really designed to
         'fail'. To be exact, the <a href="#aiProcess_ValidateDataStructure"><code>Process_ValidateDataStructure</code></a> flag is currently the only post processing step which can actually cause the scene to be reset
         to <code>NULL</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetPredefinedLogStream(int,long,long)">
<h3>naiGetPredefinedLogStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiGetPredefinedLogStream</span><wbr><span class="parameters">(int&nbsp;pStreams,
 long&nbsp;file,
 long&nbsp;__result)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetPredefinedLogStream(int,java.nio.ByteBuffer,org.lwjgl.assimp.AILogStream)"><code>GetPredefinedLogStream</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetPredefinedLogStream(int,java.nio.ByteBuffer,org.lwjgl.assimp.AILogStream)">
<h3>aiGetPredefinedLogStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a></span>&nbsp;<span class="element-name">aiGetPredefinedLogStream</span><wbr><span class="parameters">(int&nbsp;pStreams,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;file,
 <a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;__result)</span></div>
<div class="block">Get one of the predefine log streams.
 
 <p>This is the quick'n'easy solution to access Assimp's log system. Attaching a log stream can slightly reduce Assimp's overall import performance.</p>
 
 <p>Usage is rather simple (this will stream the log to a file, named log.txt, and the stdout stream of the process:</p>
 
 <pre><code>
 struct aiLogStream c;
 c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE, "log.txt");
 aiAttachLogStream(&amp;c);
 c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT, NULL);
 aiAttachLogStream(&amp;c);</code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pStreams</code> - One of the <code>aiDefaultLogStream</code> enumerated values. One of:<br><table><tr><td><a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a></td><td><a href="#aiDefaultLogStream_STDOUT"><code>DefaultLogStream_STDOUT</code></a></td><td><a href="#aiDefaultLogStream_STDERR"><code>DefaultLogStream_STDERR</code></a></td></tr><tr><td><a href="#aiDefaultLogStream_DEBUGGER"><code>DefaultLogStream_DEBUGGER</code></a></td></tr></table></dd>
<dd><code>file</code> - Solely for the <a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a> flag: specifies the file to write to. Pass <code>NULL</code> for all other flags.</dd>
<dd><code>__result</code> - The log stream. <code>callback</code> is set to <code>NULL</code> if something went wrong.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetPredefinedLogStream(int,java.lang.CharSequence,org.lwjgl.assimp.AILogStream)">
<h3>aiGetPredefinedLogStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a></span>&nbsp;<span class="element-name">aiGetPredefinedLogStream</span><wbr><span class="parameters">(int&nbsp;pStreams,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;file,
 <a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;__result)</span></div>
<div class="block">Get one of the predefine log streams.
 
 <p>This is the quick'n'easy solution to access Assimp's log system. Attaching a log stream can slightly reduce Assimp's overall import performance.</p>
 
 <p>Usage is rather simple (this will stream the log to a file, named log.txt, and the stdout stream of the process:</p>
 
 <pre><code>
 struct aiLogStream c;
 c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE, "log.txt");
 aiAttachLogStream(&amp;c);
 c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT, NULL);
 aiAttachLogStream(&amp;c);</code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pStreams</code> - One of the <code>aiDefaultLogStream</code> enumerated values. One of:<br><table><tr><td><a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a></td><td><a href="#aiDefaultLogStream_STDOUT"><code>DefaultLogStream_STDOUT</code></a></td><td><a href="#aiDefaultLogStream_STDERR"><code>DefaultLogStream_STDERR</code></a></td></tr><tr><td><a href="#aiDefaultLogStream_DEBUGGER"><code>DefaultLogStream_DEBUGGER</code></a></td></tr></table></dd>
<dd><code>file</code> - Solely for the <a href="#aiDefaultLogStream_FILE"><code>DefaultLogStream_FILE</code></a> flag: specifies the file to write to. Pass <code>NULL</code> for all other flags.</dd>
<dd><code>__result</code> - The log stream. <code>callback</code> is set to <code>NULL</code> if something went wrong.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiAttachLogStream(long)">
<h3>naiAttachLogStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiAttachLogStream</span><wbr><span class="parameters">(long&nbsp;stream)</span></div>
<div class="block">Unsafe version of: <a href="#aiAttachLogStream(org.lwjgl.assimp.AILogStream)"><code>AttachLogStream</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiAttachLogStream(org.lwjgl.assimp.AILogStream)">
<h3>aiAttachLogStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiAttachLogStream</span><wbr><span class="parameters">(<a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;stream)</span></div>
<div class="block">Attach a custom log stream to the libraries' logging system.
 
 <p>Attaching a log stream can slightly reduce Assimp's overall import performance. Multiple log-streams can be attached.</p>
 
 <div style="margin-left: 26px; border-left: 1px solid gray; padding-left: 14px;"><h5>Note</h5>
 
 <p>To ensure proper destruction of the logging system, you need to manually call <a href="#aiDetachLogStream(org.lwjgl.assimp.AILogStream)"><code>DetachLogStream</code></a> on every single log stream you attach. Alternatively
 (for the lazy folks) <a href="#aiDetachAllLogStreams()"><code>DetachAllLogStreams</code></a> is provided.</p>
 </div></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>stream</code> - Describes the new log stream.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiEnableVerboseLogging(boolean)">
<h3>aiEnableVerboseLogging</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiEnableVerboseLogging</span><wbr><span class="parameters">(boolean&nbsp;d)</span></div>
<div class="block">Enable verbose logging. Verbose logging includes debug-related stuff and detailed import statistics. This can have severe impact on import performance
 and memory consumption. However, it might be useful to find out why a file didn't read correctly.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>d</code> - true or false, your decision</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiDetachLogStream(long)">
<h3>naiDetachLogStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiDetachLogStream</span><wbr><span class="parameters">(long&nbsp;stream)</span></div>
<div class="block">Unsafe version of: <a href="#aiDetachLogStream(org.lwjgl.assimp.AILogStream)"><code>DetachLogStream</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiDetachLogStream(org.lwjgl.assimp.AILogStream)">
<h3>aiDetachLogStream</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiDetachLogStream</span><wbr><span class="parameters">(<a href="AILogStream.html" title="class in org.lwjgl.assimp">AILogStream</a>&nbsp;stream)</span></div>
<div class="block">Detach a custom log stream from the libraries' logging system.
 
 <p>This is the counterpart of <a href="#aiAttachLogStream(org.lwjgl.assimp.AILogStream)"><code>AttachLogStream</code></a>. If you attached a stream, don't forget to detach it again.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>stream</code> - The log stream to be detached.</dd>
<dt>Returns:</dt>
<dd><a href="#aiReturn_SUCCESS"><code>Return_SUCCESS</code></a> if the log stream has been detached successfully.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiDetachAllLogStreams()">
<h3>aiDetachAllLogStreams</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiDetachAllLogStreams</span>()</div>
<div class="block">Detach all active log streams from the libraries' logging system. This ensures that the logging system is terminated properly and all resources
 allocated by it are actually freed. If you attached a stream, don't forget to detach it again.</div>
</section>
</li>
<li>
<section class="detail" id="naiReleaseImport(long)">
<h3>naiReleaseImport</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiReleaseImport</span><wbr><span class="parameters">(long&nbsp;pScene)</span></div>
<div class="block">Unsafe version of: <a href="#aiReleaseImport(org.lwjgl.assimp.AIScene)"><code>ReleaseImport</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiReleaseImport(org.lwjgl.assimp.AIScene)">
<h3>aiReleaseImport</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiReleaseImport</span><wbr><span class="parameters">(@Nullable
 <a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pScene)</span></div>
<div class="block">Releases all resources associated with the given import process.
 
 <p>Call this function after you're done with the imported data.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pScene</code> - The imported data to release. <code>NULL</code> is a valid value.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetErrorString()">
<h3>naiGetErrorString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiGetErrorString</span>()</div>
<div class="block">Unsafe version of: <a href="#aiGetErrorString()"><code>GetErrorString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetErrorString()">
<h3>aiGetErrorString</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">aiGetErrorString</span>()</div>
<div class="block">Returns the error text of the last failed import process.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>A textual description of the error that occurred at the last import process. <code>NULL</code> if there was no error. There can't be an error if you got a
         non-<code>NULL</code> <a href="AIScene.html" title="class in org.lwjgl.assimp"><code>AIScene</code></a> from <a href="#aiImportFile(java.nio.ByteBuffer,int)"><code>ImportFile</code></a>/<a href="#aiImportFileEx(java.nio.ByteBuffer,int,org.lwjgl.assimp.AIFileIO)"><code>ImportFileEx</code></a>/<a href="#aiApplyPostProcessing(org.lwjgl.assimp.AIScene,int)"><code>ApplyPostProcessing</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiIsExtensionSupported(long)">
<h3>naiIsExtensionSupported</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiIsExtensionSupported</span><wbr><span class="parameters">(long&nbsp;szExtension)</span></div>
<div class="block">Unsafe version of: <a href="#aiIsExtensionSupported(java.nio.ByteBuffer)"><code>IsExtensionSupported</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiIsExtensionSupported(java.nio.ByteBuffer)">
<h3>aiIsExtensionSupported</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiIsExtensionSupported</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szExtension)</span></div>
<div class="block">Returns whether a given file extension is supported by ASSIMP.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>szExtension</code> - Extension for which the function queries support for. Must include a leading dot '.'. Example: ".3ds", ".md3"</dd>
<dt>Returns:</dt>
<dd>true if the file extension is supported.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiIsExtensionSupported(java.lang.CharSequence)">
<h3>aiIsExtensionSupported</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiIsExtensionSupported</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szExtension)</span></div>
<div class="block">Returns whether a given file extension is supported by ASSIMP.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>szExtension</code> - Extension for which the function queries support for. Must include a leading dot '.'. Example: ".3ds", ".md3"</dd>
<dt>Returns:</dt>
<dd>true if the file extension is supported.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetExtensionList(long)">
<h3>naiGetExtensionList</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiGetExtensionList</span><wbr><span class="parameters">(long&nbsp;szOut)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetExtensionList(org.lwjgl.assimp.AIString)"><code>GetExtensionList</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetExtensionList(org.lwjgl.assimp.AIString)">
<h3>aiGetExtensionList</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiGetExtensionList</span><wbr><span class="parameters">(<a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;szOut)</span></div>
<div class="block">Get a list of all file extensions supported by ASSIMP.
 
 <p>If a file extension is contained in the list this does, of course, not mean that ASSIMP is able to load all files with this extension.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>szOut</code> - String to receive the extension list. Format of the list: "*.3ds;*.obj;*.dae". <code>NULL</code> is not a valid parameter.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMemoryRequirements(long,long)">
<h3>naiGetMemoryRequirements</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiGetMemoryRequirements</span><wbr><span class="parameters">(long&nbsp;pIn,
 long&nbsp;in)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMemoryRequirements(org.lwjgl.assimp.AIScene,org.lwjgl.assimp.AIMemoryInfo)"><code>GetMemoryRequirements</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMemoryRequirements(org.lwjgl.assimp.AIScene,org.lwjgl.assimp.AIMemoryInfo)">
<h3>aiGetMemoryRequirements</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiGetMemoryRequirements</span><wbr><span class="parameters">(<a href="AIScene.html" title="class in org.lwjgl.assimp">AIScene</a>&nbsp;pIn,
 <a href="AIMemoryInfo.html" title="class in org.lwjgl.assimp">AIMemoryInfo</a>&nbsp;in)</span></div>
<div class="block">Get the approximated storage required by an imported asset.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pIn</code> - Input asset.</dd>
<dd><code>in</code> - Data structure to be filled.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiCreatePropertyStore()">
<h3>naiCreatePropertyStore</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiCreatePropertyStore</span>()</div>
<div class="block">Unsafe version of: <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiCreatePropertyStore()">
<h3>aiCreatePropertyStore</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a></span>&nbsp;<span class="element-name">aiCreatePropertyStore</span>()</div>
<div class="block">Create an empty property store. Property stores are used to collect import settings.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>New property store. Property stores need to be manually destroyed using the <a href="#aiReleasePropertyStore(org.lwjgl.assimp.AIPropertyStore)"><code>ReleasePropertyStore</code></a> API function.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiReleasePropertyStore(long)">
<h3>naiReleasePropertyStore</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiReleasePropertyStore</span><wbr><span class="parameters">(long&nbsp;p)</span></div>
<div class="block">Unsafe version of: <a href="#aiReleasePropertyStore(org.lwjgl.assimp.AIPropertyStore)"><code>ReleasePropertyStore</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiReleasePropertyStore(org.lwjgl.assimp.AIPropertyStore)">
<h3>aiReleasePropertyStore</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiReleasePropertyStore</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;p)</span></div>
<div class="block">Delete a property store.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p</code> - Property store to be deleted.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiSetImportPropertyInteger(long,long,int)">
<h3>naiSetImportPropertyInteger</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiSetImportPropertyInteger</span><wbr><span class="parameters">(long&nbsp;store,
 long&nbsp;szName,
 int&nbsp;value)</span></div>
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyInteger(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,int)"><code>SetImportPropertyInteger</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyInteger(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,int)">
<h3>aiSetImportPropertyInteger</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyInteger</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 int&nbsp;value)</span></div>
<div class="block">Set an integer property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyInteger()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyInteger(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,int)">
<h3>aiSetImportPropertyInteger</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyInteger</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 int&nbsp;value)</span></div>
<div class="block">Set an integer property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyInteger()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiSetImportPropertyFloat(long,long,float)">
<h3>naiSetImportPropertyFloat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiSetImportPropertyFloat</span><wbr><span class="parameters">(long&nbsp;store,
 long&nbsp;szName,
 float&nbsp;value)</span></div>
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyFloat(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,float)"><code>SetImportPropertyFloat</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyFloat(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,float)">
<h3>aiSetImportPropertyFloat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyFloat</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 float&nbsp;value)</span></div>
<div class="block">Set an floating-point property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyFloat()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyFloat(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,float)">
<h3>aiSetImportPropertyFloat</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyFloat</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 float&nbsp;value)</span></div>
<div class="block">Set an floating-point property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyFloat()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiSetImportPropertyString(long,long,long)">
<h3>naiSetImportPropertyString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiSetImportPropertyString</span><wbr><span class="parameters">(long&nbsp;store,
 long&nbsp;szName,
 long&nbsp;value)</span></div>
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyString(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIString)"><code>SetImportPropertyString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyString(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIString)">
<h3>aiSetImportPropertyString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyString</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;value)</span></div>
<div class="block">Set a string property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyString()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyString(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,org.lwjgl.assimp.AIString)">
<h3>aiSetImportPropertyString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyString</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;value)</span></div>
<div class="block">Set a string property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyString()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiSetImportPropertyMatrix(long,long,long)">
<h3>naiSetImportPropertyMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiSetImportPropertyMatrix</span><wbr><span class="parameters">(long&nbsp;store,
 long&nbsp;szName,
 long&nbsp;value)</span></div>
<div class="block">Unsafe version of: <a href="#aiSetImportPropertyMatrix(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIMatrix4x4)"><code>SetImportPropertyMatrix</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyMatrix(org.lwjgl.assimp.AIPropertyStore,java.nio.ByteBuffer,org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiSetImportPropertyMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyMatrix</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;szName,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;value)</span></div>
<div class="block">Set a matrix property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyMatrix()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiSetImportPropertyMatrix(org.lwjgl.assimp.AIPropertyStore,java.lang.CharSequence,org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiSetImportPropertyMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiSetImportPropertyMatrix</span><wbr><span class="parameters">(<a href="AIPropertyStore.html" title="class in org.lwjgl.assimp">AIPropertyStore</a>&nbsp;store,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;szName,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;value)</span></div>
<div class="block">Set a matrix property.
 
 <p>This is the C-version of <code>Assimp::Importer::SetPropertyMatrix()</code>. In the C interface, properties are always shared by all imports. It is not
 possible to specify them per import.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>store</code> - Store to modify. Use <a href="#aiCreatePropertyStore()"><code>CreatePropertyStore</code></a> to obtain a store.</dd>
<dd><code>szName</code> - Name of the configuration property to be set. One of:<br><table><tr><td><a href="#AI_CONFIG_GLOB_MEASURE_TIME"><code>AI_CONFIG_GLOB_MEASURE_TIME</code></a></td><td><a href="#AI_CONFIG_IMPORT_NO_SKELETON_MESHES"><code>AI_CONFIG_IMPORT_NO_SKELETON_MESHES</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBBC_MAX_BONES"><code>AI_CONFIG_PP_SBBC_MAX_BONES</code></a></td><td><a href="#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX"><code>AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX</code></a></td><td><a href="#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE"><code>AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_COLORMAP"><code>AI_CONFIG_IMPORT_MDL_COLORMAP</code></a></td><td><a href="#AI_CONFIG_PP_RRM_EXCLUDE_LIST"><code>AI_CONFIG_PP_RRM_EXCLUDE_LIST</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_KEEP_HIERARCHY"><code>AI_CONFIG_PP_PTV_KEEP_HIERARCHY</code></a></td><td><a href="#AI_CONFIG_PP_PTV_NORMALIZE"><code>AI_CONFIG_PP_PTV_NORMALIZE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION</code></a></td><td><a href="#AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION"><code>AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FD_REMOVE"><code>AI_CONFIG_PP_FD_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FD_CHECKAREA"><code>AI_CONFIG_PP_FD_CHECKAREA</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_OG_EXCLUDE_LIST"><code>AI_CONFIG_PP_OG_EXCLUDE_LIST</code></a></td><td><a href="#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT"><code>AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SLM_VERTEX_LIMIT"><code>AI_CONFIG_PP_SLM_VERTEX_LIMIT</code></a></td><td><a href="#AI_CONFIG_PP_LBW_MAX_WEIGHTS"><code>AI_CONFIG_PP_LBW_MAX_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_DB_THRESHOLD"><code>AI_CONFIG_PP_DB_THRESHOLD</code></a></td><td><a href="#AI_CONFIG_PP_DB_ALL_OR_NONE"><code>AI_CONFIG_PP_DB_ALL_OR_NONE</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_ICL_PTCACHE_SIZE"><code>AI_CONFIG_PP_ICL_PTCACHE_SIZE</code></a></td><td><a href="#AI_CONFIG_PP_RVC_FLAGS"><code>AI_CONFIG_PP_RVC_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_SBP_REMOVE"><code>AI_CONFIG_PP_SBP_REMOVE</code></a></td><td><a href="#AI_CONFIG_PP_FID_ANIM_ACCURACY"><code>AI_CONFIG_PP_FID_ANIM_ACCURACY</code></a></td></tr><tr><td><a href="#AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS"><code>AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS</code></a></td><td><a href="#AI_CONFIG_PP_TUV_EVALUATE"><code>AI_CONFIG_PP_TUV_EVALUATE</code></a></td></tr><tr><td><a href="#AI_CONFIG_FAVOUR_SPEED"><code>AI_CONFIG_FAVOUR_SPEED</code></a></td><td><a href="#AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER"><code>AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_MATERIALS"><code>AI_CONFIG_IMPORT_FBX_READ_MATERIALS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_TEXTURES"><code>AI_CONFIG_IMPORT_FBX_READ_TEXTURES</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_CAMERAS"><code>AI_CONFIG_IMPORT_FBX_READ_CAMERAS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_LIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_LIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_READ_WEIGHTS"><code>AI_CONFIG_IMPORT_FBX_READ_WEIGHTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_STRICT_MODE"><code>AI_CONFIG_IMPORT_FBX_STRICT_MODE</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS"><code>AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"><code>AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES</code></a></td><td><a href="#AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"><code>AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"><code>AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES</code></a></td><td><a href="#AI_CONFIG_FBX_CONVERT_TO_M"><code>AI_CONFIG_FBX_CONVERT_TO_M</code></a></td></tr><tr><td><a href="#AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"><code>AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER</code></a></td><td><a href="#AI_CONFIG_IMPORT_GLOBAL_KEYFRAME"><code>AI_CONFIG_IMPORT_GLOBAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_KEYFRAME"><code>AI_CONFIG_IMPORT_MD3_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD2_KEYFRAME"><code>AI_CONFIG_IMPORT_MD2_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_KEYFRAME"><code>AI_CONFIG_IMPORT_MDL_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDC_KEYFRAME"><code>AI_CONFIG_IMPORT_MDC_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_KEYFRAME"><code>AI_CONFIG_IMPORT_SMD_KEYFRAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_UNREAL_KEYFRAME"><code>AI_CONFIG_IMPORT_UNREAL_KEYFRAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES</code></a></td><td><a href="#AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"><code>AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST"><code>AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST</code></a></td><td><a href="#AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL"><code>AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION"><code>AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION</code></a></td><td><a href="#AI_CONFIG_UNREAL_HANDLE_FLAGS"><code>AI_CONFIG_UNREAL_HANDLE_FLAGS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_TER_MAKE_UVS"><code>AI_CONFIG_IMPORT_TER_MAKE_UVS</code></a></td><td><a href="#AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS"><code>AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART"><code>AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SKIN_NAME"><code>AI_CONFIG_IMPORT_MD3_SKIN_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_MD3_LOAD_SHADERS"><code>AI_CONFIG_IMPORT_MD3_LOAD_SHADERS</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD3_SHADER_SRC"><code>AI_CONFIG_IMPORT_MD3_SHADER_SRC</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY"><code>AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY</code></a></td><td><a href="#AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD"><code>AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_START"><code>AI_CONFIG_IMPORT_LWS_ANIM_START</code></a></td><td><a href="#AI_CONFIG_IMPORT_LWS_ANIM_END"><code>AI_CONFIG_IMPORT_LWS_ANIM_END</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IRR_ANIM_FPS"><code>AI_CONFIG_IMPORT_IRR_ANIM_FPS</code></a></td><td><a href="#AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE"><code>AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"><code>AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"><code>AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS"><code>AI_CONFIG_IMPORT_IFC_SKIP_CURVE_REPRESENTATIONS</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION"><code>AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE"><code>AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION"><code>AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION</code></a></td><td><a href="#AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION"><code>AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION</code></a></td></tr><tr><td><a href="#AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES"><code>AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES</code></a></td><td><a href="#AI_CONFIG_EXPORT_XFILE_64BIT"><code>AI_CONFIG_EXPORT_XFILE_64BIT</code></a></td></tr><tr><td><a href="#AI_CONFIG_EXPORT_POINT_CLOUDS"><code>AI_CONFIG_EXPORT_POINT_CLOUDS</code></a></td><td><a href="#AI_CONFIG_EXPORT_BLOB_NAME"><code>AI_CONFIG_EXPORT_BLOB_NAME</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_KEY"><code>AI_CONFIG_APP_SCALE_KEY</code></a></td></tr><tr><td><a href="#AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT"><code>AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT</code></a></td><td><a href="#AI_CONFIG_APP_SCALE_DEFAULT"><code>AI_CONFIG_APP_SCALE_DEFAULT</code></a></td></tr></table></dd>
<dd><code>value</code> - New value for the property</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiCreateQuaternionFromMatrix(long,long)">
<h3>naiCreateQuaternionFromMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiCreateQuaternionFromMatrix</span><wbr><span class="parameters">(long&nbsp;quat,
 long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiCreateQuaternionFromMatrix(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIMatrix3x3)"><code>CreateQuaternionFromMatrix</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiCreateQuaternionFromMatrix(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiCreateQuaternionFromMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiCreateQuaternionFromMatrix</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;quat,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</span></div>
<div class="block">Construct a quaternion from a 3x3 rotation matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>quat</code> - Receives the output quaternion.</dd>
<dd><code>mat</code> - Matrix to 'quaternionize'.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiDecomposeMatrix(long,long,long,long)">
<h3>naiDecomposeMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiDecomposeMatrix</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;rotation,
 long&nbsp;position)</span></div>
<div class="block">Unsafe version of: <a href="#aiDecomposeMatrix(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>DecomposeMatrix</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiDecomposeMatrix(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)">
<h3>aiDecomposeMatrix</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiDecomposeMatrix</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</span></div>
<div class="block">Decompose a transformation matrix into its rotational, translational and scaling components.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - Matrix to decompose</dd>
<dd><code>scaling</code> - Receives the scaling component</dd>
<dd><code>rotation</code> - Receives the rotational component</dd>
<dd><code>position</code> - Receives the translational component.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiTransposeMatrix4(long)">
<h3>naiTransposeMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiTransposeMatrix4</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiTransposeMatrix4(org.lwjgl.assimp.AIMatrix4x4)"><code>TransposeMatrix4</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiTransposeMatrix4(org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiTransposeMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiTransposeMatrix4</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</span></div>
<div class="block">Transpose a 4x4 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - Pointer to the matrix to be transposed</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiTransposeMatrix3(long)">
<h3>naiTransposeMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiTransposeMatrix3</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiTransposeMatrix3(org.lwjgl.assimp.AIMatrix3x3)"><code>TransposeMatrix3</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiTransposeMatrix3(org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiTransposeMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiTransposeMatrix3</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</span></div>
<div class="block">Transpose a 3x3 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - Pointer to the matrix to be transposed</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiTransformVecByMatrix3(long,long)">
<h3>naiTransformVecByMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiTransformVecByMatrix3</span><wbr><span class="parameters">(long&nbsp;vec,
 long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiTransformVecByMatrix3(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix3x3)"><code>TransformVecByMatrix3</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiTransformVecByMatrix3(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiTransformVecByMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiTransformVecByMatrix3</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;vec,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</span></div>
<div class="block">Transform a vector by a 3x3 matrix</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>vec</code> - Vector to be transformed.</dd>
<dd><code>mat</code> - Matrix to transform the vector with.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiTransformVecByMatrix4(long,long)">
<h3>naiTransformVecByMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiTransformVecByMatrix4</span><wbr><span class="parameters">(long&nbsp;vec,
 long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiTransformVecByMatrix4(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix4x4)"><code>TransformVecByMatrix4</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiTransformVecByMatrix4(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiTransformVecByMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiTransformVecByMatrix4</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;vec,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</span></div>
<div class="block">Transform a vector by a 4x4 matrix</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>vec</code> - Vector to be transformed.</dd>
<dd><code>mat</code> - Matrix to transform the vector with.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMultiplyMatrix4(long,long)">
<h3>naiMultiplyMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMultiplyMatrix4</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;src)</span></div>
<div class="block">Unsafe version of: <a href="#aiMultiplyMatrix4(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)"><code>MultiplyMatrix4</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMultiplyMatrix4(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiMultiplyMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMultiplyMatrix4</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;dst,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;src)</span></div>
<div class="block">Multiply two 4x4 matrices.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - First factor, receives result.</dd>
<dd><code>src</code> - Matrix to be multiplied with 'dst'.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMultiplyMatrix3(long,long)">
<h3>naiMultiplyMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMultiplyMatrix3</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;src)</span></div>
<div class="block">Unsafe version of: <a href="#aiMultiplyMatrix3(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)"><code>MultiplyMatrix3</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMultiplyMatrix3(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiMultiplyMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMultiplyMatrix3</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;dst,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;src)</span></div>
<div class="block">Multiply two 3x3 matrices.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - First factor, receives result.</dd>
<dd><code>src</code> - Matrix to be multiplied with 'dst'.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiIdentityMatrix3(long)">
<h3>naiIdentityMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiIdentityMatrix3</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiIdentityMatrix3(org.lwjgl.assimp.AIMatrix3x3)"><code>IdentityMatrix3</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiIdentityMatrix3(org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiIdentityMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiIdentityMatrix3</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</span></div>
<div class="block">Get a 3x3 identity matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - Matrix to receive its personal identity</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiIdentityMatrix4(long)">
<h3>naiIdentityMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiIdentityMatrix4</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiIdentityMatrix4(org.lwjgl.assimp.AIMatrix4x4)"><code>IdentityMatrix4</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiIdentityMatrix4(org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiIdentityMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiIdentityMatrix4</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</span></div>
<div class="block">Get a 4x4 identity matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - Matrix to receive its personal identity</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetImportFormatCount()">
<h3>aiGetImportFormatCount</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">aiGetImportFormatCount</span>()</div>
<div class="block">Returns the number of import file formats available in the current Assimp build. Use <a href="#aiGetImportFormatDescription(long)"><code>GetImportFormatDescription</code></a> to retrieve infos of a specific
 import format.</div>
</section>
</li>
<li>
<section class="detail" id="naiGetImportFormatDescription(long)">
<h3>naiGetImportFormatDescription</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiGetImportFormatDescription</span><wbr><span class="parameters">(long&nbsp;pIndex)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetImportFormatDescription(long)"><code>GetImportFormatDescription</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetImportFormatDescription(long)">
<h3>aiGetImportFormatDescription</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIImporterDesc.html" title="class in org.lwjgl.assimp">AIImporterDesc</a></span>&nbsp;<span class="element-name">aiGetImportFormatDescription</span><wbr><span class="parameters">(long&nbsp;pIndex)</span></div>
<div class="block">Returns a description of the nth import file format. Use <a href="#aiGetImportFormatCount()"><code>GetImportFormatCount</code></a> to learn how many import formats are supported.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pIndex</code> - Index of the import format to retrieve information for. Valid range is 0 to <a href="#aiGetImportFormatCount()"><code>GetImportFormatCount</code></a></dd>
<dt>Returns:</dt>
<dd>A description of that specific import format. <code>NULL</code> if <code>pIndex</code> is out of range.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2AreEqual(long,long)">
<h3>naiVector2AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiVector2AreEqual</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2AreEqual(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2AreEqual</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2AreEqual(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiVector2AreEqual</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;a,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;b)</span></div>
<div class="block">Check if 2D vectors are equal.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first vector to compare</dd>
<dd><code>b</code> - second vector to compare</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2AreEqualEpsilon(long,long,float)">
<h3>naiVector2AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiVector2AreEqualEpsilon</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2AreEqualEpsilon(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D,float)"><code>Vector2AreEqualEpsilon</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2AreEqualEpsilon(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D,float)">
<h3>aiVector2AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiVector2AreEqualEpsilon</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;a,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Check if 2D vectors are equal using epsilon.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first vector to compare</dd>
<dd><code>b</code> - second vector to compare</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2Add(long,long)">
<h3>naiVector2Add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2Add</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;src)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2Add(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2Add</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2Add(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2Add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2Add</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;src)</span></div>
<div class="block">Add 2D vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - first addend, receives result</dd>
<dd><code>src</code> - vector to be added to <code>dst</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2Subtract(long,long)">
<h3>naiVector2Subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2Subtract</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;src)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2Subtract(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2Subtract</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2Subtract(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2Subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2Subtract</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;src)</span></div>
<div class="block">Subtract 2D vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - minuend, receives result</dd>
<dd><code>src</code> - vector to be subtracted from <code>dst</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2Scale(long,float)">
<h3>naiVector2Scale</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2Scale</span><wbr><span class="parameters">(long&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2Scale(org.lwjgl.assimp.AIVector2D,float)"><code>Vector2Scale</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2Scale(org.lwjgl.assimp.AIVector2D,float)">
<h3>aiVector2Scale</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2Scale</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Multiply a 2D vector by a scalar.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector to be scaled by <code>s</code></dd>
<dd><code>s</code> - scale factor</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2SymMul(long,long)">
<h3>naiVector2SymMul</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2SymMul</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;other)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2SymMul(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2SymMul</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2SymMul(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2SymMul</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2SymMul</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;other)</span></div>
<div class="block">Multiply each component of a 2D vector with the components of another vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - first vector, receives result</dd>
<dd><code>other</code> - second vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2DivideByScalar(long,float)">
<h3>naiVector2DivideByScalar</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2DivideByScalar</span><wbr><span class="parameters">(long&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2DivideByScalar(org.lwjgl.assimp.AIVector2D,float)"><code>Vector2DivideByScalar</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2DivideByScalar(org.lwjgl.assimp.AIVector2D,float)">
<h3>aiVector2DivideByScalar</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2DivideByScalar</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Divide a 2D vector by a scalar.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector to be divided by <code>s</code></dd>
<dd><code>s</code> - scalar divisor</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2DivideByVector(long,long)">
<h3>naiVector2DivideByVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2DivideByVector</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2DivideByVector(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2DivideByVector</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2DivideByVector(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2DivideByVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2DivideByVector</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</span></div>
<div class="block">Divide each component of a 2D vector by the components of another vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector as the dividend</dd>
<dd><code>v</code> - vector as the divisor</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2Length(long)">
<h3>naiVector2Length</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiVector2Length</span><wbr><span class="parameters">(long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2Length(org.lwjgl.assimp.AIVector2D)"><code>Vector2Length</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2Length(org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2Length</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiVector2Length</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</span></div>
<div class="block">Get the length of a 2D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector to evaluate</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2SquareLength(long)">
<h3>naiVector2SquareLength</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiVector2SquareLength</span><wbr><span class="parameters">(long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2SquareLength(org.lwjgl.assimp.AIVector2D)"><code>Vector2SquareLength</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2SquareLength(org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2SquareLength</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiVector2SquareLength</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</span></div>
<div class="block">Get the squared length of a 2D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector to evaluate</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2Negate(long)">
<h3>naiVector2Negate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2Negate</span><wbr><span class="parameters">(long&nbsp;dst)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2Negate(org.lwjgl.assimp.AIVector2D)"><code>Vector2Negate</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2Negate(org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2Negate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2Negate</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;dst)</span></div>
<div class="block">Negate a 2D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector to be negated</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2DotProduct(long,long)">
<h3>naiVector2DotProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiVector2DotProduct</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2DotProduct(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)"><code>Vector2DotProduct</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2DotProduct(org.lwjgl.assimp.AIVector2D,org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2DotProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiVector2DotProduct</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;a,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;b)</span></div>
<div class="block">Get the dot product of 2D vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first vector</dd>
<dd><code>b</code> - second vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector2Normalize(long)">
<h3>naiVector2Normalize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector2Normalize</span><wbr><span class="parameters">(long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector2Normalize(org.lwjgl.assimp.AIVector2D)"><code>Vector2Normalize</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector2Normalize(org.lwjgl.assimp.AIVector2D)">
<h3>aiVector2Normalize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector2Normalize</span><wbr><span class="parameters">(<a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;v)</span></div>
<div class="block">Normalize a 2D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector to normalize</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3AreEqual(long,long)">
<h3>naiVector3AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiVector3AreEqual</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3AreEqual(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3AreEqual</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3AreEqual(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiVector3AreEqual</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</span></div>
<div class="block">Check if 3D vectors are equal.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first vector to compare</dd>
<dd><code>b</code> - second vector to compare</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3AreEqualEpsilon(long,long,float)">
<h3>naiVector3AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiVector3AreEqualEpsilon</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3AreEqualEpsilon(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,float)"><code>Vector3AreEqualEpsilon</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3AreEqualEpsilon(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,float)">
<h3>aiVector3AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiVector3AreEqualEpsilon</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Check if 3D vectors are equal using epsilon.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first vector to compare</dd>
<dd><code>b</code> - second vector to compare</dd>
<dd><code>epsilon</code> - epsilon</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3LessThan(long,long)">
<h3>naiVector3LessThan</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiVector3LessThan</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3LessThan(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3LessThan</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3LessThan(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3LessThan</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiVector3LessThan</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</span></div>
<div class="block">Check if vector <code>a</code> is less than vector <code>b</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first vector to compare</dd>
<dd><code>b</code> - second vector to compare</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3Add(long,long)">
<h3>naiVector3Add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3Add</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;src)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3Add(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3Add</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3Add(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3Add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3Add</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;src)</span></div>
<div class="block">Add 3D vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - first addend, receives result</dd>
<dd><code>src</code> - vector to be added to <code>dst</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3Subtract(long,long)">
<h3>naiVector3Subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3Subtract</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;src)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3Subtract(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3Subtract</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3Subtract(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3Subtract</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3Subtract</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;src)</span></div>
<div class="block">Subtract 3D vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - minuend, receives result</dd>
<dd><code>src</code> - vector to be subtracted from <code>dst</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3Scale(long,float)">
<h3>naiVector3Scale</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3Scale</span><wbr><span class="parameters">(long&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3Scale(org.lwjgl.assimp.AIVector3D,float)"><code>Vector3Scale</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3Scale(org.lwjgl.assimp.AIVector3D,float)">
<h3>aiVector3Scale</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3Scale</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Multiply a 3D vector by a scalar.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector to be scaled by <code>s</code></dd>
<dd><code>s</code> - scale factor</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3SymMul(long,long)">
<h3>naiVector3SymMul</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3SymMul</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;other)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3SymMul(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3SymMul</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3SymMul(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3SymMul</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3SymMul</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;other)</span></div>
<div class="block">Multiply each component of a 3D vector with the components of another vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - first vector, receives result</dd>
<dd><code>other</code> - second vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3DivideByScalar(long,float)">
<h3>naiVector3DivideByScalar</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3DivideByScalar</span><wbr><span class="parameters">(long&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3DivideByScalar(org.lwjgl.assimp.AIVector3D,float)"><code>Vector3DivideByScalar</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3DivideByScalar(org.lwjgl.assimp.AIVector3D,float)">
<h3>aiVector3DivideByScalar</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3DivideByScalar</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 float&nbsp;s)</span></div>
<div class="block">Divide a 3D vector by a scalar.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector to be divided by <code>s</code></dd>
<dd><code>s</code> - scalar divisor</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3DivideByVector(long,long)">
<h3>naiVector3DivideByVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3DivideByVector</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3DivideByVector(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3DivideByVector</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3DivideByVector(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3DivideByVector</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3DivideByVector</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</span></div>
<div class="block">Divide each component of a 3D vector by the components of another vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector as the dividend</dd>
<dd><code>v</code> - vector as the divisor</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3Length(long)">
<h3>naiVector3Length</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiVector3Length</span><wbr><span class="parameters">(long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3Length(org.lwjgl.assimp.AIVector3D)"><code>Vector3Length</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3Length(org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3Length</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiVector3Length</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</span></div>
<div class="block">Get the length of a 3D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector to evaluate</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3SquareLength(long)">
<h3>naiVector3SquareLength</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiVector3SquareLength</span><wbr><span class="parameters">(long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3SquareLength(org.lwjgl.assimp.AIVector3D)"><code>Vector3SquareLength</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3SquareLength(org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3SquareLength</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiVector3SquareLength</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</span></div>
<div class="block">Get the squared length of a 3D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector to evaluate</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3Negate(long)">
<h3>naiVector3Negate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3Negate</span><wbr><span class="parameters">(long&nbsp;dst)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3Negate(org.lwjgl.assimp.AIVector3D)"><code>Vector3Negate</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3Negate(org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3Negate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3Negate</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst)</span></div>
<div class="block">Negate a 3D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector to be negated</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3DotProduct(long,long)">
<h3>naiVector3DotProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiVector3DotProduct</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3DotProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3DotProduct</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3DotProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3DotProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiVector3DotProduct</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</span></div>
<div class="block">Get the dot product of 3D vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first vector</dd>
<dd><code>b</code> - second vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3CrossProduct(long,long,long)">
<h3>naiVector3CrossProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3CrossProduct</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3CrossProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Vector3CrossProduct</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3CrossProduct(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3CrossProduct</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3CrossProduct</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;dst,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;a,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;b)</span></div>
<div class="block">Get cross product of 3D vectors.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - vector to receive the result</dd>
<dd><code>a</code> - first vector</dd>
<dd><code>b</code> - second vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3Normalize(long)">
<h3>naiVector3Normalize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3Normalize</span><wbr><span class="parameters">(long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3Normalize(org.lwjgl.assimp.AIVector3D)"><code>Vector3Normalize</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3Normalize(org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3Normalize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3Normalize</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</span></div>
<div class="block">Normalize a 3D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector to normalize</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3NormalizeSafe(long)">
<h3>naiVector3NormalizeSafe</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3NormalizeSafe</span><wbr><span class="parameters">(long&nbsp;v)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3NormalizeSafe(org.lwjgl.assimp.AIVector3D)"><code>Vector3NormalizeSafe</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3NormalizeSafe(org.lwjgl.assimp.AIVector3D)">
<h3>aiVector3NormalizeSafe</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3NormalizeSafe</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v)</span></div>
<div class="block">Check for division by zero and normalize a 3D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - vector to normalize</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiVector3RotateByQuaternion(long,long)">
<h3>naiVector3RotateByQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiVector3RotateByQuaternion</span><wbr><span class="parameters">(long&nbsp;v,
 long&nbsp;q)</span></div>
<div class="block">Unsafe version of: <a href="#aiVector3RotateByQuaternion(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion)"><code>Vector3RotateByQuaternion</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiVector3RotateByQuaternion(org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion)">
<h3>aiVector3RotateByQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiVector3RotateByQuaternion</span><wbr><span class="parameters">(<a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;v,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</span></div>
<div class="block">Rotate a 3D vector by a quaternion.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - the vector to rotate by <code>q</code></dd>
<dd><code>q</code> - quaternion to use to rotate <code>v</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3FromMatrix4(long,long)">
<h3>naiMatrix3FromMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix3FromMatrix4</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3FromMatrix4(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix3FromMatrix4</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3FromMatrix4(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiMatrix3FromMatrix4</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix3FromMatrix4</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;dst,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</span></div>
<div class="block">Construct a 3x3 matrix from a 4x4 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - receives the output matrix</dd>
<dd><code>mat</code> - the 4x4 matrix to use</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3FromQuaternion(long,long)">
<h3>naiMatrix3FromQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix3FromQuaternion</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;q)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3FromQuaternion(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIQuaternion)"><code>Matrix3FromQuaternion</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3FromQuaternion(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIQuaternion)">
<h3>aiMatrix3FromQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix3FromQuaternion</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</span></div>
<div class="block">Construct a 3x3 matrix from a quaternion.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>q</code> - the quaternion matrix to use</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3AreEqual(long,long)">
<h3>naiMatrix3AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiMatrix3AreEqual</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3AreEqual(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix3AreEqual</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3AreEqual(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiMatrix3AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiMatrix3AreEqual</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;a,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;b)</span></div>
<div class="block">Check if 3x3 matrices are equal.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first matrix to compare</dd>
<dd><code>b</code> - second matrix to compare</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3AreEqualEpsilon(long,long,float)">
<h3>naiMatrix3AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiMatrix3AreEqualEpsilon</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3AreEqualEpsilon(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3,float)"><code>Matrix3AreEqualEpsilon</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3AreEqualEpsilon(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIMatrix3x3,float)">
<h3>aiMatrix3AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiMatrix3AreEqualEpsilon</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;a,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Check if 3x3 matrices are equal.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first matrix to compare</dd>
<dd><code>b</code> - second matrix to compare</dd>
<dd><code>epsilon</code> - epsilon</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3Inverse(long)">
<h3>naiMatrix3Inverse</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix3Inverse</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3Inverse(org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix3Inverse</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3Inverse(org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiMatrix3Inverse</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix3Inverse</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</span></div>
<div class="block">Invert a 3x3 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to invert</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3Determinant(long)">
<h3>naiMatrix3Determinant</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiMatrix3Determinant</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3Determinant(org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix3Determinant</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3Determinant(org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiMatrix3Determinant</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiMatrix3Determinant</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</span></div>
<div class="block">Get the determinant of a 3x3 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to get the determinant from</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3RotationZ(long,float)">
<h3>naiMatrix3RotationZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix3RotationZ</span><wbr><span class="parameters">(long&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3RotationZ(org.lwjgl.assimp.AIMatrix3x3,float)"><code>Matrix3RotationZ</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3RotationZ(org.lwjgl.assimp.AIMatrix3x3,float)">
<h3>aiMatrix3RotationZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix3RotationZ</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Get a 3x3 rotation matrix around the Z axis.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>angle</code> - rotation angle, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3FromRotationAroundAxis(long,long,float)">
<h3>naiMatrix3FromRotationAroundAxis</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix3FromRotationAroundAxis</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;axis,
 float&nbsp;angle)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,float)"><code>Matrix3FromRotationAroundAxis</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,float)">
<h3>aiMatrix3FromRotationAroundAxis</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix3FromRotationAroundAxis</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float&nbsp;angle)</span></div>
<div class="block">Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>axis</code> - rotation axis, should be a normalized vector</dd>
<dd><code>angle</code> - rotation angle, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3Translation(long,long)">
<h3>naiMatrix3Translation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix3Translation</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;translation)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3Translation(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector2D)"><code>Matrix3Translation</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3Translation(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector2D)">
<h3>aiMatrix3Translation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix3Translation</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIVector2D.html" title="class in org.lwjgl.assimp">AIVector2D</a>&nbsp;translation)</span></div>
<div class="block">Get a 3x3 translation matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>translation</code> - the translation vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix3FromTo(long,long,long)">
<h3>naiMatrix3FromTo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix3FromTo</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;from,
 long&nbsp;to)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix3FromTo(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Matrix3FromTo</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix3FromTo(org.lwjgl.assimp.AIMatrix3x3,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix3FromTo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix3FromTo</span><wbr><span class="parameters">(<a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;from,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;to)</span></div>
<div class="block">Create a 3x3 matrix that rotates one vector to another vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>from</code> - vector to rotate from</dd>
<dd><code>to</code> - vector to rotate to</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4FromMatrix3(long,long)">
<h3>naiMatrix4FromMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4FromMatrix3</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4FromMatrix3(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix3x3)"><code>Matrix4FromMatrix3</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4FromMatrix3(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix3x3)">
<h3>aiMatrix4FromMatrix3</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4FromMatrix3</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;dst,
 <a href="AIMatrix3x3.html" title="class in org.lwjgl.assimp">AIMatrix3x3</a>&nbsp;mat)</span></div>
<div class="block">Construct a 4x4 matrix from a 3x3 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - receives the output matrix</dd>
<dd><code>mat</code> - the 3x3 matrix to use</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4FromScalingQuaternionPosition(long,long,long,long)">
<h3>naiMatrix4FromScalingQuaternionPosition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4FromScalingQuaternionPosition</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;rotation,
 long&nbsp;position)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4FromScalingQuaternionPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>Matrix4FromScalingQuaternionPosition</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4FromScalingQuaternionPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4FromScalingQuaternionPosition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4FromScalingQuaternionPosition</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</span></div>
<div class="block">Construct a 4x4 matrix from scaling, rotation and position.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>scaling</code> - the scaling for the x,y,z axes</dd>
<dd><code>rotation</code> - the rotation as a hamilton quaternion</dd>
<dd><code>position</code> - the position for the x,y,z axes</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4Add(long,long)">
<h3>naiMatrix4Add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4Add</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;src)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4Add(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4Add</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4Add(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiMatrix4Add</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4Add</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;dst,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;src)</span></div>
<div class="block">Add 4x4 matrices.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - first addend, receives result</dd>
<dd><code>src</code> - matrix to be added to <code>dst</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4AreEqual(long,long)">
<h3>naiMatrix4AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiMatrix4AreEqual</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4AreEqual(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4AreEqual</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4AreEqual(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiMatrix4AreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiMatrix4AreEqual</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;a,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;b)</span></div>
<div class="block">Check if 4x4 matrices are equal.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first matrix to compare</dd>
<dd><code>b</code> - second matrix to compare</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4AreEqualEpsilon(long,long,float)">
<h3>naiMatrix4AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiMatrix4AreEqualEpsilon</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4AreEqualEpsilon(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4AreEqualEpsilon</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4AreEqualEpsilon(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIMatrix4x4,float)">
<h3>aiMatrix4AreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiMatrix4AreEqualEpsilon</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;a,
 <a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Check if 4x4 matrices are equal.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first matrix to compare</dd>
<dd><code>b</code> - second matrix to compare</dd>
<dd><code>epsilon</code> - epsilon</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4Inverse(long)">
<h3>naiMatrix4Inverse</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4Inverse</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4Inverse(org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4Inverse</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4Inverse(org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiMatrix4Inverse</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4Inverse</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</span></div>
<div class="block">Invert a 4x4 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to invert</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4Determinant(long)">
<h3>naiMatrix4Determinant</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">naiMatrix4Determinant</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4Determinant(org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4Determinant</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4Determinant(org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiMatrix4Determinant</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">aiMatrix4Determinant</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</span></div>
<div class="block">Get the determinant of a 4x4 matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to get the determinant from</dd>
<dt>Returns:</dt>
<dd>the determinant of the matrix</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4IsIdentity(long)">
<h3>naiMatrix4IsIdentity</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiMatrix4IsIdentity</span><wbr><span class="parameters">(long&nbsp;mat)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4IsIdentity(org.lwjgl.assimp.AIMatrix4x4)"><code>Matrix4IsIdentity</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4IsIdentity(org.lwjgl.assimp.AIMatrix4x4)">
<h3>aiMatrix4IsIdentity</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiMatrix4IsIdentity</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat)</span></div>
<div class="block">Returns true of the matrix is the identity matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to get the determinant from</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4DecomposeIntoScalingEulerAnglesPosition(long,long,long,long)">
<h3>naiMatrix4DecomposeIntoScalingEulerAnglesPosition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4DecomposeIntoScalingEulerAnglesPosition</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;rotation,
 long&nbsp;position)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4DecomposeIntoScalingEulerAnglesPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeIntoScalingEulerAnglesPosition</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4DecomposeIntoScalingEulerAnglesPosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4DecomposeIntoScalingEulerAnglesPosition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4DecomposeIntoScalingEulerAnglesPosition</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</span></div>
<div class="block">Decompose a transformation matrix into its scaling, rotational as euler angles, and translational components.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to decompose</dd>
<dd><code>scaling</code> - receives the output scaling for the x,y,z axes</dd>
<dd><code>rotation</code> - receives the output rotation as a Euler angles</dd>
<dd><code>position</code> - receives the output position for the x,y,z axes</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4DecomposeIntoScalingAxisAnglePosition(long,long,long,long,long)">
<h3>naiMatrix4DecomposeIntoScalingAxisAnglePosition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4DecomposeIntoScalingAxisAnglePosition</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;scaling,
 long&nbsp;axis,
 long&nbsp;angle,
 long&nbsp;position)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,java.nio.FloatBuffer,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeIntoScalingAxisAnglePosition</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,java.nio.FloatBuffer,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4DecomposeIntoScalingAxisAnglePosition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4DecomposeIntoScalingAxisAnglePosition</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;angle,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</span></div>
<div class="block">Decompose a transformation matrix into its scaling, rotational split into an axis and rotational angle, and it's translational components.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to decompose</dd>
<dd><code>scaling</code> - receives the rotational component</dd>
<dd><code>axis</code> - receives the output rotation axis</dd>
<dd><code>angle</code> - receives the output rotation angle</dd>
<dd><code>position</code> - receives the output position for the x,y,z axes</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4DecomposeNoScaling(long,long,long)">
<h3>naiMatrix4DecomposeNoScaling</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4DecomposeNoScaling</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;rotation,
 long&nbsp;position)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4DecomposeNoScaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeNoScaling</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4DecomposeNoScaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4DecomposeNoScaling</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4DecomposeNoScaling</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;rotation,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</span></div>
<div class="block">Decompose a transformation matrix into its rotational and translational components.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - matrix to decompose</dd>
<dd><code>rotation</code> - receives the rotational component</dd>
<dd><code>position</code> - receives the translational component</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4FromEulerAngles(long,float,float,float)">
<h3>naiMatrix4FromEulerAngles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4FromEulerAngles</span><wbr><span class="parameters">(long&nbsp;mat,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4FromEulerAngles(org.lwjgl.assimp.AIMatrix4x4,float,float,float)"><code>Matrix4FromEulerAngles</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4FromEulerAngles(org.lwjgl.assimp.AIMatrix4x4,float,float,float)">
<h3>aiMatrix4FromEulerAngles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4FromEulerAngles</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</span></div>
<div class="block">Creates a 4x4 matrix from a set of euler angles.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>x</code> - rotation angle for the x-axis, in radians</dd>
<dd><code>y</code> - rotation angle for the y-axis, in radians</dd>
<dd><code>z</code> - rotation angle for the z-axis, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4RotationX(long,float)">
<h3>naiMatrix4RotationX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4RotationX</span><wbr><span class="parameters">(long&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4RotationX(org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4RotationX</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4RotationX(org.lwjgl.assimp.AIMatrix4x4,float)">
<h3>aiMatrix4RotationX</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4RotationX</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Get a 4x4 rotation matrix around the X axis.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>angle</code> - rotation angle, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4RotationY(long,float)">
<h3>naiMatrix4RotationY</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4RotationY</span><wbr><span class="parameters">(long&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4RotationY(org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4RotationY</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4RotationY(org.lwjgl.assimp.AIMatrix4x4,float)">
<h3>aiMatrix4RotationY</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4RotationY</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Get a 4x4 rotation matrix around the Y axis.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>angle</code> - rotation angle, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4RotationZ(long,float)">
<h3>naiMatrix4RotationZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4RotationZ</span><wbr><span class="parameters">(long&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4RotationZ(org.lwjgl.assimp.AIMatrix4x4,float)"><code>Matrix4RotationZ</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4RotationZ(org.lwjgl.assimp.AIMatrix4x4,float)">
<h3>aiMatrix4RotationZ</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4RotationZ</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 float&nbsp;angle)</span></div>
<div class="block">Get a 4x4 rotation matrix around the Z axis.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>angle</code> - rotation angle, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4FromRotationAroundAxis(long,long,float)">
<h3>naiMatrix4FromRotationAroundAxis</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4FromRotationAroundAxis</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;axis,
 float&nbsp;angle)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,float)"><code>Matrix4FromRotationAroundAxis</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4FromRotationAroundAxis(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,float)">
<h3>aiMatrix4FromRotationAroundAxis</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4FromRotationAroundAxis</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float&nbsp;angle)</span></div>
<div class="block">Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>axis</code> - rotation axis, should be a normalized vector</dd>
<dd><code>angle</code> - rotation angle, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4Translation(long,long)">
<h3>naiMatrix4Translation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4Translation</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;translation)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4Translation(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)"><code>Matrix4Translation</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4Translation(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4Translation</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4Translation</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;translation)</span></div>
<div class="block">Get a 4x4 translation matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>translation</code> - the translation vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4Scaling(long,long)">
<h3>naiMatrix4Scaling</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4Scaling</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;scaling)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4Scaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)"><code>Matrix4Scaling</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4Scaling(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4Scaling</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4Scaling</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling)</span></div>
<div class="block">Get a 4x4 scaling matrix.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>scaling</code> - the scaling vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiMatrix4FromTo(long,long,long)">
<h3>naiMatrix4FromTo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiMatrix4FromTo</span><wbr><span class="parameters">(long&nbsp;mat,
 long&nbsp;from,
 long&nbsp;to)</span></div>
<div class="block">Unsafe version of: <a href="#aiMatrix4FromTo(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)"><code>Matrix4FromTo</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4FromTo(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4FromTo</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4FromTo</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;from,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;to)</span></div>
<div class="block">Create a 4x4 matrix that rotates one vector to another vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>mat</code> - receives the output matrix</dd>
<dd><code>from</code> - vector to rotate from</dd>
<dd><code>to</code> - vector to rotate to</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionFromEulerAngles(long,float,float,float)">
<h3>naiQuaternionFromEulerAngles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiQuaternionFromEulerAngles</span><wbr><span class="parameters">(long&nbsp;q,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionFromEulerAngles(org.lwjgl.assimp.AIQuaternion,float,float,float)"><code>QuaternionFromEulerAngles</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionFromEulerAngles(org.lwjgl.assimp.AIQuaternion,float,float,float)">
<h3>aiQuaternionFromEulerAngles</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiQuaternionFromEulerAngles</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q,
 float&nbsp;x,
 float&nbsp;y,
 float&nbsp;z)</span></div>
<div class="block">Create a Quaternion from euler angles.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - receives the output quaternion</dd>
<dd><code>x</code> - rotation angle for the x-axis, in radians</dd>
<dd><code>y</code> - rotation angle for the y-axis, in radians</dd>
<dd><code>z</code> - rotation angle for the z-axis, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionFromAxisAngle(long,long,float)">
<h3>naiQuaternionFromAxisAngle</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiQuaternionFromAxisAngle</span><wbr><span class="parameters">(long&nbsp;q,
 long&nbsp;axis,
 float&nbsp;angle)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionFromAxisAngle(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D,float)"><code>QuaternionFromAxisAngle</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionFromAxisAngle(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D,float)">
<h3>aiQuaternionFromAxisAngle</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiQuaternionFromAxisAngle</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float&nbsp;angle)</span></div>
<div class="block">Create a Quaternion from an axis angle pair.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - receives the output quaternion</dd>
<dd><code>axis</code> - the orientation axis</dd>
<dd><code>angle</code> - the rotation angle, in radians</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionFromNormalizedQuaternion(long,long)">
<h3>naiQuaternionFromNormalizedQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiQuaternionFromNormalizedQuaternion</span><wbr><span class="parameters">(long&nbsp;q,
 long&nbsp;normalized)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionFromNormalizedQuaternion(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)"><code>QuaternionFromNormalizedQuaternion</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionFromNormalizedQuaternion(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIVector3D)">
<h3>aiQuaternionFromNormalizedQuaternion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiQuaternionFromNormalizedQuaternion</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;normalized)</span></div>
<div class="block">Create a Quaternion from a normalized quaternion stored in a 3D vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - receives the output quaternion</dd>
<dd><code>normalized</code> - the vector that stores the quaternion</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionAreEqual(long,long)">
<h3>naiQuaternionAreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiQuaternionAreEqual</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionAreEqual(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)"><code>QuaternionAreEqual</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionAreEqual(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)">
<h3>aiQuaternionAreEqual</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiQuaternionAreEqual</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;a,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;b)</span></div>
<div class="block">Check if quaternions are equal.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first quaternion to compare</dd>
<dd><code>b</code> - second quaternion to compare</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionAreEqualEpsilon(long,long,float)">
<h3>naiQuaternionAreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiQuaternionAreEqualEpsilon</span><wbr><span class="parameters">(long&nbsp;a,
 long&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionAreEqualEpsilon(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)"><code>QuaternionAreEqualEpsilon</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionAreEqualEpsilon(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)">
<h3>aiQuaternionAreEqualEpsilon</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">aiQuaternionAreEqualEpsilon</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;a,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;b,
 float&nbsp;epsilon)</span></div>
<div class="block">Check if quaternions are equal using epsilon.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>a</code> - first quaternion to compare</dd>
<dd><code>b</code> - second quaternion to compare</dd>
<dd><code>epsilon</code> - epsilon</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionNormalize(long)">
<h3>naiQuaternionNormalize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiQuaternionNormalize</span><wbr><span class="parameters">(long&nbsp;q)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionNormalize(org.lwjgl.assimp.AIQuaternion)"><code>QuaternionNormalize</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionNormalize(org.lwjgl.assimp.AIQuaternion)">
<h3>aiQuaternionNormalize</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiQuaternionNormalize</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</span></div>
<div class="block">Normalize a quaternion.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - quaternion to normalize</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionConjugate(long)">
<h3>naiQuaternionConjugate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiQuaternionConjugate</span><wbr><span class="parameters">(long&nbsp;q)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionConjugate(org.lwjgl.assimp.AIQuaternion)"><code>QuaternionConjugate</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionConjugate(org.lwjgl.assimp.AIQuaternion)">
<h3>aiQuaternionConjugate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiQuaternionConjugate</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</span></div>
<div class="block">Compute quaternion conjugate.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>q</code> - quaternion to compute conjugate, receives the output quaternion</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionMultiply(long,long)">
<h3>naiQuaternionMultiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiQuaternionMultiply</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;q)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionMultiply(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)"><code>QuaternionMultiply</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionMultiply(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion)">
<h3>aiQuaternionMultiply</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiQuaternionMultiply</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;dst,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;q)</span></div>
<div class="block">Multiply quaternions.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - first quaternion, receives the output quaternion</dd>
<dd><code>q</code> - second quaternion</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiQuaternionInterpolate(long,long,long,float)">
<h3>naiQuaternionInterpolate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">naiQuaternionInterpolate</span><wbr><span class="parameters">(long&nbsp;dst,
 long&nbsp;start,
 long&nbsp;end,
 float&nbsp;factor)</span></div>
<div class="block">Unsafe version of: <a href="#aiQuaternionInterpolate(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)"><code>QuaternionInterpolate</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiQuaternionInterpolate(org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,org.lwjgl.assimp.AIQuaternion,float)">
<h3>aiQuaternionInterpolate</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiQuaternionInterpolate</span><wbr><span class="parameters">(<a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;dst,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;start,
 <a href="AIQuaternion.html" title="class in org.lwjgl.assimp">AIQuaternion</a>&nbsp;end,
 float&nbsp;factor)</span></div>
<div class="block">Performs a spherical interpolation between two quaternions.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dst</code> - receives the quaternion resulting from the interpolation</dd>
<dd><code>start</code> - quaternion when <code>factor == 0</code></dd>
<dd><code>end</code> - quaternion when <code>factor == 1</code></dd>
<dd><code>factor</code> - interpolation factor between 0 and 1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetImporterDesc(long)">
<h3>naiGetImporterDesc</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiGetImporterDesc</span><wbr><span class="parameters">(long&nbsp;extension)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetImporterDesc(java.nio.ByteBuffer)"><code>GetImporterDesc</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetImporterDesc(java.nio.ByteBuffer)">
<h3>aiGetImporterDesc</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIImporterDesc.html" title="class in org.lwjgl.assimp">AIImporterDesc</a></span>&nbsp;<span class="element-name">aiGetImporterDesc</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;extension)</span></div>
<div class="block">Returns the Importer description for a given extension.
 
 <p>Will return a <code>NULL</code>-pointer if no assigned importer desc. was found for the given extension.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>extension</code> - The extension to look for</dd>
<dt>Returns:</dt>
<dd>A pointer showing to the ImporterDesc, <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetImporterDesc(java.lang.CharSequence)">
<h3>aiGetImporterDesc</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="AIImporterDesc.html" title="class in org.lwjgl.assimp">AIImporterDesc</a></span>&nbsp;<span class="element-name">aiGetImporterDesc</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;extension)</span></div>
<div class="block">Returns the Importer description for a given extension.
 
 <p>Will return a <code>NULL</code>-pointer if no assigned importer desc. was found for the given extension.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>extension</code> - The extension to look for</dd>
<dt>Returns:</dt>
<dd>A pointer showing to the ImporterDesc, <a href="AIImporterDesc.html" title="class in org.lwjgl.assimp"><code>AIImporterDesc</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiTextureTypeToString(int)">
<h3>naiTextureTypeToString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiTextureTypeToString</span><wbr><span class="parameters">(int&nbsp;in)</span></div>
<div class="block">Unsafe version of: <a href="#aiTextureTypeToString(int)"><code>TextureTypeToString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiTextureTypeToString(int)">
<h3>aiTextureTypeToString</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">aiTextureTypeToString</span><wbr><span class="parameters">(int&nbsp;in)</span></div>
<div class="block">Get a string for a given <code>aiTextureType</code>.</div>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialProperty(long,long,int,int,long)">
<h3>naiGetMaterialProperty</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialProperty</span><wbr><span class="parameters">(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;mPropOut)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.PointerBuffer)"><code>GetMaterialProperty</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.PointerBuffer)">
<h3>aiGetMaterialProperty</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialProperty</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</span></div>
<div class="block">Retrieve a material property with a specific key from the material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>mPropOut</code> - Pointer to receive a pointer to a valid <a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a> structure or <code>NULL</code> if the key has not been found.</dd>
<dt>Returns:</dt>
<dd>Return_xxx values.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.PointerBuffer)">
<h3>aiGetMaterialProperty</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialProperty</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</span></div>
<div class="block">Retrieve a material property with a specific key from the material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>mPropOut</code> - Pointer to receive a pointer to a valid <a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a> structure or <code>NULL</code> if the key has not been found.</dd>
<dt>Returns:</dt>
<dd>Return_xxx values.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,org.lwjgl.PointerBuffer)">
<h3>aiGetMaterialProperty</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialProperty</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</span></div>
<div class="block">Retrieve a material property with a specific key from the material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>mPropOut</code> - Pointer to receive a pointer to a valid <a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a> structure or <code>NULL</code> if the key has not been found.</dd>
<dt>Returns:</dt>
<dd>Return_xxx values.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialProperty(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,org.lwjgl.PointerBuffer)">
<h3>aiGetMaterialProperty</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialProperty</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 <a href="../PointerBuffer.html" title="class in org.lwjgl">PointerBuffer</a>&nbsp;mPropOut)</span></div>
<div class="block">Retrieve a material property with a specific key from the material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>mPropOut</code> - Pointer to receive a pointer to a valid <a href="AIMaterialProperty.html" title="class in org.lwjgl.assimp"><code>AIMaterialProperty</code></a> structure or <code>NULL</code> if the key has not been found.</dd>
<dt>Returns:</dt>
<dd>Return_xxx values.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialFloatArray(long,long,int,int,long,long)">
<h3>naiGetMaterialFloatArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialFloatArray</span><wbr><span class="parameters">(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut,
 long&nbsp;pMax)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)"><code>GetMaterialFloatArray</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMax</code> - Specifies the size of the given buffer, in float's. Receives the number of values (not bytes!) read.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)">
<h3>aiGetMaterialFloatArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialFloatArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;pOut,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</span></div>
<div class="block">Retrieve an array of float values with a specific key from the material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a buffer to receive the result.</dd>
<dd><code>pMax</code> - Specifies the size of the given buffer, in float's. Receives the number of values (not bytes!) read.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output arrays remains unmodified and <code>pMax</code> is set to 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)">
<h3>aiGetMaterialFloatArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialFloatArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;pOut,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</span></div>
<div class="block">Retrieve an array of float values with a specific key from the material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a buffer to receive the result.</dd>
<dd><code>pMax</code> - Specifies the size of the given buffer, in float's. Receives the number of values (not bytes!) read.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output arrays remains unmodified and <code>pMax</code> is set to 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialIntegerArray(long,long,int,int,long,long)">
<h3>naiGetMaterialIntegerArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialIntegerArray</span><wbr><span class="parameters">(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut,
 long&nbsp;pMax)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialIntegerArray</code></a></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMax</code> - Specifies the size of the given buffer, in int's. Receives the number of values (not bytes!) read.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)">
<h3>aiGetMaterialIntegerArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialIntegerArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pOut,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</span></div>
<div class="block">Retrieve an array of integer values with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a buffer to receive the result.</dd>
<dd><code>pMax</code> - Specifies the size of the given buffer, in int's. Receives the number of values (not bytes!) read.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output arrays remains unmodified and <code>pMax</code> is set to 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,java.nio.IntBuffer,java.nio.IntBuffer)">
<h3>aiGetMaterialIntegerArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialIntegerArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pOut,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;pMax)</span></div>
<div class="block">Retrieve an array of integer values with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a buffer to receive the result.</dd>
<dd><code>pMax</code> - Specifies the size of the given buffer, in int's. Receives the number of values (not bytes!) read.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output arrays remains unmodified and <code>pMax</code> is set to 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialColor(long,long,int,int,long)">
<h3>naiGetMaterialColor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialColor</span><wbr><span class="parameters">(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialColor(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIColor4D)"><code>GetMaterialColor</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialColor(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIColor4D)">
<h3>aiGetMaterialColor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialColor</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIColor4D.html" title="class in org.lwjgl.assimp">AIColor4D</a>&nbsp;pOut)</span></div>
<div class="block">Retrieve a color value with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a color to receive the result.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output struct remains unmodified.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialColor(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.assimp.AIColor4D)">
<h3>aiGetMaterialColor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialColor</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIColor4D.html" title="class in org.lwjgl.assimp">AIColor4D</a>&nbsp;pOut)</span></div>
<div class="block">Retrieve a color value with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a color to receive the result.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output struct remains unmodified.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialUVTransform(long,long,int,int,long)">
<h3>naiGetMaterialUVTransform</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialUVTransform</span><wbr><span class="parameters">(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialUVTransform(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIUVTransform)"><code>GetMaterialUVTransform</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialUVTransform(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIUVTransform)">
<h3>aiGetMaterialUVTransform</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialUVTransform</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIUVTransform.html" title="class in org.lwjgl.assimp">AIUVTransform</a>&nbsp;pOut)</span></div>
<div class="block">Retrieve a UVTransform value with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a <a href="AIUVTransform.html" title="class in org.lwjgl.assimp"><code>AIUVTransform</code></a> to receive the result.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output struct remains unmodified.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialUVTransform(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.assimp.AIUVTransform)">
<h3>aiGetMaterialUVTransform</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialUVTransform</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIUVTransform.html" title="class in org.lwjgl.assimp">AIUVTransform</a>&nbsp;pOut)</span></div>
<div class="block">Retrieve a UVTransform value with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a <a href="AIUVTransform.html" title="class in org.lwjgl.assimp"><code>AIUVTransform</code></a> to receive the result.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output struct remains unmodified.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialString(long,long,int,int,long)">
<h3>naiGetMaterialString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialString</span><wbr><span class="parameters">(long&nbsp;pMat,
 long&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;pOut)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialString(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIString)"><code>GetMaterialString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialString(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,org.lwjgl.assimp.AIString)">
<h3>aiGetMaterialString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialString</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;pOut)</span></div>
<div class="block">Retrieve a string value with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a string to receive the result.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output struct remains unmodified.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialString(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,org.lwjgl.assimp.AIString)">
<h3>aiGetMaterialString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialString</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;pOut)</span></div>
<div class="block">Retrieve a string value with a specific key from a material.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>pKey</code> - Key to search for. One of the AI_MATKEY_XXX constants.</dd>
<dd><code>type</code> - Specifies the type of the texture to be retrieved. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture to be retrieved.</dd>
<dd><code>pOut</code> - Pointer to a string to receive the result.</dd>
<dt>Returns:</dt>
<dd>Specifies whether the key has been found. If not, the output struct remains unmodified.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialTextureCount(long,int)">
<h3>naiGetMaterialTextureCount</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialTextureCount</span><wbr><span class="parameters">(long&nbsp;pMat,
 int&nbsp;type)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialTextureCount(org.lwjgl.assimp.AIMaterial,int)"><code>GetMaterialTextureCount</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialTextureCount(org.lwjgl.assimp.AIMaterial,int)">
<h3>aiGetMaterialTextureCount</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialTextureCount</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 int&nbsp;type)</span></div>
<div class="block">Get the number of textures for a particular texture type.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>type</code> - Texture type to check for. One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dt>Returns:</dt>
<dd>Number of textures for this type.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetMaterialTexture(long,int,int,long,long,long,long,long,long,long)">
<h3>naiGetMaterialTexture</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">naiGetMaterialTexture</span><wbr><span class="parameters">(long&nbsp;pMat,
 int&nbsp;type,
 int&nbsp;index,
 long&nbsp;path,
 long&nbsp;mapping,
 long&nbsp;uvindex,
 long&nbsp;blend,
 long&nbsp;op,
 long&nbsp;mapmode,
 long&nbsp;flags)</span></div>
<div class="block">Unsafe version of: <a href="#aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialTexture</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer)">
<h3>aiGetMaterialTexture</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialTexture</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;path,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;mapping,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;uvindex,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/FloatBuffer.html" title="class or interface in java.nio" class="external-link">FloatBuffer</a>&nbsp;blend,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;op,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;mapmode,
 @Nullable
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/IntBuffer.html" title="class or interface in java.nio" class="external-link">IntBuffer</a>&nbsp;flags)</span></div>
<div class="block">Helper function to get all values pertaining to a particular
 texture slot from a material structure.
 
 <p>This function is provided just for convenience. You could also read the
 texture by parsing all of its properties manually. This function bundles
 all of them in a huge function monster.</p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pMat</code> - Pointer to the input material. May not be <code>NULL</code></dd>
<dd><code>type</code> - Specifies the texture stack to read from (e.g. diffuse, specular, height map ...). One of:<br><table><tr><td><a href="#aiTextureType_NONE"><code>TextureType_NONE</code></a></td><td><a href="#aiTextureType_DIFFUSE"><code>TextureType_DIFFUSE</code></a></td><td><a href="#aiTextureType_SPECULAR"><code>TextureType_SPECULAR</code></a></td></tr><tr><td><a href="#aiTextureType_AMBIENT"><code>TextureType_AMBIENT</code></a></td><td><a href="#aiTextureType_EMISSIVE"><code>TextureType_EMISSIVE</code></a></td><td><a href="#aiTextureType_HEIGHT"><code>TextureType_HEIGHT</code></a></td></tr><tr><td><a href="#aiTextureType_NORMALS"><code>TextureType_NORMALS</code></a></td><td><a href="#aiTextureType_SHININESS"><code>TextureType_SHININESS</code></a></td><td><a href="#aiTextureType_OPACITY"><code>TextureType_OPACITY</code></a></td></tr><tr><td><a href="#aiTextureType_DISPLACEMENT"><code>TextureType_DISPLACEMENT</code></a></td><td><a href="#aiTextureType_LIGHTMAP"><code>TextureType_LIGHTMAP</code></a></td><td><a href="#aiTextureType_REFLECTION"><code>TextureType_REFLECTION</code></a></td></tr><tr><td><a href="#aiTextureType_BASE_COLOR"><code>TextureType_BASE_COLOR</code></a></td><td><a href="#aiTextureType_NORMAL_CAMERA"><code>TextureType_NORMAL_CAMERA</code></a></td><td><a href="#aiTextureType_EMISSION_COLOR"><code>TextureType_EMISSION_COLOR</code></a></td></tr><tr><td><a href="#aiTextureType_METALNESS"><code>TextureType_METALNESS</code></a></td><td><a href="#aiTextureType_DIFFUSE_ROUGHNESS"><code>TextureType_DIFFUSE_ROUGHNESS</code></a></td><td><a href="#aiTextureType_AMBIENT_OCCLUSION"><code>TextureType_AMBIENT_OCCLUSION</code></a></td></tr><tr><td><a href="#aiTextureType_SHEEN"><code>TextureType_SHEEN</code></a></td><td><a href="#aiTextureType_CLEARCOAT"><code>TextureType_CLEARCOAT</code></a></td><td><a href="#aiTextureType_TRANSMISSION"><code>TextureType_TRANSMISSION</code></a></td></tr><tr><td><a href="#aiTextureType_UNKNOWN"><code>TextureType_UNKNOWN</code></a></td></tr></table></dd>
<dd><code>index</code> - Index of the texture. The function fails if the requested index is not available for this texture type.</dd>
<dd><code>path</code> - Receives the output path. This parameter must be non-null.</dd>
<dd><code>mapping</code> - The texture mapping mode to be used. Pass <code>NULL</code> if you're not interested in this information.</dd>
<dd><code>uvindex</code> - For UV-mapped textures: receives the index of the UV source channel. Unmodified otherwise.</dd>
<dd><code>blend</code> - Receives the blend factor for the texture. Pass <code>NULL</code> if you're not interested in this information.</dd>
<dd><code>op</code> - Receives the texture blend operation to be perform between this texture and the previous texture. Pass <code>NULL</code> if you're not interested in this
                information.</dd>
<dd><code>mapmode</code> - Receives the mapping modes to be used for the texture. Pass <code>NULL</code> if you're not interested in this information. Otherwise, pass a pointer to an
                array of two <code>aiTextureMapMode</code>'s (one for each axis, UV order).</dd>
<dd><code>flags</code> - Receives the texture flags.</dd>
<dt>Returns:</dt>
<dd><a href="#aiReturn_SUCCESS"><code>Return_SUCCESS</code></a> on success, otherwise something else. Have fun.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetLegalString()">
<h3>naiGetLegalString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiGetLegalString</span>()</div>
<div class="block">Unsafe version of: <a href="#aiGetLegalString()"><code>GetLegalString</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetLegalString()">
<h3>aiGetLegalString</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">aiGetLegalString</span>()</div>
<div class="block">Returns a string with legal copyright and licensing information about Assimp. The string may include multiple lines.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>A string containing the legal information.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetVersionPatch()">
<h3>aiGetVersionPatch</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetVersionPatch</span>()</div>
<div class="block">Returns the current patch version number of Assimp.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>patch version of the Assimp runtime the application was linked/built against</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetVersionMinor()">
<h3>aiGetVersionMinor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetVersionMinor</span>()</div>
<div class="block">Returns the current minor version number of Assimp.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>minor version of the Assimp runtime the application was linked/built against</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetVersionMajor()">
<h3>aiGetVersionMajor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetVersionMajor</span>()</div>
<div class="block">Returns the current major version number of Assimp.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>major version of the Assimp runtime the application was linked/built against</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetVersionRevision()">
<h3>aiGetVersionRevision</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetVersionRevision</span>()</div>
<div class="block">Returns the repository revision of the Assimp runtime.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>SVN Repository revision number of the Assimp runtime the application was linked/built against.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="naiGetBranchName()">
<h3>naiGetBranchName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">naiGetBranchName</span>()</div>
<div class="block">Unsafe version of: <a href="#aiGetBranchName()"><code>GetBranchName</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetBranchName()">
<h3>aiGetBranchName</h3>
<div class="member-signature"><span class="annotations">@Nullable
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">aiGetBranchName</span>()</div>
<div class="block">Returns the branch name of the Assimp runtime.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the current branch name</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiGetCompileFlags()">
<h3>aiGetCompileFlags</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetCompileFlags</span>()</div>
<div class="block">Returns assimp's compile flags.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>any bitwise combination of the <code>ASSIMP_CFLAGS_xxx</code> constants.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,float[],org.lwjgl.assimp.AIVector3D)">
<h3>aiMatrix4DecomposeIntoScalingAxisAnglePosition</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">aiMatrix4DecomposeIntoScalingAxisAnglePosition</span><wbr><span class="parameters">(<a href="AIMatrix4x4.html" title="class in org.lwjgl.assimp">AIMatrix4x4</a>&nbsp;mat,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;scaling,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;axis,
 float[]&nbsp;angle,
 <a href="AIVector3D.html" title="class in org.lwjgl.assimp">AIVector3D</a>&nbsp;position)</span></div>
<div class="block">Array version of: <a href="#aiMatrix4DecomposeIntoScalingAxisAnglePosition(org.lwjgl.assimp.AIMatrix4x4,org.lwjgl.assimp.AIVector3D,org.lwjgl.assimp.AIVector3D,java.nio.FloatBuffer,org.lwjgl.assimp.AIVector3D)"><code>Matrix4DecomposeIntoScalingAxisAnglePosition</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,float[],int[])">
<h3>aiGetMaterialFloatArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialFloatArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 float[]&nbsp;pOut,
 @Nullable
 int[]&nbsp;pMax)</span></div>
<div class="block">Array version of: <a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)"><code>GetMaterialFloatArray</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,float[],int[])">
<h3>aiGetMaterialFloatArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialFloatArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 float[]&nbsp;pOut,
 @Nullable
 int[]&nbsp;pMax)</span></div>
<div class="block">Array version of: <a href="#aiGetMaterialFloatArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.FloatBuffer,java.nio.IntBuffer)"><code>GetMaterialFloatArray</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,int[],int[])">
<h3>aiGetMaterialIntegerArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialIntegerArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 int[]&nbsp;pOut,
 @Nullable
 int[]&nbsp;pMax)</span></div>
<div class="block">Array version of: <a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialIntegerArray</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.lang.CharSequence,int,int,int[],int[])">
<h3>aiGetMaterialIntegerArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialIntegerArray</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/CharSequence.html" title="class or interface in java.lang" class="external-link">CharSequence</a>&nbsp;pKey,
 int&nbsp;type,
 int&nbsp;index,
 int[]&nbsp;pOut,
 @Nullable
 int[]&nbsp;pMax)</span></div>
<div class="block">Array version of: <a href="#aiGetMaterialIntegerArray(org.lwjgl.assimp.AIMaterial,java.nio.ByteBuffer,int,int,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialIntegerArray</code></a></div>
</section>
</li>
<li>
<section class="detail" id="aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,int[],int[],float[],int[],int[],int[])">
<h3>aiGetMaterialTexture</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">aiGetMaterialTexture</span><wbr><span class="parameters">(<a href="AIMaterial.html" title="class in org.lwjgl.assimp">AIMaterial</a>&nbsp;pMat,
 int&nbsp;type,
 int&nbsp;index,
 <a href="AIString.html" title="class in org.lwjgl.assimp">AIString</a>&nbsp;path,
 @Nullable
 int[]&nbsp;mapping,
 @Nullable
 int[]&nbsp;uvindex,
 @Nullable
 float[]&nbsp;blend,
 @Nullable
 int[]&nbsp;op,
 @Nullable
 int[]&nbsp;mapmode,
 @Nullable
 int[]&nbsp;flags)</span></div>
<div class="block">Array version of: <a href="#aiGetMaterialTexture(org.lwjgl.assimp.AIMaterial,int,int,org.lwjgl.assimp.AIString,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.IntBuffer,java.nio.IntBuffer)"><code>GetMaterialTexture</code></a></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><i>Copyright LWJGL. All Rights Reserved. <a href="https://www.lwjgl.org/license">License terms</a>.</i></small></p>
</footer>
</div>
</div>
</body>
</html>
